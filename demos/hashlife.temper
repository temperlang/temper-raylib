
let {...} = import("../rl/raylib.temper");

var hashtable = new MapBuilder<Int, ListBuilder<Node>>();
var heat = 0;

var pow2 = new ListBuilder<Int>();
var cur = 1;
for (var i = 0; i < 32; i++) {
  pow2.add(cur);
  cur += cur;
}

let idString(s: String): String {
  return s;
}

let saveTable(): String {
  var ret = new ListBuilder<String>();
  var items = hashtable.toList();
  for (var i = 0; i < items.length; i++) {
    var key = items[i].key;
    var values = hashtable[key];
    if (i != 0) {
      ret.add("#");
    }
    ret.add(key.toString());
    ret.add("=");
    for (var j = 0; j < values.length; j++) {
      if (j != 0) {
        ret.add(".")
      }
      ret.add(values[j].toJson());
    }
  }
  return ret.join("", idString);
}

class DrawConfig {
  public screen: Rectangle;
}

let nodeToJsonRef(n: Node): String {
  return n.toJsonRef();
}

interface Node {
  public level: Int;
  public pop: Int;
  public a: Node;
  public b: Node;
  public c: Node;
  public d: Node;
  public hash: Int;
  public next: Node = null;
  public succ: ListBuilder<Node>;

  public setNext(n: Node): Void;
  public setSucc(j: Int, n: Node): Void;
  public eq(other: Node): Boolean;
  public draw(config: DrawConfig, bounds: Rectangle): Void;
  
  public toJson(): String;
  public toJsonRef(): String;
}

class RealNode extends Node {
  public level: Int;
  public pop: Int;
  public a: Node;
  public b: Node;
  public c: Node;
  public d: Node;
  public hash: Int;
  public next: Node;
  public succ: ListBuilder<Node>;
  
  constructor(level: Int, pop: Int, a: Node, b: Node, c: Node, d: Node, hash: Int): Void {
    this.level = level;
    this.pop = pop;
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.hash = hash;
    next = fake;
    succ = new ListBuilder<Node>();
  }

  public toJson(): String {
    var parts = [
      level.toString(),
      pop.toString(),
      a.toJsonRef(),
      b.toJsonRef(),
      c.toJsonRef(),
      d.toJsonRef(),
      next.toJsonRef(),
      succ.join(",", nodeToJsonRef),
    ];
    return parts.join(";", idString);
  }

  public toJsonRef(): String {
    var ent = hashtable[hash];
    for (var i = 0; i < ent.length; i++) {
      if (ent[i] == this) {
        return "${hash.toString()}>${i.toString()}";
      }
    }
    return "???";
  }

  public setNext(n: Node): Void {
    next = n;
  }

  public setSucc(j: Int, n: Node): Void {
    while (succ.length <= j) {
      succ.add(fake);
    }
    succ[j] = n;
  }

  public eq(other: Node): Boolean {
    if (level != other.level) {
      return false;
    }
    if (level == 0) {
      return other.level == 0 && other.pop == pop;
    }
    if (other.pop != pop) {
      return false;
    }
    // for (var i = 0; i < 4; i++) {
    //   if (children[i] != other.children[i]) {
    //     return false;
    //   }
    // }
    return a == other.a && b == other.b && c == other.c && d == other.d;
  }

  public draw(config: DrawConfig, base: Rectangle): Void {
    if (!CheckCollisionRecs(config.screen, base)) {
      return;
    }
    if (pop == 0) {
      // DrawRectangleRec(
      //   new Rectangle(
      //     base.x.max(config.screen.x),
      //     base.y.max(config.screen.y),
      //     base.width.min(config.screen.width),
      //     base.height.min(config.screen.height),
      //   ),
      //   BLACK,
      // );
    } else if (level == 0 || base.width < 2.0) {
      DrawRectangleRec(
        new Rectangle(
          base.x.max(config.screen.x),
          base.y.max(config.screen.y),
          base.width.min(config.screen.width),
          base.height.min(config.screen.height),
        ),
        WHITE,
      );
    } else {
      var halfWidth = base.width * 0.5;
      var halfHeight = base.height * 0.5;
      a.draw(config, new Rectangle(base.x, base.y, halfWidth, halfHeight));
      b.draw(config, new Rectangle(base.x + halfWidth, base.y, halfWidth, halfHeight));
      c.draw(config, new Rectangle(base.x, base.y + halfHeight, halfWidth, halfHeight));
      d.draw(config, new Rectangle(base.x + halfWidth, base.y + halfHeight, halfWidth, halfHeight));
    }
  }
}

class FakeNode extends Node {
  public level: Int;
  public pop: Int;
  public a: Node;
  public b: Node;
  public c: Node;
  public d: Node;
  public hash: Int;
  public next: Node;
  public succ: ListBuilder<Node>;

  constructor(): Void {}

  public toJson(): String {
    return "???";
  }
  
  public toJsonRef(): String {
    return "???";
  }
  
  public setNext(n: Node): Void {}
  public setSucc(j: Int, n: Node): Void {}
  public eq(other: Node): Boolean {
    return this == other;
  }
  public draw(config: DrawConfig, bounds: Rectangle): Void {}
}

var fake = new FakeNode();
var off = new RealNode(0, 0, fake, fake, fake, fake, 1);
var on = new RealNode(0, 1, fake, fake, fake, fake, 2);

enter(on);
enter(off);

let enter(node: Node): Node {
  var got = hashtable[node.hash] orelse new ListBuilder<Node>();
  for (var i = got.length - 1; i >= 0; i--) {
    var cur = got.getOr(i, node);
    if (node.eq(cur)) {
      return cur;
    }
  }
  heat += 1;
  got.add(node);
  hashtable[node.hash] = got;
  return node;
}


let join(a: Node, b: Node, c: Node, d: Node): Node {
  var pop = a.pop + b.pop + c.pop + d.pop;
  var next = (
    a.level
    + 2531198185803 * pop
    + 5131830419411 * a.hash
    + 3758991985019 * b.hash
    + 8973110871315 * c.hash
    + 4318490180473 * d.hash
  );
  return enter(new RealNode(a.level + 1, pop, a, b, c, d, next % 2147483648));
}

let zero(level: Int): Node {
  if (level == 0) {
    return off;
  } else {
    var val = zero(level-1);
    return join(val, val, val, val);
  }
}

let random(level: Int): Node {
  if (level == 0) {
    if (GetRandomValue(0, 5) == 0) {
      return on
    } else {
      return off;
    }
  } else {
    return join(random(level-1), random(level-1), random(level-1), random(level-1));
  }
}

let center(node: Node): Node {
  var z = zero(node.level - 1);
  return join(
    join(z, z, z, node.a), join(z, z, node.b, z),
    join(z, node.c, z, z), join(node.d, z, z, z),
  );
}

let lifeRule(a: Node, b: Node, c: Node, d: Node, e: Node, f: Node, g: Node, h: Node, i: Node): Node {
  var outer = a.pop + b.pop + c.pop + d.pop + f.pop + g.pop + h.pop + i.pop;
  if ((outer == 2 && e.pop != 0) || outer == 3) {
    return on;
  } else {
    return off;
  }
}


let life2(m: Node): Node {
  var ad = lifeRule(
    m.a.a, m.a.b, m.b.a,
    m.a.c, m.a.d, m.b.c,
    m.c.a, m.c.b, m.d.a
  );
  var bc = lifeRule(
    m.a.b, m.b.a, m.b.b,
    m.a.d, m.b.c, m.b.d,
    m.c.b, m.d.a, m.d.b
  );
  var cb = lifeRule(
    m.a.c, m.a.d, m.b.c,
    m.c.a, m.c.b, m.d.a,
    m.c.c, m.c.d, m.d.c
  );
  var da = lifeRule(
    m.a.d, m.b.c, m.b.d,
    m.c.b, m.d.a, m.d.b,
    m.c.d, m.d.c, m.d.d
  );
  return join(ad, bc, cb, da);
}

let nextGen(m: Node): Node {
  if (m.next == fake) {
    var next = nextGenImpl(m);
    m.setNext(next);
    return next;
  } else {
    return m.next;
  }
}

let nextGenImpl(m: Node): Node {
  if (m.pop == 0) {
    return m.a;
  } else if (m.level == 2) {
    return life2(m);
  } else {
    var c1 = nextGen(join(m.a.a, m.a.b, m.a.c, m.a.d));
    var c2 = nextGen(join(m.a.b, m.b.a, m.a.d, m.b.c));
    var c3 = nextGen(join(m.b.a, m.b.b, m.b.c, m.b.d));
    var c4 = nextGen(join(m.a.c, m.a.d, m.c.a, m.c.b));
    var c5 = nextGen(join(m.a.d, m.b.c, m.c.b, m.d.a));
    var c6 = nextGen(join(m.b.c, m.b.d, m.d.a, m.d.b));
    var c7 = nextGen(join(m.c.a, m.c.b, m.c.c, m.c.d));
    var c8 = nextGen(join(m.c.b, m.d.a, m.c.d, m.d.c));
    var c9 = nextGen(join(m.d.a, m.d.b, m.d.c, m.d.d));

    return join(
      (join(c1.d, c2.c, c4.b, c5.a)),
      (join(c2.d, c3.c, c5.b, c6.a)),
      (join(c4.d, c5.c, c7.b, c8.a)),
      (join(c5.d, c6.c, c8.b, c9.a)),
    );
  }
}

let successor(m: Node, j: Int): Node {
  if (j == 0) {
    return nextGen(m);
  }
  var mSucc = m.succ.getOr(j, fake); 
  if (mSucc == fake) {
    var succ = successorImpl(m, j);
    m.setSucc(j, succ);
    return succ;
  } else {
    return mSucc;
  }
}

let successorImpl(m: Node, j: Int): Node {
  if (m.pop == 0) {
    return m.a;
  } else if (m.level == 2) {
    return life2(m);
  } else {
    if (j > m.level - 2) {
      j = m.level - 2;
    }
    var c1 = successor(join(m.a.a, m.a.b, m.a.c, m.a.d), j);
    var c2 = successor(join(m.a.b, m.b.a, m.a.d, m.b.c), j);
    var c3 = successor(join(m.b.a, m.b.b, m.b.c, m.b.d), j);
    var c4 = successor(join(m.a.c, m.a.d, m.c.a, m.c.b), j);
    var c5 = successor(join(m.a.d, m.b.c, m.c.b, m.d.a), j);
    var c6 = successor(join(m.b.c, m.b.d, m.d.a, m.d.b), j);
    var c7 = successor(join(m.c.a, m.c.b, m.c.c, m.c.d), j);
    var c8 = successor(join(m.c.b, m.d.a, m.c.d, m.d.c), j);
    var c9 = successor(join(m.d.a, m.d.b, m.d.c, m.d.d), j);

    if (j < m.level - 2) {
      return join(
        join(c1.d, c2.c, c4.b, c5.a),
        join(c2.d, c3.c, c5.b, c6.a),
        join(c4.d, c5.c, c7.b, c8.a),
        join(c5.d, c6.c, c8.b, c9.a),
      );
    } else {
      return join(
        successor(join(c1, c2, c4, c5), j),
        successor(join(c2, c3, c5, c6), j),
        successor(join(c4, c5, c7, c8), j),
        successor(join(c5, c6, c8, c9), j),
      );
    }
  }
}

let subRandom(n: Int, subs: Int): Node {
  if (subs == 0) {
    return random(n);
  } else {
    var v1 = subRandom(n - 1, subs-1);
    var v2 = subRandom(n - 1, subs-1);
    return join(v1, v2, v2, v1);
  }
}

let nodeForBit(n: Boolean): Node {
  if (n) {
    return on;
  } else {
    return off;
  }
}

let copyWithRangeSet(grid0: Node, low: List<Int>, high: List<Int>, data: Listed<DenseBitVector>): Node {
  var low0 = low[0];
  var low1 = low[1];
  var high0 = high[0];
  var high1 = high[1];

  let go(grid: Node, x: Int, y: Int, size: Int): Node {
    if (x >= high0 || x + size <= low0 || y >= high1 || y + size <= low1) {
      return grid;
    }
    
    if (grid.level == 0) {
      if (data[y - low1][x - low0]) {
        return on;
      } else {
        return off;
      }
    }
    
    var halfSize = size / 2;
    var xh = x + halfSize;
    var yh = y + halfSize;
    return join(
      go(grid.a, x, y, halfSize),
      go(grid.b, xh, y, halfSize),
      go(grid.c, x, yh, halfSize),
      go(grid.d, xh, yh, halfSize),
    );
  }

  return go(grid0, 0, 0, pow2[grid0.level]);
}

class Game {
  public grid: Node;
  
  constructor(args: Listed<String>) {
    var sizeLog2 = args[0].toInt() orelse 16;
    var size = pow2[sizeLog2];
    grid = zero(sizeLog2);
  }

  public clear(): Void {
    grid = zero(grid.level);
  }

  public addData(size: List<Int>, data: Listed<DenseBitVector>, pos: List<Int>): Void {
    grid = copyWithRangeSet(grid, pos, [pos[0] + size[0], pos[1] + size[1]], data);
  }

  public addBuilder(builder: LifeBuilder, pos: List<Int>): Void {
    addData(builder.size, builder.buildBits(), pos);
  }

  public draw(bounds: Rectangle): Void {
    var screen = new Rectangle(0.0, 0.0, GetScreenWidth().toFloat64(), GetScreenHeight().toFloat64());
    var config = new DrawConfig(screen);
    DrawRectangleRec(bounds, BLACK);
    grid.draw(config, bounds);
  }

  public update(): Void {
    grid = nextGen(center(grid));
  }

  public warp(n: Int): Int {
    grid = successor(center(grid), n);
    if (n < grid.level - 2) {
      return n;
    } else {
      return grid.level - 2;
    }
  }
}

class LifeBuilder {
  public width: Int;
  private data: ListBuilder<DenseBitVector>;
  
  public doFlipX: Boolean;
  public doFlipY: Boolean;
  
  private node: Node;
  private builtNode: Boolean;

  public constructor() {
    width = 0;
    data = new ListBuilder<DenseBitVector>();
    doFlipX = false;
    doFlipY = false;
    clear();
  }

  private clear(): Void {
    builtNode = false;
  }

  public flipX(): Void {
    clear();
    doFlipX = !doFlipX;
  }

  public flipY(): Void {
    clear();
    doFlipY = !doFlipY;
  }

  public get height(): Int {
    return data.length;
  }

  public get size(): List<Int> {
    return [width, height];
  }

  public buildNode(): Node {
    if (!builtNode) {
      var startTime = GetTime();
      builtNode = true;
      var sizeMax = if (size[0] < size[1]) { size[1] } else { size[0] };
      var empty: Node = off;
      while (pow2[empty.level] < sizeMax) {
        empty = join(empty, empty, empty, empty);
      }
      var start = [
        (size[0] - sizeMax) / 2,
        (size[1] - sizeMax) / 2,
      ];
      var stop = [
        start[0] + size[0],
        start[1] + size[1],
      ];
      node = copyWithRangeSet(empty, start, stop, buildBits());
      var endTime = GetTime();
    }
    return node;
  }

  public add(t: DenseBitVector, len: Int): Void {
    if (len > width) {
      width = len;
    }
    data.add(t);
  }
  
  public buildBits(): Listed<DenseBitVector> {
    return data;
  }
}

class Pattern {
  public name: String;
  public builder: LifeBuilder;
  private doNotDraw: Boolean;
  private hasTexture: Boolean;
  private texture: RenderTexture2D;

  public get size(): List<Int> {
    return builder.size;
  }

  public constructor(nameArg: String, builderArg: LifeBuilder) {
    name = nameArg;
    builder = builderArg;
    // doNotDraw = builder.size[0] * builder.size[1] > 1000000;
    doNotDraw = false;
    hasTexture = false;
  }

  public drawTool(bounds: Rectangle, selected: Boolean): Boolean {
    if (selected) {
      DrawRectangleRec(bounds, new Color(32, 128, 32, 255));
    } else {
      DrawRectangleRec(bounds, new Color(32, 32, 32, 255));
    }
    var border = 0.1;
    bounds = new Rectangle(
      bounds.x + bounds.width * border,
      bounds.y + bounds.height * border,
      bounds.width * (1.0 - border * 2.0),
      bounds.height * (1.0 - border * 2.0),
    );
    if (doNotDraw) {
      DrawRectangleRec(bounds, new Color(255, 128, 32, 255));
    } else {
      var size = builder.width.toFloat64().max(builder.height.toFloat64());
      var textureBounds = new Rectangle(0.0, 0.0, size, size);
      if (!hasTexture) {
        hasTexture = true;
        texture = LoadRenderTexture(builder.width, builder.height);
        BeginTextureMode(texture);
        DrawRectangleRec(textureBounds, BLACK);
        var built = builder.buildBits();
        for (var y = 0; y < builder.height; y += 1) {
          var row = built[y];
          for (var x = 0; x < builder.width; x += 1) {
            if (row[x]) {
              DrawPixel(x, y, WHITE);
            }
          }
        }
        EndTextureMode();
      }
      var b = new Rectangle(0.0, 0.0, builder.width.toFloat64(), builder.height.toFloat64());
      if (builder.doFlipX) {
        b.x = b.width - 1.0;
        b.width = -b.width;
      }
      if (builder.doFlipY) {
        b.y = b.height - 1.0;
        b.height = -b.height;
      }
      DrawTexturePro(texture.texture, b, bounds, new Vector2(0.0, 0.0), 0.0, WHITE);
    }
    var mouse = GetMousePosition();
    if (CheckCollisionPointRec(mouse, bounds)) {
      if (IsMouseButtonPressed(0)) {
        return true;
      }
    }
    return false;
  }
}

let stringToPattern(text: String): Pattern {
  var name = "???";
  var csl = 0;
  var cs = new DenseBitVector(0);
  var builder = new LifeBuilder();
  var split = text.split("\n");
  var numEmpty = 0;
  for (var i = 0; i < split.length; i++) {
    var cur = split[i].codePoints;
    if (cur.hasAtLeast(1)) {
      if (cur.read() == /* x */ 120) {
        continue;
      }
      if (cur.read() == /* # */ 35) {
        var type = cur.advance(1).read();
        if (type == /* N */ 78) {
          var hack = split[i].split("#N");
          name = hack[hack.length - 1];
        }
        continue;
      }
    }
    while (!cur.isEmpty) {
      var code = cur.read();
      var n = 1;
      if (48 <= code && code < 58) {
        n = 0;
        while (48 <= code && code < 58) {
          n *= 10;
          n += code - 48;
          cur = cur.advance(1);
          code = cur.read();
          if (cur.isEmpty) {
            break;
          }
        }
      }
      cur = cur.advance(1);
      if (code == /* b */ 98) {
        for (var i = 0; i < n; i++) {
          cs[csl++] = false;
        }
      }
      if (code == /* o */ 111) {
        for (var i = 0; i < n; i++) {
          cs[csl++] = true;
        }
      }
      if (code == /* $ */ 36 || code == /* ! */ 33) {
        for (var i = 0; i < n; i++) {
          if (csl == 0) {
            numEmpty += 1;
          }
          builder.add(cs, csl);
          csl = 0;
          cs = new DenseBitVector(0);
        }
      }
    }
  }
  if (csl != 0) {
    console.log("${name} failed with ${csl.toString()} data");
    bubble();
  }
  return new Pattern(name, builder);
}

class SimpleCamera {
  public target: Vector2;
  public zoom: Float64;
  public cells: Int;
  public screenSize: Vector2;

  constructor(maxLevel: Int) {
    zoom = 1.0;
    target = new Vector2(0.0, 0.0);
    cells = pow2[maxLevel];
  }

  public update(): Void {
    screenSize = new Vector2(GetScreenWidth().toFloat64(), GetScreenHeight().toFloat64());
  }

  public get size(): Float64 {
    return screenSize.x.max(screenSize.y);
  }

  public screenToLife(x: Float64, y: Float64): List<Int> {
    var xProgress = (x / zoom - target.x) / size;
    var yProgress = (y / zoom - target.y) / size;
    return [
      (xProgress * cells.toFloat64()).toInt(),
      (yProgress * cells.toFloat64()).toInt(),
    ];
  }

  public lifeToScreen(life: List<Int>): Vector2 {
    var xProgress = life[0].toFloat64() / cells.toFloat64();
    var yProgress = life[1].toFloat64() / cells.toFloat64();
    return new Vector2(
      xProgress * (size * zoom) - target.x * zoom,
      yProgress * (size * zoom) - target.y * zoom,
    );
  }

  public zoomBy(wheel: Float64, center: Vector2): Void {
    var next = wheel * 0.2;
    target.x = target.x - next * center.x / zoom;
    target.y = target.y - next * center.y / zoom;
    zoom = zoom * (1.0 + next);
  }

  public moveBy(dist: Vector2): Void {
    target.x = target.x + dist.x / zoom;
    target.y = target.y + dist.y / zoom;
  }
}

let patterns(): List<Pattern> {
  return LoadFileText("demos/patterns.har").split("\n--- header ---\n").map(stringToPattern);
}

export let main(args: Listed<String>): Void | Bubble {
  SetTraceLogLevel(LOG_WARNING);
  
  var allPatterns = patterns();
  var patternHead = 0;
  var patterns = new ListBuilder<Pattern>();
  if (allPatterns.length != 0) {
    for (var i = patternHead; i < patternHead + 10; i++) {
      patterns.add(allPatterns[(i + allPatterns.length) % allPatterns.length]);
    }
  }
  var selectedEnt: Pattern | Null = null;

  var bench = (args[0] == "--bench") orelse false;
  if (bench) {
    SetConfigFlags(FLAG_WINDOW_RESIZABLE);
    args = args.slice(1, args.length);
  } else {
    SetConfigFlags(FLAG_WINDOW_RESIZABLE | FLAG_VSYNC_HINT);
  }

  InitWindow(960, 540, "Conway's Game of LIFE");
  var game = new Game(args);

  var paused = false;
  var rate = 1.0;
  var steps = 0;

  var camera = new SimpleCamera(game.grid.level);

  var nextTime = GetTime() + 1.0 / rate;

  var realHeat = heat;

  while (!WindowShouldClose()) {
    camera.update();

    var wheel = GetMouseWheelMove();
    if (wheel != 0.0) {
      camera.zoomBy(wheel, new Vector2(GetMouseX().toFloat64(), GetMouseY().toFloat64()));
    }

    if (IsMouseButtonDown(1)) {
      camera.moveBy(GetMouseDelta());
    }

    BeginDrawing();
    ClearBackground(new Color(32, 32, 32, 255));
    var gameBounds = new Rectangle(
      camera.target.x * camera.zoom,
      camera.target.y * camera.zoom,
      camera.size * camera.zoom,
      camera.size * camera.zoom,
    );
    game.draw(gameBounds);
    DrawFPS(20, 20);
    var n = 1;
    for (var i = 0; n < realHeat; i += 1) {
      DrawRectangleRec(new Rectangle(20.0, 50.0 + i.toFloat64() * 30.0, 20.0, 20.0), RED);
      n *= 2;
    }
    DrawText("${rate.toString()} hz * ${pow2[steps].toString()} warp", 120, 20, 20, WHITE);
    var entWidth = (GetScreenHeight().toFloat64() * 0.1).min(GetScreenWidth().toFloat64() / patterns.length.toFloat64());
    var mouse = GetMousePosition();
    var drawSelectedEnt = true;
    var clickWasEnts = false;
    var toolText = "";
    for (var i = 0; i < patterns.length; i++) {
      var bounds = new Rectangle(i.toFloat64() * entWidth, GetScreenHeight().toFloat64() - entWidth, entWidth, entWidth);
      if (CheckCollisionPointRec(mouse, bounds)) {
        clickWasEnts = true;
        drawSelectedEnt = false;
        toolText = patterns[i].name;
      }
      if (patterns[i].drawTool(bounds, selectedEnt == patterns[i])) {
        if (selectedEnt == patterns[i]) {
          selectedEnt = null;
        } else {
          selectedEnt = patterns[i];
        }
      }
    }
    if (toolText != "") {
      var width = MeasureText(toolText, 20);
      DrawRectangleRec(new Rectangle(mouse.x + 2.0, mouse.y - 16.0, width.toFloat64() + 4.0, 24.0), new Color(0, 0, 0, 192));
      DrawText(toolText, mouse.x.toInt() + 8, mouse.y.toInt() - 16, 20, WHITE);
    }
    if (!clickWasEnts && selectedEnt != null) {
      var boundsFlipX1 = new Rectangle(GetScreenWidth().toFloat64() - 50.0, 10.0, 20.0, 40.0);
      var boundsFlipX2 = new Rectangle(GetScreenWidth().toFloat64() - 30.0, 10.0, 20.0, 40.0);
      DrawRectangleRec(boundsFlipX1, GREEN);
      DrawRectangleRec(boundsFlipX2, RED);
      var inBounds = CheckCollisionPointRec(mouse, boundsFlipX1) || CheckCollisionPointRec(mouse, boundsFlipX2);
      if (inBounds) {
        drawSelectedEnt = false;
        if (IsMouseButtonPressed(0)) {
          selectedEnt.as<Pattern>().builder.flipX();
          clickWasEnts = true;  
        }
      }
    }
    if (!clickWasEnts && selectedEnt != null) {
      var boundsFlipY1 = new Rectangle(GetScreenWidth().toFloat64() - 100.0, 10.0, 40.0, 20.0);
      var boundsFlipY2 = new Rectangle(GetScreenWidth().toFloat64() - 100.0, 30.0, 40.0, 20.0);
      DrawRectangleRec(boundsFlipY1, GREEN);
      DrawRectangleRec(boundsFlipY2, RED);
      var inBounds = CheckCollisionPointRec(mouse, boundsFlipY1) || CheckCollisionPointRec(mouse, boundsFlipY2);
      if (inBounds) {
        drawSelectedEnt = false;
        if (IsMouseButtonPressed(0)) {
          selectedEnt.as<Pattern>().builder.flipY();
          clickWasEnts = true;
        }
      }
    }
    if (drawSelectedEnt && selectedEnt != null && CheckCollisionPointRec(mouse, gameBounds)) {
      var pat = selectedEnt.as<Pattern>();
      DrawText("Selected: ${pat.name}", GetMouseX(), GetMouseY(), 20, GREEN);
    }
    EndDrawing();
    if (paused) {
      nextTime = GetTime() + 1.0 / rate;
    }
    if (!paused) {
      var time = GetTime();
      if (nextTime <= time) {
        if (steps == 0) {
          game.update();
        } else {
          game.warp(steps);
        }
        nextTime = time + 1.0 / rate;
      }
    }
    if (IsKeyPressed(KEY_APOSTROPHE)) {
      steps += 1;
    }
    if (IsKeyPressed(KEY_SEMICOLON)) {
      if (steps > 0) {
        steps -= 1;
      }
    }
    if (IsKeyPressed(KEY_PERIOD)) {
      rate *= 2.0;
    }
    if (IsKeyPressed(KEY_COMMA)) {
      rate *= 0.5;
    }
    if (IsKeyPressed(KEY_SPACE)) {
      paused = !paused;
    }
    if (IsKeyPressed(KEY_C)) {
      game.clear();
    }
    if (allPatterns.length != 0) {
      if (IsKeyPressed(KEY_O)) {
        patternHead -= 1;
        patterns = new ListBuilder<Pattern>();
        for (var i = patternHead; i < patternHead + 10; i++) {
          patterns.add(allPatterns[(i + allPatterns.length) % allPatterns.length]);
        }
      }
      if (IsKeyPressed(KEY_P)) {
        patternHead += 1;
        patterns = new ListBuilder<Pattern>();
        for (var i = patternHead; i < patternHead + 10; i++) {
          patterns.add(allPatterns[(i + allPatterns.length) % allPatterns.length]);
        }
      }
    }
    if (drawSelectedEnt && selectedEnt != null) {
      if (IsMouseButtonPressed(0)) {
        game.addBuilder(selectedEnt.as<Pattern>().builder, camera.screenToLife(GetMouseX().toFloat64(), GetMouseY().toFloat64()));
      }
    }
    if (heat != 0) {
      realHeat = heat;
    }
    heat = 0;
    // SaveFileText("out.save", saveTable());
  }
  CloseWindow();
}
