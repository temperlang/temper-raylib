
let {...} = import("../rl/raylib.temper");

var hashtable = new MapBuilder<Int, ListBuilder<Node>>();

let pow2(x: Int): Int {
  var ret = 1;
  for (var i = 0; i < x; i++) {
    ret *= 2;
  }
  return ret;
}

class DrawConfig {
  public screen: Rectangle;
}

interface Node {
  public level: Int;
  public pop: Int;
  public a: Node;
  public b: Node;
  public c: Node;
  public d: Node;
  public hash: Int;
  public next: Node | Null = null;
  public succ: ListBuilder<Node | Null>;

  public setNext(n: Node | Null): Void;
  public setSucc(j: Int, n: Node): Void;
  public eq(other: Node): Boolean;
  public draw(config: DrawConfig, bounds: Rectangle): Void;
}

class RealNode extends Node {
  public level: Int;
  public pop: Int;
  public a: Node;
  public b: Node;
  public c: Node;
  public d: Node;
  public hash: Int;
  public next: Node | Null;
  public succ: ListBuilder<Node | Null>;
  
  constructor(level: Int, pop: Int, a: Node, b: Node, c: Node, d: Node, hash: Int): Void {
    this.level = level;
    this.pop = pop;
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.hash = hash;
    next = null;
    succ = new ListBuilder<Node | Null>();
  }

  public setNext(n: Node | Null): Void {
    next = n;
  }

  public setSucc(j: Int, n: Node | Null): Void {
    while (succ.length <= j) {
      succ.add(null);
    }
    succ[j] = n;
  }

  public eq(other: Node): Boolean {
    if (level != other.level) {
      return false;
    }
    if (level == 0) {
      return other.level == 0 && other.pop == pop;
    }
    if (other.pop != pop) {
      return false;
    }
    // for (var i = 0; i < 4; i++) {
    //   if (children[i] != other.children[i]) {
    //     return false;
    //   }
    // }
    return a == other.a && b == other.b && c == other.c && d == other.d;
  }

  public draw(config: DrawConfig, base: Rectangle): Void {
    if (!CheckCollisionRecs(config.screen, base)) {
      return;
    }
    if (pop == 0) {
      DrawRectangleRec(
        new Rectangle(
          base.x.max(config.screen.x),
          base.y.max(config.screen.y),
          base.width.min(config.screen.width),
          base.height.min(config.screen.height),
        ),
        BLACK,
      );
    } else if (level == 0 || base.width < 2.0) {
      DrawRectangleRec(
        new Rectangle(
          base.x.max(config.screen.x),
          base.y.max(config.screen.y),
          base.width.min(config.screen.width),
          base.height.min(config.screen.height),
        ),
        WHITE,
      );
    } else {
      var halfWidth = base.width * 0.5;
      var halfHeight = base.height * 0.5;
      a.draw(config, new Rectangle(base.x, base.y, halfWidth, halfHeight));
      b.draw(config, new Rectangle(base.x + halfWidth, base.y, halfWidth, halfHeight));
      c.draw(config, new Rectangle(base.x, base.y + halfHeight, halfWidth, halfHeight));
      d.draw(config, new Rectangle(base.x + halfWidth, base.y + halfHeight, halfWidth, halfHeight));
    }
  }
}

class FakeNode extends Node {
  public level: Int;
  public pop: Int;
  public a: Node;
  public b: Node;
  public c: Node;
  public d: Node;
  public hash: Int;
  public next: Node | Null;
  public succ: ListBuilder<Node | Null>;

  constructor(): Void {
    level = -1;
    pop = 0;
    a = this;
    b = this;
    c = this;
    d = this;
    hash = 0;
    next = null;
    succ = new ListBuilder<Node | Null>();
  }

  public setNext(n: Node | Null): Void {}
  public setSucc(j: Int, n: Node | Null): Void {}
  public eq(other: Node): Boolean {
    return this == other;
  }
  public draw(config: DrawConfig, bounds: Rectangle): Void {}
}

var fake = new FakeNode();
var off = new RealNode(0, 0, fake, fake, fake, fake, 0);
var on = new RealNode(0, 1, fake, fake, fake, fake, 1);

let enter(node: Node): Node {
  var sub = hashtable[node.hash] orelse new ListBuilder<Node>();
  for (var i = sub.length - 1; i >= 0; i--) {
    if (node.eq(sub[i])) {
      return sub[i];
    }
  }
  sub.add(node);
  hashtable[node.hash] = sub;
  return node;
}

let join(a: Node, b: Node, c: Node, d: Node): Node {
  var next = (
    a.level
    + 5131830419411 * a.hash
    + 3758991985019 * b.hash
    + 8973110871315 * c.hash
    + 4318490180473 * d.hash
  );
  return enter(new RealNode(a.level + 1, a.pop + b.pop + c.pop + d.pop, a, b, c, d, next % 2147483648));
}

let zero(level: Int): Node {
  if (level == 0) {
    return off;
  } else {
    var val = zero(level-1);
    return join(val, val, val, val);
  }
}

let random(level: Int): Node {
  if (level == 0) {
    if (GetRandomValue(0, 5) == 0) {
      return on
    } else {
      return off;
    }
  } else {
    return join(random(level-1), random(level-1), random(level-1), random(level-1));
  }
}

let center(node: Node): Node {
  var z = zero(node.level - 1);
  return join(
    join(z, z, z, node.a), join(z, z, node.b, z),
    join(z, node.c, z, z), join(node.d, z, z, z),
  );
}

let lifeRule(a: Node, b: Node, c: Node, d: Node, e: Node, f: Node, g: Node, h: Node, i: Node): Node {
  var outer = a.pop + b.pop + c.pop + d.pop + f.pop + g.pop + h.pop + i.pop;
  if ((outer == 2 && e.pop != 0) || outer == 3) {
    return on;
  } else {
    return off;
  }
}


let life2(m: Node): Node {
  var ad = lifeRule(
    m.a.a, m.a.b, m.b.a,
    m.a.c, m.a.d, m.b.c,
    m.c.a, m.c.b, m.d.a
  );
  var bc = lifeRule(
    m.a.b, m.b.a, m.b.b,
    m.a.d, m.b.c, m.b.d,
    m.c.b, m.d.a, m.d.b
  );
  var cb = lifeRule(
    m.a.c, m.a.d, m.b.c,
    m.c.a, m.c.b, m.d.a,
    m.c.c, m.c.d, m.d.c
  );
  var da = lifeRule(
    m.a.d, m.b.c, m.b.d,
    m.c.b, m.d.a, m.d.b,
    m.c.d, m.d.c, m.d.d
  );
  return join(ad, bc, cb, da);
}

let nextGen(m: Node): Node {
  if (m.next == null) {
    var next = nextGenImpl(m);
    m.setNext(next);
    return next;
  } else {
    return m.next.as<Node>();
  }
}

let nextGenImpl(m: Node): Node {
  if (m.pop == 0) {
    return m.a;
  } else if (m.level == 2) {
    return life2(m);
  } else {
    var c1 = nextGen(join(m.a.a, m.a.b, m.a.c, m.a.d));
    var c2 = nextGen(join(m.a.b, m.b.a, m.a.d, m.b.c));
    var c3 = nextGen(join(m.b.a, m.b.b, m.b.c, m.b.d));
    var c4 = nextGen(join(m.a.c, m.a.d, m.c.a, m.c.b));
    var c5 = nextGen(join(m.a.d, m.b.c, m.c.b, m.d.a));
    var c6 = nextGen(join(m.b.c, m.b.d, m.d.a, m.d.b));
    var c7 = nextGen(join(m.c.a, m.c.b, m.c.c, m.c.d));
    var c8 = nextGen(join(m.c.b, m.d.a, m.c.d, m.d.c));
    var c9 = nextGen(join(m.d.a, m.d.b, m.d.c, m.d.d));

    return join(
      (join(c1.d, c2.c, c4.b, c5.a)),
      (join(c2.d, c3.c, c5.b, c6.a)),
      (join(c4.d, c5.c, c7.b, c8.a)),
      (join(c5.d, c6.c, c8.b, c9.a)),
    );
  }
}

let successor(m: Node, j: Int): Node {
  var mSucc = m.succ.getOr(j, null); 
  if (mSucc == null) {
    var succ = successorImpl(m, j);
    m.setSucc(j, succ);
    return succ;
  } else {
    return mSucc.as<Node>();
  }
}

let successorImpl(m: Node, j: Int): Node {
  if (m.pop == 0) {
    return m.a;
  } else if (m.level == 2) {
    return life2(m);
  } else {
    if (j > m.level - 2) {
      j = m.level - 2;
    }
    var c1 = successor(join(m.a.a, m.a.b, m.a.c, m.a.d), j);
    var c2 = successor(join(m.a.b, m.b.a, m.a.d, m.b.c), j);
    var c3 = successor(join(m.b.a, m.b.b, m.b.c, m.b.d), j);
    var c4 = successor(join(m.a.c, m.a.d, m.c.a, m.c.b), j);
    var c5 = successor(join(m.a.d, m.b.c, m.c.b, m.d.a), j);
    var c6 = successor(join(m.b.c, m.b.d, m.d.a, m.d.b), j);
    var c7 = successor(join(m.c.a, m.c.b, m.c.c, m.c.d), j);
    var c8 = successor(join(m.c.b, m.d.a, m.c.d, m.d.c), j);
    var c9 = successor(join(m.d.a, m.d.b, m.d.c, m.d.d), j);

    if (j < m.level - 2) {
      return join(
        join(c1.d, c2.c, c4.b, c5.a),
        join(c2.d, c3.c, c5.b, c6.a),
        join(c4.d, c5.c, c7.b, c8.a),
        join(c5.d, c6.c, c8.b, c9.a),
      );
    } else {
      return join(
        successor(join(c1, c2, c4, c5), j),
        successor(join(c2, c3, c5, c6), j),
        successor(join(c4, c5, c7, c8), j),
        successor(join(c5, c6, c8, c9), j),
      );
    }
  }
}

let subRandom(n: Int, subs: Int): Node {
  if (subs == 0) {
    return random(n);
  } else {
    var v1 = subRandom(n - 1, subs-1);
    var v2 = subRandom(n - 1, subs-1);
    return join(v1, v2, v2, v1);
  }
}

let copyWithRangeSet(grid: Node, pos: List<Int>, low: List<Int>, high: List<Int>, data: DenseBitVector): Node {
  var size = pow2(grid.level);
  if (pos[0] >= high[0] || pos[0] + size <= low[0]) {
    return grid;
  }
  if (pos[1] >= high[1] || pos[1] + size <= low[1]) {
    return grid;
  }
  if (grid.level == 0) {
    if (data[(pos[0] - low[0]) + (pos[1] - low[1]) * (high[0] - low[0])]) {
      return on;
    } else {
      return off;
    }
  }
  var size2 = size / 2;
  return join(
    copyWithRangeSet(grid.a, pos, low, high, data),
    copyWithRangeSet(grid.b, [pos[0] + size2, pos[1]], low, high, data),
    copyWithRangeSet(grid.c, [pos[0], pos[1] + size2], low, high, data),
    copyWithRangeSet(grid.d, [pos[0] + size2, pos[1] + size2], low, high, data),
  );
}

class Game {
  public grid: Node;
  
  constructor(args: Listed<String>) {
    var sizeLog2 = args[0].toInt() orelse 8;
    var size = pow2(sizeLog2);
    console.log("${(size * size).toString()} cells");
    grid = zero(sizeLog2);
  }

  public clear(): Void {
    grid = zero(grid.level);
  }

  public add(builder: LifeBuilder, pos: List<Int>): Void {
    var size = builder.size();
    var high = [pos[0] + size[0], pos[1] + size[1]];
    grid = copyWithRangeSet(grid, [0, 0], pos, high, builder.build());
  }

  public draw(bounds: Rectangle): Void {
    var screen = new Rectangle(0.0, 0.0, GetScreenWidth().toFloat64(), GetScreenHeight().toFloat64());
    var config = new DrawConfig(screen);
    grid.draw(config, bounds);
  }

  public update(): Void {
    grid = nextGen(center(grid));
  }

  public warp(n: Int): Int {
    grid = successor(center(grid), n);
    if (n < grid.level - 2) {
      return n;
    } else {
      return grid.level - 2;
    }
  }
}

class LifeBuilder {
  var width: Int;
  var data: ListBuilder<List<Boolean>>;

  constructor() {
    width = 0;
    data = new ListBuilder<String>();
  }

  public size(): List<Int> {
    return [width, data.length];
  }

  public add(t: String): Void {
    var s = t.split("");
    if (width < s.length) {
      width = s.length;
    }
    data.add(s.map(fn(s: String): Boolean {
      return s != " ";
    }));
  }
  
  public build(): DenseBitVector {
    var ret = new DenseBitVector(width * data.length);
    var n = 0;
    for (var i = 0; i < data.length; i++) {
      var split = data[i];
      for (var j = 0; j < width; j++) {
        ret[n++] = split[j] orelse false;
      }
    }
    return ret;
  }
}

let getScreenSize(): Vector2 {
  return new Vector2(GetScreenWidth().toFloat64(), GetScreenHeight().toFloat64());
}

export let main(args: Listed<String>): Void | Bubble {
  SetTraceLogLevel(LOG_WARNING);

  var bench = (args[0] == "--bench") orelse false;
  if (bench) {
    SetConfigFlags(FLAG_WINDOW_RESIZABLE);
    args = args.slice(1, args.length);
  } else {
    SetConfigFlags(FLAG_WINDOW_RESIZABLE | FLAG_VSYNC_HINT);
  }

  InitWindow(960, 540, "Conway's Game of LIFE");
  var game = new Game(args);

  var x = 0;

  var paused = false;
  var rate = 1.0;

  var target = new Vector2(0.0, 0.0);
  var zoom = 1.0;

  var nextTime = GetTime() + 1.0 / rate;

  var centerOfScreen = new Vector2(0.5, 0.5);

  while (!WindowShouldClose()) {
    var wheel = GetMouseWheelMove();
    if (wheel != 0.0) {
      var next = wheel * 0.2;
      var offset = new Vector2(next * GetMouseX().toFloat64() / zoom, next * GetMouseY().toFloat64() / zoom);
      target = Vector2Add(target, offset);
      zoom = zoom * (1.0 + next);
    }

    if (IsMouseButtonDown(0)) {
      var move = GetMouseDelta();
      target = Vector2Add(target, new Vector2(-move.x / zoom, -move.y / zoom));
    }

    BeginDrawing();
    ClearBackground(new Color(32, 32, 32, 255));
    var size = GetScreenWidth().toFloat64().max(GetScreenHeight().toFloat64());
    game.draw(
      new Rectangle(
        -target.x * zoom,
        -target.y * zoom,
        size * zoom,
        size * zoom,
      ),
    );
    DrawFPS(20, 20);
    // if (GuiLabelButton(new Rectangle(10.0, 10.0, 80.0, 80.0), "Toggle") != 0) {
    //   modeNum = "Toggle";
    // }
    DrawText(rate.toString(), 120, 20, 20, WHITE);
    EndDrawing();
    if (!paused) {
      var steps = 0;
      var time = GetTime();
      while (nextTime <= time) {
        var iters = 0;
        while (nextTime + pow2(iters).toFloat64() / rate * 2.0 <= time) {
          iters += 1;
        }
        var warps = 1;
        if (iters == 0) {
          game.update();
        } else {
          warps = pow2(game.warp(iters));
        }
        nextTime += warps.toFloat64() / rate;
        steps += warps;
      }
      var end = GetTime();
      if (steps != 0) {
        // console.log("Ran ${(steps.toFloat64() / (end - time)).toString()} steps/second");
      }
    }
    if (IsKeyPressed(KEY_PERIOD)) {
      rate *= 2.0;
    }
    if (IsKeyPressed(KEY_COMMA)) {
      rate *= 0.5;
    }
    if (IsKeyPressed(KEY_SPACE)) {
      paused = !paused;
    }
    if (IsKeyPressed(KEY_C)) {
      let size = pow2(game.grid.level);
      game.clear();
    }
    if (IsKeyPressed(KEY_ONE)) {
      var builder = new LifeBuilder();
      builder.add("  #");
      builder.add("# #");
      builder.add(" ##");
      game.add(builder, [0, 0]);
    }
    if (IsKeyPressed(KEY_TWO)) {
      var builder = new LifeBuilder();
      builder.add("                        #           ");
      builder.add("                      # #           ");
      builder.add("            ##      ##            ##");
      builder.add("           #   #    ##            ##");
      builder.add("##        #     #   ##              ");
      builder.add("##        #   # ##    # #           ");
      builder.add("          #     #       #           ");
      builder.add("           #   #                    ");
      builder.add("            ##                      ");
      game.add(builder, [0, x]);
      x += 32;
    }
    // if (IsKeyPressed(KEY_THREE)) {
    //   var size = pow2(game.grid.level);
    //   var builder = new LifeBuilder();
    //   for (var i = 0; i < size; i++) {
    //     builder.add("#");
    //   }
    //   game.add(builder, [size / 2, 0]);
    // }
    if (IsKeyPressed(KEY_THREE)) {
      var pos = pow2(game.grid.level) * 2 / 3;
      var builder = new LifeBuilder();
      builder.add(" #");
      builder.add("   #");
      builder.add("##  ###");
      game.add(builder, [pos, pos]);
    }
    // if (bench) {
    //   console.log("FrameTime: ${(GetFrameTime() * 1000.0).toInt().toString()}ms")
    // }
  }
  CloseWindow();
}
