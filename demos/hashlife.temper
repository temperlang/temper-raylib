
let {...} = import("../rl/raylib.temper");

var hashtableSize = 65536;
var hashtable = new ListBuilder<ListBuilder<Node>>();

for (var i = 0; i < hashtableSize; i++) {
  hashtable.add(new ListBuilder<Node>());
}

class Node {
  public level: Int;
  public pop: Int;
  public children: List<Node>;
  public hash: Int;
  public next: Node | Null = null;

  public setNext(n: Node | Null): Void {
    next = n;
  }

  public eq(other: Node): Boolean {
    if (level != other.level) {
      return false;
    }
    if (level == 0) {
      return other.level == 0 && other.pop == pop;
    }
    if (other.pop != pop) {
      return false;
    }
    for (var i = 0; i < 4; i++) {
      if (children[i] != other.children[i]) {
        return false;
      }
    }
    return true;
  }

  public draw(bounds: Rectangle): Void {
    if (pop == 0) {
      DrawRectangleRec(bounds, BLACK);
    } else if (level == 0) {
      DrawRectangleRec(bounds, WHITE);
    } else {
      var halfWidth = bounds.width * 0.5;
      var halfHeight = bounds.height * 0.5;
      for (var x = 0; x < 2; x++) {
        for (var y = 0; y < 2; y++) {
          children[x * 2 + y].draw(new Rectangle(bounds.x + halfWidth * x.toFloat64(), bounds.y + halfHeight * y.toFloat64(), halfWidth, halfHeight));
        }
      }
    }
  }
}

var off = new Node(0, 0, [], 0);
var on = new Node(0, 1, [], 1);

let join(a: Node, b: Node, c: Node, d: Node): Node {
  var next = (
    a.level
    + 1299811 * a.hash
    + 1299817 * b.hash
    + 1299821 * c.hash
    + 1299827 * d.hash
  );
  var tmp = new Node(a.level + 1, a.pop + b.pop + c.pop + d.pop, [a, b, c, d], next & 2147483647);
  var sub = hashtable[tmp.hash & (hashtableSize - 1)];
  for (var i = sub.length - 1; i >= 0; i--) {
    if (tmp.eq(sub[i])) {
      return sub[i];
    }
  }
  sub.add(tmp);
  return tmp;
}

let zero(level: Int): Node {
  if (level == 0) {
    return off;
  } else {
    var val = zero(level-1);
    return join(val, val, val, val);
  }
}

let random(level: Int): Node {
  if (level == 0) {
    if (GetRandomValue(0, 4) == 0) {
      return on
    } else {
      return off;
    }
  } else {
    return join(random(level-1), random(level-1), random(level-1), random(level-1));
  }
}

let center(node: Node): Node {
  var z = zero(node.level - 1);
  return join(
    join(z, z, z, node.children[0]), join(z, z, node.children[1], z),
    join(z, node.children[2], z, z), join(node.children[3], z, z, z),
  );
}

let lifeRule(a: Node, b: Node, c: Node, d: Node, e: Node, f: Node, g: Node, h: Node, i: Node): Node {
  var outer = a.pop + b.pop + c.pop + d.pop + f.pop + g.pop + h.pop + i.pop;
  if ((outer == 2 && e.pop != 0) || outer == 3) {
    return on;
  } else {
    return off;
  }
}

let life2(m: Node): Node {
    var ab = lifeRule(
      m.children[0].children[0], m.children[0].children[1], m.children[1].children[0],
      m.children[0].children[2], m.children[0].children[3], m.children[1].children[2],
      m.children[2].children[0], m.children[2].children[1], m.children[3].children[0]
    );
    var bc = lifeRule(
      m.children[0].children[1], m.children[1].children[0], m.children[1].children[1],
      m.children[0].children[3], m.children[1].children[2], m.children[1].children[3],
      m.children[2].children[1], m.children[3].children[0], m.children[3].children[1]
    );
    var cb = lifeRule(
      m.children[0].children[2], m.children[0].children[3], m.children[1].children[2],
      m.children[2].children[0], m.children[2].children[1], m.children[3].children[0],
      m.children[2].children[2], m.children[2].children[3], m.children[3].children[2]
    );
    var da = lifeRule(
      m.children[0].children[3], m.children[1].children[2], m.children[1].children[3],
      m.children[2].children[1], m.children[3].children[0], m.children[3].children[1],
      m.children[2].children[3], m.children[3].children[2], m.children[3].children[3]
    );
    return join(ab, bc, cb, da);
}

let nextGen(m: Node): Node {
  if (m.next == null) {
    var next = nextGenImpl(m);
    m.setNext(next);
    return next;
  } else {
    return m.next.as<Node>();
  }
}

let nextGenImpl(m: Node): Node {
  if (m.pop == 0) {
    return m.children[0];
  } else if (m.level == 2) {
    return life2(m);
  } else {
    var c1 = nextGen(join(m.children[0].children[0], m.children[0].children[1], m.children[0].children[2], m.children[0].children[3]));
    var c2 = nextGen(join(m.children[0].children[1], m.children[1].children[0], m.children[0].children[3], m.children[1].children[2]));
    var c3 = nextGen(join(m.children[1].children[0], m.children[1].children[1], m.children[1].children[2], m.children[1].children[3]));
    var c4 = nextGen(join(m.children[0].children[2], m.children[0].children[3], m.children[2].children[0], m.children[2].children[1]));
    var c5 = nextGen(join(m.children[0].children[3], m.children[1].children[2], m.children[2].children[1], m.children[3].children[0]));
    var c6 = nextGen(join(m.children[1].children[2], m.children[1].children[3], m.children[3].children[0], m.children[3].children[1]));
    var c7 = nextGen(join(m.children[2].children[0], m.children[2].children[1], m.children[2].children[2], m.children[2].children[3]));
    var c8 = nextGen(join(m.children[2].children[1], m.children[3].children[0], m.children[2].children[3], m.children[3].children[2]));
    var c9 = nextGen(join(m.children[3].children[0], m.children[3].children[1], m.children[3].children[2], m.children[3].children[3]));

    return join(
        (join(c1.children[3], c2.children[2], c4.children[1], c5.children[0])),
        (join(c2.children[3], c3.children[2], c5.children[1], c6.children[0])),
        (join(c4.children[3], c5.children[2], c7.children[1], c8.children[0])),
        (join(c5.children[3], c6.children[2], c8.children[1], c9.children[0])),
    );
  }
}

let pow2(x: Int): Int {
  var ret = 1;
  for (var i = 0; i < x; i++) {
    ret *= 2;
  }
  return ret;
}

// raylib

class Game {
  public grid: Node;
  
  constructor(args: Listed<String>) {
    var size = args[0].toInt() orelse 8;
    grid = random(size - 2);
    grid = join(grid, grid, grid, grid);
    grid = join(grid, grid, grid, grid);
    // var centers = args[1].toInt() orelse 1;
    // for (var i = 0; i < centers; i++) {
    //   grid = center(grid);
    // }
  }

  public draw(bounds: Rectangle): Void {
    var rec = if (bounds.width > bounds.height) {
      new Rectangle((bounds.width - bounds.height) * 0.5, 0.0, bounds.height, bounds.height)
    } else {
      new Rectangle(0.0, (bounds.height - bounds.width) * 0.5, bounds.width, bounds.width)
    };
    var hx = rec.width * 0.5;
    var hy = rec.height * 0.5;
    grid.children[0].children[3].draw(new Rectangle(rec.x, rec.y, hx, hy));
    grid.children[2].children[1].draw(new Rectangle(rec.x + hx, rec.y, hx, hy));
    grid.children[1].children[2].draw(new Rectangle(rec.x, rec.y + hy, hx, hy));
    grid.children[3].children[0].draw(new Rectangle(rec.x + hx, rec.y + hy, hx, hy));
  }

  public update(): Void {
    grid = center(nextGen(grid));
  }
}

export let main(args: Listed<String>): Void | Bubble {
  SetTraceLogLevel(LOG_WARNING);

  if ((args[0] == "--bench") orelse false) {
    SetConfigFlags(FLAG_WINDOW_RESIZABLE);
    args = args.slice(1, args.length);
  } else {
    SetConfigFlags(FLAG_WINDOW_RESIZABLE | FLAG_VSYNC_HINT);
  }

  InitWindow(0, 0, "Conway's Game of LIFE");
  var game = new Game(args);

  var n = 0;

  while (!WindowShouldClose()) {
    BeginDrawing();
    ClearBackground(BLACK);
    game.draw(new Rectangle(0.0, 0.0, GetScreenWidth().toFloat64(), GetScreenHeight().toFloat64()));
    DrawFPS(20, 20);
    EndDrawing();
    game.update();
    n += 1;
  }
  CloseWindow();
}

