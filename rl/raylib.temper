
export interface Raylib {
    // Enable gui controls (global state)
    public GuiEnable(): Void;
    // Disable gui controls (global state)
    public GuiDisable(): Void;
    // Lock gui controls (global state)
    public GuiLock(): Void;
    // Unlock gui controls (global state)
    public GuiUnlock(): Void;
    // Check if gui is locked (global state)
    public GuiIsLocked(): Boolean;
    // Set gui controls alpha (global state), alpha goes from 0.0f to 1.0f
    public GuiSetAlpha(alpha: Float64): Void;
    // Set gui state (global state)
    public GuiSetState(state: Int): Void;
    // Get gui state (global state)
    public GuiGetState(): Int;
    // Set gui custom font (global state)
    public GuiSetFont(font: Font): Void;
    // Get gui custom font (global state)
    public GuiGetFont(): Font;
    // Set one style property
    public GuiSetStyle(control: Int, property: Int, value: Int): Void;
    // Get one style property
    public GuiGetStyle(control: Int, property: Int): Int;
    // Load style file over global style variable (.rgs)
    public GuiLoadStyle(fileName: String): Void;
    // Load style default over global style
    public GuiLoadStyleDefault(): Void;
    // Enable gui tooltips (global state)
    public GuiEnableTooltip(): Void;
    // Disable gui tooltips (global state)
    public GuiDisableTooltip(): Void;
    // Set tooltip string
    public GuiSetTooltip(tooltip: String): Void;
    // Get text with icon id prepended (if supported)
    public GuiIconText(iconId: Int, text: String): String;
    // Window Box control, shows a window that can be closed
    public GuiWindowBox(bounds: Rectangle, title: String): Int;
    // Group Box control with text name
    public GuiGroupBox(bounds: Rectangle, text: String): Int;
    // Line separator control, could contain text
    public GuiLine(bounds: Rectangle, text: String): Int;
    // Panel control, useful to group controls
    public GuiPanel(bounds: Rectangle, text: String): Int;
    // Tab Bar control, returns TAB to be closed or -1
    public GuiTabBar(bounds: Rectangle, text: Listed<String>, count: Int, active: Listed<Int>): Int;
    // Scroll Panel control
    public GuiScrollPanel(bounds: Rectangle, text: String, content: Rectangle, scroll: Listed<Vector2>, view: Listed<Rectangle>): Int;
    // Label control, shows text
    public GuiLabel(bounds: Rectangle, text: String): Int;
    // Button control, returns true when clicked
    public GuiButton(bounds: Rectangle, text: String): Int;
    // Label button control, show true when clicked
    public GuiLabelButton(bounds: Rectangle, text: String): Int;
    // Toggle Button control, returns true when active
    public GuiToggle(bounds: Rectangle, text: String, active: Listed<Boolean>): Int;
    // Toggle Group control, returns active toggle index
    public GuiToggleGroup(bounds: Rectangle, text: String, active: Listed<Int>): Int;
    // Toggle Slider control, returns true when clicked
    public GuiToggleSlider(bounds: Rectangle, text: String, active: Listed<Int>): Int;
    // Check Box control, returns true when active
    public GuiCheckBox(bounds: Rectangle, text: String, checked: Listed<Boolean>): Int;
    // Combo Box control, returns selected item index
    public GuiComboBox(bounds: Rectangle, text: String, active: Listed<Int>): Int;
    // Dropdown Box control, returns selected item
    public GuiDropdownBox(bounds: Rectangle, text: String, active: Listed<Int>, editMode: Boolean): Int;
    // Spinner control, returns selected value
    public GuiSpinner(bounds: Rectangle, text: String, value: Listed<Int>, minValue: Int, maxValue: Int, editMode: Boolean): Int;
    // Value Box control, updates input text with numbers
    public GuiValueBox(bounds: Rectangle, text: String, value: Listed<Int>, minValue: Int, maxValue: Int, editMode: Boolean): Int;
    // Text Box control, updates input text
    public GuiTextBox(bounds: Rectangle, text: String, textSize: Int, editMode: Boolean): Int;
    // Slider control, returns selected value
    public GuiSlider(bounds: Rectangle, textLeft: String, textRight: String, value: Listed<Float64>, minValue: Float64, maxValue: Float64): Int;
    // Slider Bar control, returns selected value
    public GuiSliderBar(bounds: Rectangle, textLeft: String, textRight: String, value: Listed<Float64>, minValue: Float64, maxValue: Float64): Int;
    // Progress Bar control, shows current progress value
    public GuiProgressBar(bounds: Rectangle, textLeft: String, textRight: String, value: Listed<Float64>, minValue: Float64, maxValue: Float64): Int;
    // Status Bar control, shows info text
    public GuiStatusBar(bounds: Rectangle, text: String): Int;
    // Dummy control for placeholders
    public GuiDummyRec(bounds: Rectangle, text: String): Int;
    // Grid control, returns mouse cell position
    public GuiGrid(bounds: Rectangle, text: String, spacing: Float64, subdivs: Int, mouseCell: Listed<Vector2>): Int;
    // List View control, returns selected list item index
    public GuiListView(bounds: Rectangle, text: String, scrollIndex: Listed<Int>, active: Listed<Int>): Int;
    // List View with extended parameters
    public GuiListViewEx(bounds: Rectangle, text: Listed<String>, count: Int, scrollIndex: Listed<Int>, active: Listed<Int>, focus: Listed<Int>): Int;
    // Message Box control, displays a message
    public GuiMessageBox(bounds: Rectangle, title: String, message: String, buttons: String): Int;
    // Text Input Box control, ask for text, supports secret
    public GuiTextInputBox(bounds: Rectangle, title: String, message: String, buttons: String, text: String, textMaxSize: Int, secretViewActive: Listed<Boolean>): Int;
    // Color Picker control (multiple color controls)
    public GuiColorPicker(bounds: Rectangle, text: String, color: Listed<Color>): Int;
    // Color Panel control
    public GuiColorPanel(bounds: Rectangle, text: String, color: Listed<Color>): Int;
    // Color Bar Alpha control
    public GuiColorBarAlpha(bounds: Rectangle, text: String, alpha: Listed<Float64>): Int;
    // Color Bar Hue control
    public GuiColorBarHue(bounds: Rectangle, text: String, value: Listed<Float64>): Int;
    // Color Picker control that avoids conversion to RGB on each call (multiple color controls)
    public GuiColorPickerHSV(bounds: Rectangle, text: String, colorHsv: Listed<Vector3>): Int;
    // Color Panel control that returns HSV color value, used by GuiColorPickerHSV()
    public GuiColorPanelHSV(bounds: Rectangle, text: String, colorHsv: Listed<Vector3>): Int;
    // Initialize window and OpenGL context
    public InitWindow(width: Int, height: Int, title: String): Void;
    // Close window and unload OpenGL context
    public CloseWindow(): Void;
    // Check if application should close (KEY_ESCAPE pressed or windows close icon clicked)
    public WindowShouldClose(): Boolean;
    // Check if window has been initialized successfully
    public IsWindowReady(): Boolean;
    // Check if window is currently fullscreen
    public IsWindowFullscreen(): Boolean;
    // Check if window is currently hidden (only PLATFORM_DESKTOP)
    public IsWindowHidden(): Boolean;
    // Check if window is currently minimized (only PLATFORM_DESKTOP)
    public IsWindowMinimized(): Boolean;
    // Check if window is currently maximized (only PLATFORM_DESKTOP)
    public IsWindowMaximized(): Boolean;
    // Check if window is currently focused (only PLATFORM_DESKTOP)
    public IsWindowFocused(): Boolean;
    // Check if window has been resized last frame
    public IsWindowResized(): Boolean;
    // Check if one specific window flag is enabled
    public IsWindowState(flag: Int): Boolean;
    // Set window configuration state using flags (only PLATFORM_DESKTOP)
    public SetWindowState(flags: Int): Void;
    // Clear window configuration state flags
    public ClearWindowState(flags: Int): Void;
    // Toggle window state: fullscreen/windowed (only PLATFORM_DESKTOP)
    public ToggleFullscreen(): Void;
    // Toggle window state: borderless windowed (only PLATFORM_DESKTOP)
    public ToggleBorderlessWindowed(): Void;
    // Set window state: maximized, if resizable (only PLATFORM_DESKTOP)
    public MaximizeWindow(): Void;
    // Set window state: minimized, if resizable (only PLATFORM_DESKTOP)
    public MinimizeWindow(): Void;
    // Set window state: not minimized/maximized (only PLATFORM_DESKTOP)
    public RestoreWindow(): Void;
    // Set icon for window (single image, RGBA 32bit, only PLATFORM_DESKTOP)
    public SetWindowIcon(image: Image): Void;
    // Set icon for window (multiple images, RGBA 32bit, only PLATFORM_DESKTOP)
    public SetWindowIcons(images: Listed<Image>, count: Int): Void;
    // Set title for window (only PLATFORM_DESKTOP and PLATFORM_WEB)
    public SetWindowTitle(title: String): Void;
    // Set window position on screen (only PLATFORM_DESKTOP)
    public SetWindowPosition(x: Int, y: Int): Void;
    // Set monitor for the current window
    public SetWindowMonitor(monitor: Int): Void;
    // Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)
    public SetWindowMinSize(width: Int, height: Int): Void;
    // Set window maximum dimensions (for FLAG_WINDOW_RESIZABLE)
    public SetWindowMaxSize(width: Int, height: Int): Void;
    // Set window dimensions
    public SetWindowSize(width: Int, height: Int): Void;
    // Set window opacity [0.0f..1.0f] (only PLATFORM_DESKTOP)
    public SetWindowOpacity(opacity: Float64): Void;
    // Set window focused (only PLATFORM_DESKTOP)
    public SetWindowFocused(): Void;
    // Get native window handle
    public GetWindowHandle(): DenseBitVector;
    // Get current screen width
    public GetScreenWidth(): Int;
    // Get current screen height
    public GetScreenHeight(): Int;
    // Get current render width (it considers HiDPI)
    public GetRenderWidth(): Int;
    // Get current render height (it considers HiDPI)
    public GetRenderHeight(): Int;
    // Get number of connected monitors
    public GetMonitorCount(): Int;
    // Get current connected monitor
    public GetCurrentMonitor(): Int;
    // Get specified monitor position
    public GetMonitorPosition(monitor: Int): Vector2;
    // Get specified monitor width (current video mode used by monitor)
    public GetMonitorWidth(monitor: Int): Int;
    // Get specified monitor height (current video mode used by monitor)
    public GetMonitorHeight(monitor: Int): Int;
    // Get specified monitor physical width in millimetres
    public GetMonitorPhysicalWidth(monitor: Int): Int;
    // Get specified monitor physical height in millimetres
    public GetMonitorPhysicalHeight(monitor: Int): Int;
    // Get specified monitor refresh rate
    public GetMonitorRefreshRate(monitor: Int): Int;
    // Get window position XY on monitor
    public GetWindowPosition(): Vector2;
    // Get window scale DPI factor
    public GetWindowScaleDPI(): Vector2;
    // Get the human-readable, UTF-8 encoded name of the specified monitor
    public GetMonitorName(monitor: Int): String;
    // Set clipboard text content
    public SetClipboardText(text: String): Void;
    // Get clipboard text content
    public GetClipboardText(): String;
    // Enable waiting for events on EndDrawing(), no automatic event polling
    public EnableEventWaiting(): Void;
    // Disable waiting for events on EndDrawing(), automatic events polling
    public DisableEventWaiting(): Void;
    // Shows cursor
    public ShowCursor(): Void;
    // Hides cursor
    public HideCursor(): Void;
    // Check if cursor is not visible
    public IsCursorHidden(): Boolean;
    // Enables cursor (unlock cursor)
    public EnableCursor(): Void;
    // Disables cursor (lock cursor)
    public DisableCursor(): Void;
    // Check if cursor is on the screen
    public IsCursorOnScreen(): Boolean;
    // Set background color (framebuffer clear color)
    public ClearBackground(color: Color): Void;
    // Setup canvas (framebuffer) to start drawing
    public BeginDrawing(): Void;
    // End canvas drawing and swap buffers (double buffering)
    public EndDrawing(): Void;
    // Begin 2D mode with custom camera (2D)
    public BeginMode2D(camera: Camera2D): Void;
    // Ends 2D mode with custom camera
    public EndMode2D(): Void;
    // Begin 3D mode with custom camera (3D)
    public BeginMode3D(camera: Camera3D): Void;
    // Ends 3D mode and returns to default 2D orthographic mode
    public EndMode3D(): Void;
    // Begin drawing to render texture
    public BeginTextureMode(target: RenderTexture2D): Void;
    // Ends drawing to render texture
    public EndTextureMode(): Void;
    // Begin custom shader drawing
    public BeginShaderMode(shader: Shader): Void;
    // End custom shader drawing (use default shader)
    public EndShaderMode(): Void;
    // Begin blending mode (alpha, additive, multiplied, subtract, custom)
    public BeginBlendMode(mode: Int): Void;
    // End blending mode (reset to default: alpha blending)
    public EndBlendMode(): Void;
    // Begin scissor mode (define screen area for following drawing)
    public BeginScissorMode(x: Int, y: Int, width: Int, height: Int): Void;
    // End scissor mode
    public EndScissorMode(): Void;
    // Begin stereo rendering (requires VR simulator)
    public BeginVrStereoMode(config: VrStereoConfig): Void;
    // End stereo rendering (requires VR simulator)
    public EndVrStereoMode(): Void;
    // Load VR stereo config for VR simulator device parameters
    public LoadVrStereoConfig(device: VrDeviceInfo): VrStereoConfig;
    // Unload VR stereo config
    public UnloadVrStereoConfig(config: VrStereoConfig): Void;
    // Load shader from files and bind default locations
    public LoadShader(vsFileName: String, fsFileName: String): Shader;
    // Load shader from code strings and bind default locations
    public LoadShaderFromMemory(vsCode: String, fsCode: String): Shader;
    // Check if a shader is ready
    public IsShaderReady(shader: Shader): Boolean;
    // Get shader uniform location
    public GetShaderLocation(shader: Shader, uniformName: String): Int;
    // Get shader attribute location
    public GetShaderLocationAttrib(shader: Shader, attribName: String): Int;
    // Set shader uniform value
    public SetShaderValue(shader: Shader, locIndex: Int, value: DenseBitVector, uniformType: Int): Void;
    // Set shader uniform value vector
    public SetShaderValueV(shader: Shader, locIndex: Int, value: DenseBitVector, uniformType: Int, count: Int): Void;
    // Set shader uniform value (matrix 4x4)
    public SetShaderValueMatrix(shader: Shader, locIndex: Int, mat: Matrix): Void;
    // Set shader uniform value for texture (sampler2d)
    public SetShaderValueTexture(shader: Shader, locIndex: Int, texture: Texture2D): Void;
    // Unload shader from GPU memory (VRAM)
    public UnloadShader(shader: Shader): Void;
    // Get a ray trace from mouse position
    public GetMouseRay(mousePosition: Vector2, camera: Camera): Ray;
    // Get camera transform matrix (view matrix)
    public GetCameraMatrix(camera: Camera): Matrix;
    // Get camera 2d transform matrix
    public GetCameraMatrix2D(camera: Camera2D): Matrix;
    // Get the screen space position for a 3d world space position
    public GetWorldToScreen(position: Vector3, camera: Camera): Vector2;
    // Get the world space position for a 2d camera screen space position
    public GetScreenToWorld2D(position: Vector2, camera: Camera2D): Vector2;
    // Get size position for a 3d world space position
    public GetWorldToScreenEx(position: Vector3, camera: Camera, width: Int, height: Int): Vector2;
    // Get the screen space position for a 2d camera world space position
    public GetWorldToScreen2D(position: Vector2, camera: Camera2D): Vector2;
    // Set target FPS (maximum)
    public SetTargetFPS(fps: Int): Void;
    // Get time in seconds for last frame drawn (delta time)
    public GetFrameTime(): Float64;
    // Get elapsed time in seconds since InitWindow()
    public GetTime(): Float64;
    // Get current FPS
    public GetFPS(): Int;
    // Swap back buffer with front buffer (screen drawing)
    public SwapScreenBuffer(): Void;
    // Register all input events
    public PollInputEvents(): Void;
    // Wait for some time (halt program execution)
    public WaitTime(seconds: Float64): Void;
    // Set the seed for the random number generator
    public SetRandomSeed(seed: Int): Void;
    // Get a random value between min and max (both included)
    public GetRandomValue(min: Int, max: Int): Int;
    // Load random values sequence, no values repeated
    public LoadRandomSequence(count: Int, min: Int, max: Int): Listed<Int>;
    // Unload random values sequence
    public UnloadRandomSequence(sequence: Listed<Int>): Void;
    // Takes a screenshot of current screen (filename extension defines format)
    public TakeScreenshot(fileName: String): Void;
    // Setup init configuration flags (view FLAGS)
    public SetConfigFlags(flags: Int): Void;
    // Open URL with default system browser (if available)
    public OpenURL(url: String): Void;
    // Set the current threshold (minimum) log level
    public SetTraceLogLevel(logLevel: Int): Void;
    // Internal memory allocator
    public MemAlloc(size: Int): DenseBitVector;
    // Internal memory reallocator
    public MemRealloc(ptr: DenseBitVector, size: Int): DenseBitVector;
    // Internal memory free
    public MemFree(ptr: DenseBitVector): Void;
    // Load file data as byte array (read)
    public LoadFileData(fileName: String, dataSize: Listed<Int>): Listed<Int>;
    // Unload file data allocated by LoadFileData()
    public UnloadFileData(data: Listed<Int>): Void;
    // Save data to file from byte array (write), returns true on success
    public SaveFileData(fileName: String, data: DenseBitVector, dataSize: Int): Boolean;
    // Export data to code (.h), returns true on success
    public ExportDataAsCode(data: Listed<Int>, dataSize: Int, fileName: String): Boolean;
    // Load text data from file (read), returns a '\0' terminated string
    public LoadFileText(fileName: String): String;
    // Unload file text data allocated by LoadFileText()
    public UnloadFileText(text: String): Void;
    // Save text data to file (write), string must be '\0' terminated, returns true on success
    public SaveFileText(fileName: String, text: String): Boolean;
    // Check if file exists
    public FileExists(fileName: String): Boolean;
    // Check if a directory path exists
    public DirectoryExists(dirPath: String): Boolean;
    // Check file extension (including point: .png, .wav)
    public IsFileExtension(fileName: String, ext: String): Boolean;
    // Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)
    public GetFileLength(fileName: String): Int;
    // Get pointer to extension for a filename string (includes dot: '.png')
    public GetFileExtension(fileName: String): String;
    // Get pointer to filename for a path string
    public GetFileName(filePath: String): String;
    // Get filename string without extension (uses static string)
    public GetFileNameWithoutExt(filePath: String): String;
    // Get full path for a given fileName with path (uses static string)
    public GetDirectoryPath(filePath: String): String;
    // Get previous directory path for a given path (uses static string)
    public GetPrevDirectoryPath(dirPath: String): String;
    // Get current working directory (uses static string)
    public GetWorkingDirectory(): String;
    // Get the directory of the running application (uses static string)
    public GetApplicationDirectory(): String;
    // Change working directory, return true on success
    public ChangeDirectory(dir: String): Boolean;
    // Check if a given path is a file or a directory
    public IsPathFile(path: String): Boolean;
    // Load directory filepaths
    public LoadDirectoryFiles(dirPath: String): FilePathList;
    // Load directory filepaths with extension filtering and recursive directory scan
    public LoadDirectoryFilesEx(basePath: String, filter: String, scanSubdirs: Boolean): FilePathList;
    // Unload filepaths
    public UnloadDirectoryFiles(files: FilePathList): Void;
    // Check if a file has been dropped into window
    public IsFileDropped(): Boolean;
    // Load dropped filepaths
    public LoadDroppedFiles(): FilePathList;
    // Unload dropped filepaths
    public UnloadDroppedFiles(files: FilePathList): Void;
    // Get file modification time (last write time)
    public GetFileModTime(fileName: String): Int;
    // Compress data (DEFLATE algorithm), memory must be MemFree()
    public CompressData(data: Listed<Int>, dataSize: Int, compDataSize: Listed<Int>): Listed<Int>;
    // Decompress data (DEFLATE algorithm), memory must be MemFree()
    public DecompressData(compData: Listed<Int>, compDataSize: Int, dataSize: Listed<Int>): Listed<Int>;
    // Encode data to Base64 string, memory must be MemFree()
    public EncodeDataBase64(data: Listed<Int>, dataSize: Int, outputSize: Listed<Int>): String;
    // Decode Base64 string data, memory must be MemFree()
    public DecodeDataBase64(data: Listed<Int>, outputSize: Listed<Int>): Listed<Int>;
    // Load automation events list from file, NULL for empty list, capacity = MAX_AUTOMATION_EVENTS
    public LoadAutomationEventList(fileName: String): AutomationEventList;
    // Unload automation events list from file
    public UnloadAutomationEventList(list: AutomationEventList): Void;
    // Export automation events list as text file
    public ExportAutomationEventList(list: AutomationEventList, fileName: String): Boolean;
    // Set automation event list to record to
    public SetAutomationEventList(list: Listed<AutomationEventList>): Void;
    // Set automation event internal base frame to start recording
    public SetAutomationEventBaseFrame(frame: Int): Void;
    // Start recording automation events (AutomationEventList must be set)
    public StartAutomationEventRecording(): Void;
    // Stop recording automation events
    public StopAutomationEventRecording(): Void;
    // Play a recorded automation event
    public PlayAutomationEvent(event: AutomationEvent): Void;
    // Check if a key has been pressed once
    public IsKeyPressed(key: Int): Boolean;
    // Check if a key has been pressed again (Only PLATFORM_DESKTOP)
    public IsKeyPressedRepeat(key: Int): Boolean;
    // Check if a key is being pressed
    public IsKeyDown(key: Int): Boolean;
    // Check if a key has been released once
    public IsKeyReleased(key: Int): Boolean;
    // Check if a key is NOT being pressed
    public IsKeyUp(key: Int): Boolean;
    // Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty
    public GetKeyPressed(): Int;
    // Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty
    public GetCharPressed(): Int;
    // Set a custom key to exit program (default is ESC)
    public SetExitKey(key: Int): Void;
    // Check if a gamepad is available
    public IsGamepadAvailable(gamepad: Int): Boolean;
    // Get gamepad internal name id
    public GetGamepadName(gamepad: Int): String;
    // Check if a gamepad button has been pressed once
    public IsGamepadButtonPressed(gamepad: Int, button: Int): Boolean;
    // Check if a gamepad button is being pressed
    public IsGamepadButtonDown(gamepad: Int, button: Int): Boolean;
    // Check if a gamepad button has been released once
    public IsGamepadButtonReleased(gamepad: Int, button: Int): Boolean;
    // Check if a gamepad button is NOT being pressed
    public IsGamepadButtonUp(gamepad: Int, button: Int): Boolean;
    // Get the last gamepad button pressed
    public GetGamepadButtonPressed(): Int;
    // Get gamepad axis count for a gamepad
    public GetGamepadAxisCount(gamepad: Int): Int;
    // Get axis movement value for a gamepad axis
    public GetGamepadAxisMovement(gamepad: Int, axis: Int): Float64;
    // Set internal gamepad mappings (SDL_GameControllerDB)
    public SetGamepadMappings(mappings: String): Int;
    // Check if a mouse button has been pressed once
    public IsMouseButtonPressed(button: Int): Boolean;
    // Check if a mouse button is being pressed
    public IsMouseButtonDown(button: Int): Boolean;
    // Check if a mouse button has been released once
    public IsMouseButtonReleased(button: Int): Boolean;
    // Check if a mouse button is NOT being pressed
    public IsMouseButtonUp(button: Int): Boolean;
    // Get mouse position X
    public GetMouseX(): Int;
    // Get mouse position Y
    public GetMouseY(): Int;
    // Get mouse position XY
    public GetMousePosition(): Vector2;
    // Get mouse delta between frames
    public GetMouseDelta(): Vector2;
    // Set mouse position XY
    public SetMousePosition(x: Int, y: Int): Void;
    // Set mouse offset
    public SetMouseOffset(offsetX: Int, offsetY: Int): Void;
    // Set mouse scaling
    public SetMouseScale(scaleX: Float64, scaleY: Float64): Void;
    // Get mouse wheel movement for X or Y, whichever is larger
    public GetMouseWheelMove(): Float64;
    // Get mouse wheel movement for both X and Y
    public GetMouseWheelMoveV(): Vector2;
    // Set mouse cursor
    public SetMouseCursor(cursor: Int): Void;
    // Get touch position X for touch point 0 (relative to screen size)
    public GetTouchX(): Int;
    // Get touch position Y for touch point 0 (relative to screen size)
    public GetTouchY(): Int;
    // Get touch position XY for a touch point index (relative to screen size)
    public GetTouchPosition(index: Int): Vector2;
    // Get touch point identifier for given index
    public GetTouchPointId(index: Int): Int;
    // Get number of touch points
    public GetTouchPointCount(): Int;
    // Enable a set of gestures using flags
    public SetGesturesEnabled(flags: Int): Void;
    // Check if a gesture have been detected
    public IsGestureDetected(gesture: Int): Boolean;
    // Get latest detected gesture
    public GetGestureDetected(): Int;
    // Get gesture hold time in milliseconds
    public GetGestureHoldDuration(): Float64;
    // Get gesture drag vector
    public GetGestureDragVector(): Vector2;
    // Get gesture drag angle
    public GetGestureDragAngle(): Float64;
    // Get gesture pinch delta
    public GetGesturePinchVector(): Vector2;
    // Get gesture pinch angle
    public GetGesturePinchAngle(): Float64;
    // Update camera position for selected mode
    public UpdateCamera(camera: Listed<Camera>, mode: Int): Void;
    // Update camera movement/rotation
    public UpdateCameraPro(camera: Listed<Camera>, movement: Vector3, rotation: Vector3, zoom: Float64): Void;
    // Set texture and rectangle to be used on shapes drawing
    public SetShapesTexture(texture: Texture2D, source: Rectangle): Void;
    // Get texture that is used for shapes drawing
    public GetShapesTexture(): Texture2D;
    // Get texture source rectangle that is used for shapes drawing
    public GetShapesTextureRectangle(): Rectangle;
    // Draw a pixel
    public DrawPixel(posX: Int, posY: Int, color: Color): Void;
    // Draw a pixel (Vector version)
    public DrawPixelV(position: Vector2, color: Color): Void;
    // Draw a line
    public DrawLine(startPosX: Int, startPosY: Int, endPosX: Int, endPosY: Int, color: Color): Void;
    // Draw a line (using gl lines)
    public DrawLineV(startPos: Vector2, endPos: Vector2, color: Color): Void;
    // Draw a line (using triangles/quads)
    public DrawLineEx(startPos: Vector2, endPos: Vector2, thick: Float64, color: Color): Void;
    // Draw lines sequence (using gl lines)
    public DrawLineStrip(points: Listed<Vector2>, pointCount: Int, color: Color): Void;
    // Draw line segment cubic-bezier in-out interpolation
    public DrawLineBezier(startPos: Vector2, endPos: Vector2, thick: Float64, color: Color): Void;
    // Draw a color-filled circle
    public DrawCircle(centerX: Int, centerY: Int, radius: Float64, color: Color): Void;
    // Draw a piece of a circle
    public DrawCircleSector(center: Vector2, radius: Float64, startAngle: Float64, endAngle: Float64, segments: Int, color: Color): Void;
    // Draw circle sector outline
    public DrawCircleSectorLines(center: Vector2, radius: Float64, startAngle: Float64, endAngle: Float64, segments: Int, color: Color): Void;
    // Draw a gradient-filled circle
    public DrawCircleGradient(centerX: Int, centerY: Int, radius: Float64, color1: Color, color2: Color): Void;
    // Draw a color-filled circle (Vector version)
    public DrawCircleV(center: Vector2, radius: Float64, color: Color): Void;
    // Draw circle outline
    public DrawCircleLines(centerX: Int, centerY: Int, radius: Float64, color: Color): Void;
    // Draw circle outline (Vector version)
    public DrawCircleLinesV(center: Vector2, radius: Float64, color: Color): Void;
    // Draw ellipse
    public DrawEllipse(centerX: Int, centerY: Int, radiusH: Float64, radiusV: Float64, color: Color): Void;
    // Draw ellipse outline
    public DrawEllipseLines(centerX: Int, centerY: Int, radiusH: Float64, radiusV: Float64, color: Color): Void;
    // Draw ring
    public DrawRing(center: Vector2, innerRadius: Float64, outerRadius: Float64, startAngle: Float64, endAngle: Float64, segments: Int, color: Color): Void;
    // Draw ring outline
    public DrawRingLines(center: Vector2, innerRadius: Float64, outerRadius: Float64, startAngle: Float64, endAngle: Float64, segments: Int, color: Color): Void;
    // Draw a color-filled rectangle
    public DrawRectangle(posX: Int, posY: Int, width: Int, height: Int, color: Color): Void;
    // Draw a color-filled rectangle (Vector version)
    public DrawRectangleV(position: Vector2, size: Vector2, color: Color): Void;
    // Draw a color-filled rectangle
    public DrawRectangleRec(rec: Rectangle, color: Color): Void;
    // Draw a color-filled rectangle with pro parameters
    public DrawRectanglePro(rec: Rectangle, origin: Vector2, rotation: Float64, color: Color): Void;
    // Draw a vertical-gradient-filled rectangle
    public DrawRectangleGradientV(posX: Int, posY: Int, width: Int, height: Int, color1: Color, color2: Color): Void;
    // Draw a horizontal-gradient-filled rectangle
    public DrawRectangleGradientH(posX: Int, posY: Int, width: Int, height: Int, color1: Color, color2: Color): Void;
    // Draw a gradient-filled rectangle with custom vertex colors
    public DrawRectangleGradientEx(rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color): Void;
    // Draw rectangle outline
    public DrawRectangleLines(posX: Int, posY: Int, width: Int, height: Int, color: Color): Void;
    // Draw rectangle outline with extended parameters
    public DrawRectangleLinesEx(rec: Rectangle, lineThick: Float64, color: Color): Void;
    // Draw rectangle with rounded edges
    public DrawRectangleRounded(rec: Rectangle, roundness: Float64, segments: Int, color: Color): Void;
    // Draw rectangle with rounded edges outline
    public DrawRectangleRoundedLines(rec: Rectangle, roundness: Float64, segments: Int, lineThick: Float64, color: Color): Void;
    // Draw a color-filled triangle (vertex in counter-clockwise order!)
    public DrawTriangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color): Void;
    // Draw triangle outline (vertex in counter-clockwise order!)
    public DrawTriangleLines(v1: Vector2, v2: Vector2, v3: Vector2, color: Color): Void;
    // Draw a triangle fan defined by points (first vertex is the center)
    public DrawTriangleFan(points: Listed<Vector2>, pointCount: Int, color: Color): Void;
    // Draw a triangle strip defined by points
    public DrawTriangleStrip(points: Listed<Vector2>, pointCount: Int, color: Color): Void;
    // Draw a regular polygon (Vector version)
    public DrawPoly(center: Vector2, sides: Int, radius: Float64, rotation: Float64, color: Color): Void;
    // Draw a polygon outline of n sides
    public DrawPolyLines(center: Vector2, sides: Int, radius: Float64, rotation: Float64, color: Color): Void;
    // Draw a polygon outline of n sides with extended parameters
    public DrawPolyLinesEx(center: Vector2, sides: Int, radius: Float64, rotation: Float64, lineThick: Float64, color: Color): Void;
    // Draw spline: Linear, minimum 2 points
    public DrawSplineLinear(points: Listed<Vector2>, pointCount: Int, thick: Float64, color: Color): Void;
    // Draw spline: B-Spline, minimum 4 points
    public DrawSplineBasis(points: Listed<Vector2>, pointCount: Int, thick: Float64, color: Color): Void;
    // Draw spline: Catmull-Rom, minimum 4 points
    public DrawSplineCatmullRom(points: Listed<Vector2>, pointCount: Int, thick: Float64, color: Color): Void;
    // Draw spline: Quadratic Bezier, minimum 3 points (1 control point): [p1, c2, p3, c4...]
    public DrawSplineBezierQuadratic(points: Listed<Vector2>, pointCount: Int, thick: Float64, color: Color): Void;
    // Draw spline: Cubic Bezier, minimum 4 points (2 control points): [p1, c2, c3, p4, c5, c6...]
    public DrawSplineBezierCubic(points: Listed<Vector2>, pointCount: Int, thick: Float64, color: Color): Void;
    // Draw spline segment: Linear, 2 points
    public DrawSplineSegmentLinear(p1: Vector2, p2: Vector2, thick: Float64, color: Color): Void;
    // Draw spline segment: B-Spline, 4 points
    public DrawSplineSegmentBasis(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: Float64, color: Color): Void;
    // Draw spline segment: Catmull-Rom, 4 points
    public DrawSplineSegmentCatmullRom(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: Float64, color: Color): Void;
    // Draw spline segment: Quadratic Bezier, 2 points, 1 control point
    public DrawSplineSegmentBezierQuadratic(p1: Vector2, c2: Vector2, p3: Vector2, thick: Float64, color: Color): Void;
    // Draw spline segment: Cubic Bezier, 2 points, 2 control points
    public DrawSplineSegmentBezierCubic(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, thick: Float64, color: Color): Void;
    // Get (evaluate) spline point: Linear
    public GetSplinePointLinear(startPos: Vector2, endPos: Vector2, t: Float64): Vector2;
    // Get (evaluate) spline point: B-Spline
    public GetSplinePointBasis(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: Float64): Vector2;
    // Get (evaluate) spline point: Catmull-Rom
    public GetSplinePointCatmullRom(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: Float64): Vector2;
    // Get (evaluate) spline point: Quadratic Bezier
    public GetSplinePointBezierQuad(p1: Vector2, c2: Vector2, p3: Vector2, t: Float64): Vector2;
    // Get (evaluate) spline point: Cubic Bezier
    public GetSplinePointBezierCubic(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, t: Float64): Vector2;
    // Check collision between two rectangles
    public CheckCollisionRecs(rec1: Rectangle, rec2: Rectangle): Boolean;
    // Check collision between two circles
    public CheckCollisionCircles(center1: Vector2, radius1: Float64, center2: Vector2, radius2: Float64): Boolean;
    // Check collision between circle and rectangle
    public CheckCollisionCircleRec(center: Vector2, radius: Float64, rec: Rectangle): Boolean;
    // Check if point is inside rectangle
    public CheckCollisionPointRec(point: Vector2, rec: Rectangle): Boolean;
    // Check if point is inside circle
    public CheckCollisionPointCircle(point: Vector2, center: Vector2, radius: Float64): Boolean;
    // Check if point is inside a triangle
    public CheckCollisionPointTriangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2): Boolean;
    // Check if point is within a polygon described by array of vertices
    public CheckCollisionPointPoly(point: Vector2, points: Listed<Vector2>, pointCount: Int): Boolean;
    // Check the collision between two lines defined by two points each, returns collision point by reference
    public CheckCollisionLines(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: Listed<Vector2>): Boolean;
    // Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]
    public CheckCollisionPointLine(point: Vector2, p1: Vector2, p2: Vector2, threshold: Int): Boolean;
    // Get collision rectangle for two rectangles collision
    public GetCollisionRec(rec1: Rectangle, rec2: Rectangle): Rectangle;
    // Load image from file into CPU memory (RAM)
    public LoadImage(fileName: String): Image;
    // Load image from RAW file data
    public LoadImageRaw(fileName: String, width: Int, height: Int, format: Int, headerSize: Int): Image;
    // Load image from SVG file data or string with specified size
    public LoadImageSvg(fileNameOrString: String, width: Int, height: Int): Image;
    // Load image sequence from file (frames appended to image.data)
    public LoadImageAnim(fileName: String, frames: Listed<Int>): Image;
    // Load image sequence from memory buffer
    public LoadImageAnimFromMemory(fileType: String, fileData: Listed<Int>, dataSize: Int, frames: Listed<Int>): Image;
    // Load image from memory buffer, fileType refers to extension: i.e. '.png'
    public LoadImageFromMemory(fileType: String, fileData: Listed<Int>, dataSize: Int): Image;
    // Load image from GPU texture data
    public LoadImageFromTexture(texture: Texture2D): Image;
    // Load image from screen buffer and (screenshot)
    public LoadImageFromScreen(): Image;
    // Check if an image is ready
    public IsImageReady(image: Image): Boolean;
    // Unload image from CPU memory (RAM)
    public UnloadImage(image: Image): Void;
    // Export image data to file, returns true on success
    public ExportImage(image: Image, fileName: String): Boolean;
    // Export image to memory buffer
    public ExportImageToMemory(image: Image, fileType: String, fileSize: Listed<Int>): Listed<Int>;
    // Export image as code file defining an array of bytes, returns true on success
    public ExportImageAsCode(image: Image, fileName: String): Boolean;
    // Generate image: plain color
    public GenImageColor(width: Int, height: Int, color: Color): Image;
    // Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient
    public GenImageGradientLinear(width: Int, height: Int, direction: Int, start: Color, end: Color): Image;
    // Generate image: radial gradient
    public GenImageGradientRadial(width: Int, height: Int, density: Float64, inner: Color, outer: Color): Image;
    // Generate image: square gradient
    public GenImageGradientSquare(width: Int, height: Int, density: Float64, inner: Color, outer: Color): Image;
    // Generate image: checked
    public GenImageChecked(width: Int, height: Int, checksX: Int, checksY: Int, col1: Color, col2: Color): Image;
    // Generate image: white noise
    public GenImageWhiteNoise(width: Int, height: Int, factor: Float64): Image;
    // Generate image: perlin noise
    public GenImagePerlinNoise(width: Int, height: Int, offsetX: Int, offsetY: Int, scale: Float64): Image;
    // Generate image: cellular algorithm, bigger tileSize means bigger cells
    public GenImageCellular(width: Int, height: Int, tileSize: Int): Image;
    // Generate image: grayscale image from text data
    public GenImageText(width: Int, height: Int, text: String): Image;
    // Create an image duplicate (useful for transformations)
    public ImageCopy(image: Image): Image;
    // Create an image from another image piece
    public ImageFromImage(image: Image, rec: Rectangle): Image;
    // Create an image from text (default font)
    public ImageText(text: String, fontSize: Int, color: Color): Image;
    // Create an image from text (custom sprite font)
    public ImageTextEx(font: Font, text: String, fontSize: Float64, spacing: Float64, tint: Color): Image;
    // Convert image data to desired format
    public ImageFormat(image: Listed<Image>, newFormat: Int): Void;
    // Convert image to POT (power-of-two)
    public ImageToPOT(image: Listed<Image>, fill: Color): Void;
    // Crop an image to a defined rectangle
    public ImageCrop(image: Listed<Image>, crop: Rectangle): Void;
    // Crop image depending on alpha value
    public ImageAlphaCrop(image: Listed<Image>, threshold: Float64): Void;
    // Clear alpha channel to desired color
    public ImageAlphaClear(image: Listed<Image>, color: Color, threshold: Float64): Void;
    // Apply alpha mask to image
    public ImageAlphaMask(image: Listed<Image>, alphaMask: Image): Void;
    // Premultiply alpha channel
    public ImageAlphaPremultiply(image: Listed<Image>): Void;
    // Apply Gaussian blur using a box blur approximation
    public ImageBlurGaussian(image: Listed<Image>, blurSize: Int): Void;
    // Apply Custom Square image convolution kernel
    public ImageKernelConvolution(image: Listed<Image>, kernel: Listed<Float64>, kernelSize: Int): Void;
    // Resize image (Bicubic scaling algorithm)
    public ImageResize(image: Listed<Image>, newWidth: Int, newHeight: Int): Void;
    // Resize image (Nearest-Neighbor scaling algorithm)
    public ImageResizeNN(image: Listed<Image>, newWidth: Int, newHeight: Int): Void;
    // Resize canvas and fill with color
    public ImageResizeCanvas(image: Listed<Image>, newWidth: Int, newHeight: Int, offsetX: Int, offsetY: Int, fill: Color): Void;
    // Compute all mipmap levels for a provided image
    public ImageMipmaps(image: Listed<Image>): Void;
    // Dither image data to 16bpp or lower (Floyd-Steinberg dithering)
    public ImageDither(image: Listed<Image>, rBpp: Int, gBpp: Int, bBpp: Int, aBpp: Int): Void;
    // Flip image vertically
    public ImageFlipVertical(image: Listed<Image>): Void;
    // Flip image horizontally
    public ImageFlipHorizontal(image: Listed<Image>): Void;
    // Rotate image by input angle in degrees (-359 to 359)
    public ImageRotate(image: Listed<Image>, degrees: Int): Void;
    // Rotate image clockwise 90deg
    public ImageRotateCW(image: Listed<Image>): Void;
    // Rotate image counter-clockwise 90deg
    public ImageRotateCCW(image: Listed<Image>): Void;
    // Modify image color: tint
    public ImageColorTint(image: Listed<Image>, color: Color): Void;
    // Modify image color: invert
    public ImageColorInvert(image: Listed<Image>): Void;
    // Modify image color: grayscale
    public ImageColorGrayscale(image: Listed<Image>): Void;
    // Modify image color: contrast (-100 to 100)
    public ImageColorContrast(image: Listed<Image>, contrast: Float64): Void;
    // Modify image color: brightness (-255 to 255)
    public ImageColorBrightness(image: Listed<Image>, brightness: Int): Void;
    // Modify image color: replace color
    public ImageColorReplace(image: Listed<Image>, color: Color, replace: Color): Void;
    // Load color data from image as a Color array (RGBA - 32bit)
    public LoadImageColors(image: Image): Listed<Color>;
    // Load colors palette from image as a Color array (RGBA - 32bit)
    public LoadImagePalette(image: Image, maxPaletteSize: Int, colorCount: Listed<Int>): Listed<Color>;
    // Unload color data loaded with LoadImageColors()
    public UnloadImageColors(colors: Listed<Color>): Void;
    // Unload colors palette loaded with LoadImagePalette()
    public UnloadImagePalette(colors: Listed<Color>): Void;
    // Get image alpha border rectangle
    public GetImageAlphaBorder(image: Image, threshold: Float64): Rectangle;
    // Get image pixel color at (x, y) position
    public GetImageColor(image: Image, x: Int, y: Int): Color;
    // Clear image background with given color
    public ImageClearBackground(dst: Listed<Image>, color: Color): Void;
    // Draw pixel within an image
    public ImageDrawPixel(dst: Listed<Image>, posX: Int, posY: Int, color: Color): Void;
    // Draw pixel within an image (Vector version)
    public ImageDrawPixelV(dst: Listed<Image>, position: Vector2, color: Color): Void;
    // Draw line within an image
    public ImageDrawLine(dst: Listed<Image>, startPosX: Int, startPosY: Int, endPosX: Int, endPosY: Int, color: Color): Void;
    // Draw line within an image (Vector version)
    public ImageDrawLineV(dst: Listed<Image>, start: Vector2, end: Vector2, color: Color): Void;
    // Draw a filled circle within an image
    public ImageDrawCircle(dst: Listed<Image>, centerX: Int, centerY: Int, radius: Int, color: Color): Void;
    // Draw a filled circle within an image (Vector version)
    public ImageDrawCircleV(dst: Listed<Image>, center: Vector2, radius: Int, color: Color): Void;
    // Draw circle outline within an image
    public ImageDrawCircleLines(dst: Listed<Image>, centerX: Int, centerY: Int, radius: Int, color: Color): Void;
    // Draw circle outline within an image (Vector version)
    public ImageDrawCircleLinesV(dst: Listed<Image>, center: Vector2, radius: Int, color: Color): Void;
    // Draw rectangle within an image
    public ImageDrawRectangle(dst: Listed<Image>, posX: Int, posY: Int, width: Int, height: Int, color: Color): Void;
    // Draw rectangle within an image (Vector version)
    public ImageDrawRectangleV(dst: Listed<Image>, position: Vector2, size: Vector2, color: Color): Void;
    // Draw rectangle within an image
    public ImageDrawRectangleRec(dst: Listed<Image>, rec: Rectangle, color: Color): Void;
    // Draw rectangle lines within an image
    public ImageDrawRectangleLines(dst: Listed<Image>, rec: Rectangle, thick: Int, color: Color): Void;
    // Draw a source image within a destination image (tint applied to source)
    public ImageDraw(dst: Listed<Image>, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color): Void;
    // Draw text (using default font) within an image (destination)
    public ImageDrawText(dst: Listed<Image>, text: String, posX: Int, posY: Int, fontSize: Int, color: Color): Void;
    // Draw text (custom sprite font) within an image (destination)
    public ImageDrawTextEx(dst: Listed<Image>, font: Font, text: String, position: Vector2, fontSize: Float64, spacing: Float64, tint: Color): Void;
    // Load texture from file into GPU memory (VRAM)
    public LoadTexture(fileName: String): Texture2D;
    // Load texture from image data
    public LoadTextureFromImage(image: Image): Texture2D;
    // Load cubemap from image, multiple image cubemap layouts supported
    public LoadTextureCubemap(image: Image, layout: Int): TextureCubemap;
    // Load texture for rendering (framebuffer)
    public LoadRenderTexture(width: Int, height: Int): RenderTexture2D;
    // Check if a texture is ready
    public IsTextureReady(texture: Texture2D): Boolean;
    // Unload texture from GPU memory (VRAM)
    public UnloadTexture(texture: Texture2D): Void;
    // Check if a render texture is ready
    public IsRenderTextureReady(target: RenderTexture2D): Boolean;
    // Unload render texture from GPU memory (VRAM)
    public UnloadRenderTexture(target: RenderTexture2D): Void;
    // Update GPU texture with new data
    public UpdateTexture(texture: Texture2D, pixels: DenseBitVector): Void;
    // Update GPU texture rectangle with new data
    public UpdateTextureRec(texture: Texture2D, rec: Rectangle, pixels: DenseBitVector): Void;
    // Generate GPU mipmaps for a texture
    public GenTextureMipmaps(texture: Listed<Texture2D>): Void;
    // Set texture scaling filter mode
    public SetTextureFilter(texture: Texture2D, filter: Int): Void;
    // Set texture wrapping mode
    public SetTextureWrap(texture: Texture2D, wrap: Int): Void;
    // Draw a Texture2D
    public DrawTexture(texture: Texture2D, posX: Int, posY: Int, tint: Color): Void;
    // Draw a Texture2D with position defined as Vector2
    public DrawTextureV(texture: Texture2D, position: Vector2, tint: Color): Void;
    // Draw a Texture2D with extended parameters
    public DrawTextureEx(texture: Texture2D, position: Vector2, rotation: Float64, scale: Float64, tint: Color): Void;
    // Draw a part of a texture defined by a rectangle
    public DrawTextureRec(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color): Void;
    // Draw a part of a texture defined by a rectangle with 'pro' parameters
    public DrawTexturePro(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: Float64, tint: Color): Void;
    // Draws a texture (or part of it) that stretches or shrinks nicely
    public DrawTextureNPatch(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: Float64, tint: Color): Void;
    // Get color with alpha applied, alpha goes from 0.0f to 1.0f
    public Fade(color: Color, alpha: Float64): Color;
    // Get hexadecimal value for a Color
    public ColorToInt(color: Color): Int;
    // Get Color normalized as float [0..1]
    public ColorNormalize(color: Color): Vector4;
    // Get Color from normalized values [0..1]
    public ColorFromNormalized(normalized: Vector4): Color;
    // Get HSV values for a Color, hue [0..360], saturation/value [0..1]
    public ColorToHSV(color: Color): Vector3;
    // Get a Color from HSV values, hue [0..360], saturation/value [0..1]
    public ColorFromHSV(hue: Float64, saturation: Float64, value: Float64): Color;
    // Get color multiplied with another color
    public ColorTint(color: Color, tint: Color): Color;
    // Get color with brightness correction, brightness factor goes from -1.0f to 1.0f
    public ColorBrightness(color: Color, factor: Float64): Color;
    // Get color with contrast correction, contrast values between -1.0f and 1.0f
    public ColorContrast(color: Color, contrast: Float64): Color;
    // Get color with alpha applied, alpha goes from 0.0f to 1.0f
    public ColorAlpha(color: Color, alpha: Float64): Color;
    // Get src alpha-blended into dst color with tint
    public ColorAlphaBlend(dst: Color, src: Color, tint: Color): Color;
    // Get Color structure from hexadecimal value
    public GetColor(hexValue: Int): Color;
    // Get Color from a source pixel pointer of certain format
    public GetPixelColor(srcPtr: DenseBitVector, format: Int): Color;
    // Set color formatted into destination pixel pointer
    public SetPixelColor(dstPtr: DenseBitVector, color: Color, format: Int): Void;
    // Get pixel data size in bytes for certain format
    public GetPixelDataSize(width: Int, height: Int, format: Int): Int;
    // Get the default Font
    public GetFontDefault(): Font;
    // Load font from file into GPU memory (VRAM)
    public LoadFont(fileName: String): Font;
    // Load font from file with extended parameters, use NULL for codepoints and 0 for codepointCount to load the default character setFont
    public LoadFontEx(fileName: String, fontSize: Int, codepoints: Listed<Int>, codepointCount: Int): Font;
    // Load font from Image (XNA style)
    public LoadFontFromImage(image: Image, key: Color, firstChar: Int): Font;
    // Load font from memory buffer, fileType refers to extension: i.e. '.ttf'
    public LoadFontFromMemory(fileType: String, fileData: Listed<Int>, dataSize: Int, fontSize: Int, codepoints: Listed<Int>, codepointCount: Int): Font;
    // Check if a font is ready
    public IsFontReady(font: Font): Boolean;
    // Load font data for further use
    public LoadFontData(fileData: Listed<Int>, dataSize: Int, fontSize: Int, codepoints: Listed<Int>, codepointCount: Int, type: Int): Listed<GlyphInfo>;
    // Generate image font atlas using chars info
    public GenImageFontAtlas(glyphs: Listed<GlyphInfo>, glyphRecs: Listed<Listed<Rectangle>>, glyphCount: Int, fontSize: Int, padding: Int, packMethod: Int): Image;
    // Unload font chars info data (RAM)
    public UnloadFontData(glyphs: Listed<GlyphInfo>, glyphCount: Int): Void;
    // Unload font from GPU memory (VRAM)
    public UnloadFont(font: Font): Void;
    // Export font as code file, returns true on success
    public ExportFontAsCode(font: Font, fileName: String): Boolean;
    // Draw current FPS
    public DrawFPS(posX: Int, posY: Int): Void;
    // Draw text (using default font)
    public DrawText(text: String, posX: Int, posY: Int, fontSize: Int, color: Color): Void;
    // Draw text using font and additional parameters
    public DrawTextEx(font: Font, text: String, position: Vector2, fontSize: Float64, spacing: Float64, tint: Color): Void;
    // Draw text using Font and pro parameters (rotation)
    public DrawTextPro(font: Font, text: String, position: Vector2, origin: Vector2, rotation: Float64, fontSize: Float64, spacing: Float64, tint: Color): Void;
    // Draw one character (codepoint)
    public DrawTextCodepoint(font: Font, codepoint: Int, position: Vector2, fontSize: Float64, tint: Color): Void;
    // Draw multiple character (codepoint)
    public DrawTextCodepoints(font: Font, codepoints: Listed<Int>, codepointCount: Int, position: Vector2, fontSize: Float64, spacing: Float64, tint: Color): Void;
    // Set vertical line spacing when drawing with line-breaks
    public SetTextLineSpacing(spacing: Int): Void;
    // Measure string width for default font
    public MeasureText(text: String, fontSize: Int): Int;
    // Measure string size for Font
    public MeasureTextEx(font: Font, text: String, fontSize: Float64, spacing: Float64): Vector2;
    // Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found
    public GetGlyphIndex(font: Font, codepoint: Int): Int;
    // Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found
    public GetGlyphInfo(font: Font, codepoint: Int): GlyphInfo;
    // Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found
    public GetGlyphAtlasRec(font: Font, codepoint: Int): Rectangle;
    // Load UTF-8 text encoded from codepoints array
    public LoadUTF8(codepoints: Listed<Int>, length: Int): String;
    // Unload UTF-8 text encoded from codepoints array
    public UnloadUTF8(text: String): Void;
    // Load all codepoints from a UTF-8 text string, codepoints count returned by parameter
    public LoadCodepoints(text: String, count: Listed<Int>): Listed<Int>;
    // Unload codepoints data from memory
    public UnloadCodepoints(codepoints: Listed<Int>): Void;
    // Get total number of codepoints in a UTF-8 encoded string
    public GetCodepointCount(text: String): Int;
    // Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
    public GetCodepoint(text: String, codepointSize: Listed<Int>): Int;
    // Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
    public GetCodepointNext(text: String, codepointSize: Listed<Int>): Int;
    // Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
    public GetCodepointPrevious(text: String, codepointSize: Listed<Int>): Int;
    // Encode one codepoint into UTF-8 byte array (array length returned as parameter)
    public CodepointToUTF8(codepoint: Int, utf8Size: Listed<Int>): String;
    // Copy one string to another, returns bytes copied
    public TextCopy(dst: String, src: String): Int;
    // Check if two text string are equal
    public TextIsEqual(text1: String, text2: String): Boolean;
    // Get text length, checks for '\0' ending
    public TextLength(text: String): Int;
    // Get a piece of a text string
    public TextSubtext(text: String, position: Int, length: Int): String;
    // Replace text string (WARNING: memory must be freed!)
    public TextReplace(text: String, replace: String, by: String): String;
    // Insert text in a position (WARNING: memory must be freed!)
    public TextInsert(text: String, insert: String, position: Int): String;
    // Join text strings with delimiter
    public TextJoin(textList: Listed<String>, count: Int, delimiter: String): String;
    // Split text into multiple strings
    public TextSplit(text: String, delimiter: Int, count: Listed<Int>): Listed<String>;
    // Append text at specific position and move cursor!
    public TextAppend(text: String, append: String, position: Listed<Int>): Void;
    // Find first text occurrence within a string
    public TextFindIndex(text: String, find: String): Int;
    // Get upper case version of provided string
    public TextToUpper(text: String): String;
    // Get lower case version of provided string
    public TextToLower(text: String): String;
    // Get Pascal case notation version of provided string
    public TextToPascal(text: String): String;
    // Get integer value from text (negative values not supported)
    public TextToInteger(text: String): Int;
    // Get float value from text (negative values not supported)
    public TextToFloat(text: String): Float64;
    // Draw a line in 3D world space
    public DrawLine3D(startPos: Vector3, endPos: Vector3, color: Color): Void;
    // Draw a point in 3D space, actually a small line
    public DrawPoint3D(position: Vector3, color: Color): Void;
    // Draw a circle in 3D world space
    public DrawCircle3D(center: Vector3, radius: Float64, rotationAxis: Vector3, rotationAngle: Float64, color: Color): Void;
    // Draw a color-filled triangle (vertex in counter-clockwise order!)
    public DrawTriangle3D(v1: Vector3, v2: Vector3, v3: Vector3, color: Color): Void;
    // Draw a triangle strip defined by points
    public DrawTriangleStrip3D(points: Listed<Vector3>, pointCount: Int, color: Color): Void;
    // Draw cube
    public DrawCube(position: Vector3, width: Float64, height: Float64, length: Float64, color: Color): Void;
    // Draw cube (Vector version)
    public DrawCubeV(position: Vector3, size: Vector3, color: Color): Void;
    // Draw cube wires
    public DrawCubeWires(position: Vector3, width: Float64, height: Float64, length: Float64, color: Color): Void;
    // Draw cube wires (Vector version)
    public DrawCubeWiresV(position: Vector3, size: Vector3, color: Color): Void;
    // Draw sphere
    public DrawSphere(centerPos: Vector3, radius: Float64, color: Color): Void;
    // Draw sphere with extended parameters
    public DrawSphereEx(centerPos: Vector3, radius: Float64, rings: Int, slices: Int, color: Color): Void;
    // Draw sphere wires
    public DrawSphereWires(centerPos: Vector3, radius: Float64, rings: Int, slices: Int, color: Color): Void;
    // Draw a cylinder/cone
    public DrawCylinder(position: Vector3, radiusTop: Float64, radiusBottom: Float64, height: Float64, slices: Int, color: Color): Void;
    // Draw a cylinder with base at startPos and top at endPos
    public DrawCylinderEx(startPos: Vector3, endPos: Vector3, startRadius: Float64, endRadius: Float64, sides: Int, color: Color): Void;
    // Draw a cylinder/cone wires
    public DrawCylinderWires(position: Vector3, radiusTop: Float64, radiusBottom: Float64, height: Float64, slices: Int, color: Color): Void;
    // Draw a cylinder wires with base at startPos and top at endPos
    public DrawCylinderWiresEx(startPos: Vector3, endPos: Vector3, startRadius: Float64, endRadius: Float64, sides: Int, color: Color): Void;
    // Draw a capsule with the center of its sphere caps at startPos and endPos
    public DrawCapsule(startPos: Vector3, endPos: Vector3, radius: Float64, slices: Int, rings: Int, color: Color): Void;
    // Draw capsule wireframe with the center of its sphere caps at startPos and endPos
    public DrawCapsuleWires(startPos: Vector3, endPos: Vector3, radius: Float64, slices: Int, rings: Int, color: Color): Void;
    // Draw a plane XZ
    public DrawPlane(centerPos: Vector3, size: Vector2, color: Color): Void;
    // Draw a ray line
    public DrawRay(ray: Ray, color: Color): Void;
    // Draw a grid (centered at (0, 0, 0))
    public DrawGrid(slices: Int, spacing: Float64): Void;
    // Load model from files (meshes and materials)
    public LoadModel(fileName: String): Model;
    // Load model from generated mesh (default material)
    public LoadModelFromMesh(mesh: Mesh): Model;
    // Check if a model is ready
    public IsModelReady(model: Model): Boolean;
    // Unload model (including meshes) from memory (RAM and/or VRAM)
    public UnloadModel(model: Model): Void;
    // Compute model bounding box limits (considers all meshes)
    public GetModelBoundingBox(model: Model): BoundingBox;
    // Draw a model (with texture if set)
    public DrawModel(model: Model, position: Vector3, scale: Float64, tint: Color): Void;
    // Draw a model with extended parameters
    public DrawModelEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: Float64, scale: Vector3, tint: Color): Void;
    // Draw a model wires (with texture if set)
    public DrawModelWires(model: Model, position: Vector3, scale: Float64, tint: Color): Void;
    // Draw a model wires (with texture if set) with extended parameters
    public DrawModelWiresEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: Float64, scale: Vector3, tint: Color): Void;
    // Draw bounding box (wires)
    public DrawBoundingBox(box: BoundingBox, color: Color): Void;
    // Draw a billboard texture
    public DrawBillboard(camera: Camera, texture: Texture2D, position: Vector3, size: Float64, tint: Color): Void;
    // Draw a billboard texture defined by source
    public DrawBillboardRec(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color): Void;
    // Draw a billboard texture defined by source and rotation
    public DrawBillboardPro(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: Float64, tint: Color): Void;
    // Upload mesh vertex data in GPU and provide VAO/VBO ids
    public UploadMesh(mesh: Listed<Mesh>, dynamic: Boolean): Void;
    // Update mesh vertex data in GPU for a specific buffer index
    public UpdateMeshBuffer(mesh: Mesh, index: Int, data: DenseBitVector, dataSize: Int, offset: Int): Void;
    // Unload mesh data from CPU and GPU
    public UnloadMesh(mesh: Mesh): Void;
    // Draw a 3d mesh with material and transform
    public DrawMesh(mesh: Mesh, material: Material, transform: Matrix): Void;
    // Draw multiple mesh instances with material and different transforms
    public DrawMeshInstanced(mesh: Mesh, material: Material, transforms: Listed<Matrix>, instances: Int): Void;
    // Compute mesh bounding box limits
    public GetMeshBoundingBox(mesh: Mesh): BoundingBox;
    // Compute mesh tangents
    public GenMeshTangents(mesh: Listed<Mesh>): Void;
    // Export mesh data to file, returns true on success
    public ExportMesh(mesh: Mesh, fileName: String): Boolean;
    // Export mesh as code file (.h) defining multiple arrays of vertex attributes
    public ExportMeshAsCode(mesh: Mesh, fileName: String): Boolean;
    // Generate polygonal mesh
    public GenMeshPoly(sides: Int, radius: Float64): Mesh;
    // Generate plane mesh (with subdivisions)
    public GenMeshPlane(width: Float64, length: Float64, resX: Int, resZ: Int): Mesh;
    // Generate cuboid mesh
    public GenMeshCube(width: Float64, height: Float64, length: Float64): Mesh;
    // Generate sphere mesh (standard sphere)
    public GenMeshSphere(radius: Float64, rings: Int, slices: Int): Mesh;
    // Generate half-sphere mesh (no bottom cap)
    public GenMeshHemiSphere(radius: Float64, rings: Int, slices: Int): Mesh;
    // Generate cylinder mesh
    public GenMeshCylinder(radius: Float64, height: Float64, slices: Int): Mesh;
    // Generate cone/pyramid mesh
    public GenMeshCone(radius: Float64, height: Float64, slices: Int): Mesh;
    // Generate torus mesh
    public GenMeshTorus(radius: Float64, size: Float64, radSeg: Int, sides: Int): Mesh;
    // Generate trefoil knot mesh
    public GenMeshKnot(radius: Float64, size: Float64, radSeg: Int, sides: Int): Mesh;
    // Generate heightmap mesh from image data
    public GenMeshHeightmap(heightmap: Image, size: Vector3): Mesh;
    // Generate cubes-based map mesh from image data
    public GenMeshCubicmap(cubicmap: Image, cubeSize: Vector3): Mesh;
    // Load materials from model file
    public LoadMaterials(fileName: String, materialCount: Listed<Int>): Listed<Material>;
    // Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)
    public LoadMaterialDefault(): Material;
    // Check if a material is ready
    public IsMaterialReady(material: Material): Boolean;
    // Unload material from GPU memory (VRAM)
    public UnloadMaterial(material: Material): Void;
    // Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)
    public SetMaterialTexture(material: Listed<Material>, mapType: Int, texture: Texture2D): Void;
    // Set material for a mesh
    public SetModelMeshMaterial(model: Listed<Model>, meshId: Int, materialId: Int): Void;
    // Load model animations from file
    public LoadModelAnimations(fileName: String, animCount: Listed<Int>): Listed<ModelAnimation>;
    // Update model animation pose
    public UpdateModelAnimation(model: Model, anim: ModelAnimation, frame: Int): Void;
    // Unload animation data
    public UnloadModelAnimation(anim: ModelAnimation): Void;
    // Unload animation array data
    public UnloadModelAnimations(animations: Listed<ModelAnimation>, animCount: Int): Void;
    // Check model animation skeleton match
    public IsModelAnimationValid(model: Model, anim: ModelAnimation): Boolean;
    // Check collision between two spheres
    public CheckCollisionSpheres(center1: Vector3, radius1: Float64, center2: Vector3, radius2: Float64): Boolean;
    // Check collision between two bounding boxes
    public CheckCollisionBoxes(box1: BoundingBox, box2: BoundingBox): Boolean;
    // Check collision between box and sphere
    public CheckCollisionBoxSphere(box: BoundingBox, center: Vector3, radius: Float64): Boolean;
    // Get collision info between ray and sphere
    public GetRayCollisionSphere(ray: Ray, center: Vector3, radius: Float64): RayCollision;
    // Get collision info between ray and box
    public GetRayCollisionBox(ray: Ray, box: BoundingBox): RayCollision;
    // Get collision info between ray and mesh
    public GetRayCollisionMesh(ray: Ray, mesh: Mesh, transform: Matrix): RayCollision;
    // Get collision info between ray and triangle
    public GetRayCollisionTriangle(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3): RayCollision;
    // Get collision info between ray and quad
    public GetRayCollisionQuad(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3): RayCollision;
    // Initialize audio device and context
    public InitAudioDevice(): Void;
    // Close the audio device and context
    public CloseAudioDevice(): Void;
    // Check if audio device has been initialized successfully
    public IsAudioDeviceReady(): Boolean;
    // Set master volume (listener)
    public SetMasterVolume(volume: Float64): Void;
    // Get master volume (listener)
    public GetMasterVolume(): Float64;
    // Load wave data from file
    public LoadWave(fileName: String): Wave;
    // Load wave from memory buffer, fileType refers to extension: i.e. '.wav'
    public LoadWaveFromMemory(fileType: String, fileData: Listed<Int>, dataSize: Int): Wave;
    // Checks if wave data is ready
    public IsWaveReady(wave: Wave): Boolean;
    // Unload wave data
    public UnloadWave(wave: Wave): Void;
    // Export wave data to file, returns true on success
    public ExportWave(wave: Wave, fileName: String): Boolean;
    // Export wave sample data to code (.h), returns true on success
    public ExportWaveAsCode(wave: Wave, fileName: String): Boolean;
    // Copy a wave to a new wave
    public WaveCopy(wave: Wave): Wave;
    // Crop a wave to defined samples range
    public WaveCrop(wave: Listed<Wave>, initSample: Int, finalSample: Int): Void;
    // Convert wave data to desired format
    public WaveFormat(wave: Listed<Wave>, sampleRate: Int, sampleSize: Int, channels: Int): Void;
    // Load samples data from wave as a 32bit float data array
    public LoadWaveSamples(wave: Wave): Listed<Float64>;
    // Unload samples data loaded with LoadWaveSamples()
    public UnloadWaveSamples(samples: Listed<Float64>): Void;
    // Load music stream from file
    public LoadMusicStream(fileName: String): Music;
    // Load music stream from data
    public LoadMusicStreamFromMemory(fileType: String, data: Listed<Int>, dataSize: Int): Music;
    // Checks if a music stream is ready
    public IsMusicReady(music: Music): Boolean;
    // Unload music stream
    public UnloadMusicStream(music: Music): Void;
    // Start music playing
    public PlayMusicStream(music: Music): Void;
    // Check if music is playing
    public IsMusicStreamPlaying(music: Music): Boolean;
    // Updates buffers for music streaming
    public UpdateMusicStream(music: Music): Void;
    // Stop music playing
    public StopMusicStream(music: Music): Void;
    // Pause music playing
    public PauseMusicStream(music: Music): Void;
    // Resume playing paused music
    public ResumeMusicStream(music: Music): Void;
    // Seek music to a position (in seconds)
    public SeekMusicStream(music: Music, position: Float64): Void;
    // Set volume for music (1.0 is max level)
    public SetMusicVolume(music: Music, volume: Float64): Void;
    // Set pitch for a music (1.0 is base level)
    public SetMusicPitch(music: Music, pitch: Float64): Void;
    // Set pan for a music (0.5 is center)
    public SetMusicPan(music: Music, pan: Float64): Void;
    // Get music time length (in seconds)
    public GetMusicTimeLength(music: Music): Float64;
    // Get current music time played (in seconds)
    public GetMusicTimePlayed(music: Music): Float64;
    // Load audio stream (to stream raw audio pcm data)
    public LoadAudioStream(sampleRate: Int, sampleSize: Int, channels: Int): AudioStream;
    // Checks if an audio stream is ready
    public IsAudioStreamReady(stream: AudioStream): Boolean;
    // Unload audio stream and free memory
    public UnloadAudioStream(stream: AudioStream): Void;
    // Update audio stream buffers with data
    public UpdateAudioStream(stream: AudioStream, data: DenseBitVector, frameCount: Int): Void;
    // Check if any audio stream buffers requires refill
    public IsAudioStreamProcessed(stream: AudioStream): Boolean;
    // Play audio stream
    public PlayAudioStream(stream: AudioStream): Void;
    // Pause audio stream
    public PauseAudioStream(stream: AudioStream): Void;
    // Resume audio stream
    public ResumeAudioStream(stream: AudioStream): Void;
    // Check if audio stream is playing
    public IsAudioStreamPlaying(stream: AudioStream): Boolean;
    // Stop audio stream
    public StopAudioStream(stream: AudioStream): Void;
    // Set volume for audio stream (1.0 is max level)
    public SetAudioStreamVolume(stream: AudioStream, volume: Float64): Void;
    // Set pitch for audio stream (1.0 is base level)
    public SetAudioStreamPitch(stream: AudioStream, pitch: Float64): Void;
    // Set pan for audio stream (0.5 is centered)
    public SetAudioStreamPan(stream: AudioStream, pan: Float64): Void;
    // Default size for new audio streams
    public SetAudioStreamBufferSizeDefault(size: Int): Void;
    // 
    public Clamp(value: Float64, min: Float64, max: Float64): Float64;
    // 
    public Lerp(start: Float64, end: Float64, amount: Float64): Float64;
    // 
    public Normalize(value: Float64, start: Float64, end: Float64): Float64;
    // 
    public Remap(value: Float64, inputStart: Float64, inputEnd: Float64, outputStart: Float64, outputEnd: Float64): Float64;
    // 
    public Wrap(value: Float64, min: Float64, max: Float64): Float64;
    // 
    public FloatEquals(x: Float64, y: Float64): Int;
    // 
    public Vector2Zero(): Vector2;
    // 
    public Vector2One(): Vector2;
    // 
    public Vector2Add(v1: Vector2, v2: Vector2): Vector2;
    // 
    public Vector2AddValue(v: Vector2, add: Float64): Vector2;
    // 
    public Vector2Subtract(v1: Vector2, v2: Vector2): Vector2;
    // 
    public Vector2SubtractValue(v: Vector2, sub: Float64): Vector2;
    // 
    public Vector2Length(v: Vector2): Float64;
    // 
    public Vector2LengthSqr(v: Vector2): Float64;
    // 
    public Vector2DotProduct(v1: Vector2, v2: Vector2): Float64;
    // 
    public Vector2Distance(v1: Vector2, v2: Vector2): Float64;
    // 
    public Vector2DistanceSqr(v1: Vector2, v2: Vector2): Float64;
    // 
    public Vector2Angle(v1: Vector2, v2: Vector2): Float64;
    // 
    public Vector2LineAngle(start: Vector2, end: Vector2): Float64;
    // 
    public Vector2Scale(v: Vector2, scale: Float64): Vector2;
    // 
    public Vector2Multiply(v1: Vector2, v2: Vector2): Vector2;
    // 
    public Vector2Negate(v: Vector2): Vector2;
    // 
    public Vector2Divide(v1: Vector2, v2: Vector2): Vector2;
    // 
    public Vector2Normalize(v: Vector2): Vector2;
    // 
    public Vector2Transform(v: Vector2, mat: Matrix): Vector2;
    // 
    public Vector2Lerp(v1: Vector2, v2: Vector2, amount: Float64): Vector2;
    // 
    public Vector2Reflect(v: Vector2, normal: Vector2): Vector2;
    // 
    public Vector2Rotate(v: Vector2, angle: Float64): Vector2;
    // 
    public Vector2MoveTowards(v: Vector2, target: Vector2, maxDistance: Float64): Vector2;
    // 
    public Vector2Invert(v: Vector2): Vector2;
    // 
    public Vector2Clamp(v: Vector2, min: Vector2, max: Vector2): Vector2;
    // 
    public Vector2ClampValue(v: Vector2, min: Float64, max: Float64): Vector2;
    // 
    public Vector2Equals(p: Vector2, q: Vector2): Int;
    // 
    public Vector3Zero(): Vector3;
    // 
    public Vector3One(): Vector3;
    // 
    public Vector3Add(v1: Vector3, v2: Vector3): Vector3;
    // 
    public Vector3AddValue(v: Vector3, add: Float64): Vector3;
    // 
    public Vector3Subtract(v1: Vector3, v2: Vector3): Vector3;
    // 
    public Vector3SubtractValue(v: Vector3, sub: Float64): Vector3;
    // 
    public Vector3Scale(v: Vector3, scalar: Float64): Vector3;
    // 
    public Vector3Multiply(v1: Vector3, v2: Vector3): Vector3;
    // 
    public Vector3CrossProduct(v1: Vector3, v2: Vector3): Vector3;
    // 
    public Vector3Perpendicular(v: Vector3): Vector3;
    // 
    public Vector3Length(v: Vector3): Float64;
    // 
    public Vector3LengthSqr(v: Vector3): Float64;
    // 
    public Vector3DotProduct(v1: Vector3, v2: Vector3): Float64;
    // 
    public Vector3Distance(v1: Vector3, v2: Vector3): Float64;
    // 
    public Vector3DistanceSqr(v1: Vector3, v2: Vector3): Float64;
    // 
    public Vector3Angle(v1: Vector3, v2: Vector3): Float64;
    // 
    public Vector3Negate(v: Vector3): Vector3;
    // 
    public Vector3Divide(v1: Vector3, v2: Vector3): Vector3;
    // 
    public Vector3Normalize(v: Vector3): Vector3;
    // 
    public Vector3Project(v1: Vector3, v2: Vector3): Vector3;
    // 
    public Vector3Reject(v1: Vector3, v2: Vector3): Vector3;
    // 
    public Vector3OrthoNormalize(v1: Listed<Vector3>, v2: Listed<Vector3>): Void;
    // 
    public Vector3Transform(v: Vector3, mat: Matrix): Vector3;
    // 
    public Vector3RotateByQuaternion(v: Vector3, q: Quaternion): Vector3;
    // 
    public Vector3RotateByAxisAngle(v: Vector3, axis: Vector3, angle: Float64): Vector3;
    // 
    public Vector3Lerp(v1: Vector3, v2: Vector3, amount: Float64): Vector3;
    // 
    public Vector3Reflect(v: Vector3, normal: Vector3): Vector3;
    // 
    public Vector3Min(v1: Vector3, v2: Vector3): Vector3;
    // 
    public Vector3Max(v1: Vector3, v2: Vector3): Vector3;
    // 
    public Vector3Barycenter(p: Vector3, a: Vector3, b: Vector3, c: Vector3): Vector3;
    // 
    public Vector3Unproject(source: Vector3, projection: Matrix, view: Matrix): Vector3;
    // 
    public Vector3ToFloatV(v: Vector3): float3;
    // 
    public Vector3Invert(v: Vector3): Vector3;
    // 
    public Vector3Clamp(v: Vector3, min: Vector3, max: Vector3): Vector3;
    // 
    public Vector3ClampValue(v: Vector3, min: Float64, max: Float64): Vector3;
    // 
    public Vector3Equals(p: Vector3, q: Vector3): Int;
    // 
    public Vector3Refract(v: Vector3, n: Vector3, r: Float64): Vector3;
    // 
    public MatrixDeterminant(mat: Matrix): Float64;
    // 
    public MatrixTrace(mat: Matrix): Float64;
    // 
    public MatrixTranspose(mat: Matrix): Matrix;
    // 
    public MatrixInvert(mat: Matrix): Matrix;
    // 
    public MatrixIdentity(): Matrix;
    // 
    public MatrixAdd(left: Matrix, right: Matrix): Matrix;
    // 
    public MatrixSubtract(left: Matrix, right: Matrix): Matrix;
    // 
    public MatrixMultiply(left: Matrix, right: Matrix): Matrix;
    // 
    public MatrixTranslate(x: Float64, y: Float64, z: Float64): Matrix;
    // 
    public MatrixRotate(axis: Vector3, angle: Float64): Matrix;
    // 
    public MatrixRotateX(angle: Float64): Matrix;
    // 
    public MatrixRotateY(angle: Float64): Matrix;
    // 
    public MatrixRotateZ(angle: Float64): Matrix;
    // 
    public MatrixRotateXYZ(angle: Vector3): Matrix;
    // 
    public MatrixRotateZYX(angle: Vector3): Matrix;
    // 
    public MatrixScale(x: Float64, y: Float64, z: Float64): Matrix;
    // 
    public MatrixFrustum(left: Float64, right: Float64, bottom: Float64, top: Float64, near: Float64, far: Float64): Matrix;
    // 
    public MatrixPerspective(fovY: Float64, aspect: Float64, nearPlane: Float64, farPlane: Float64): Matrix;
    // 
    public MatrixOrtho(left: Float64, right: Float64, bottom: Float64, top: Float64, nearPlane: Float64, farPlane: Float64): Matrix;
    // 
    public MatrixLookAt(eye: Vector3, target: Vector3, up: Vector3): Matrix;
    // 
    public MatrixToFloatV(mat: Matrix): float16;
    // 
    public QuaternionAdd(q1: Quaternion, q2: Quaternion): Quaternion;
    // 
    public QuaternionAddValue(q: Quaternion, add: Float64): Quaternion;
    // 
    public QuaternionSubtract(q1: Quaternion, q2: Quaternion): Quaternion;
    // 
    public QuaternionSubtractValue(q: Quaternion, sub: Float64): Quaternion;
    // 
    public QuaternionIdentity(): Quaternion;
    // 
    public QuaternionLength(q: Quaternion): Float64;
    // 
    public QuaternionNormalize(q: Quaternion): Quaternion;
    // 
    public QuaternionInvert(q: Quaternion): Quaternion;
    // 
    public QuaternionMultiply(q1: Quaternion, q2: Quaternion): Quaternion;
    // 
    public QuaternionScale(q: Quaternion, mul: Float64): Quaternion;
    // 
    public QuaternionDivide(q1: Quaternion, q2: Quaternion): Quaternion;
    // 
    public QuaternionLerp(q1: Quaternion, q2: Quaternion, amount: Float64): Quaternion;
    // 
    public QuaternionNlerp(q1: Quaternion, q2: Quaternion, amount: Float64): Quaternion;
    // 
    public QuaternionSlerp(q1: Quaternion, q2: Quaternion, amount: Float64): Quaternion;
    // 
    public QuaternionFromVector3ToVector3(from: Vector3, to: Vector3): Quaternion;
    // 
    public QuaternionFromMatrix(mat: Matrix): Quaternion;
    // 
    public QuaternionToMatrix(q: Quaternion): Matrix;
    // 
    public QuaternionFromAxisAngle(axis: Vector3, angle: Float64): Quaternion;
    // 
    public QuaternionToAxisAngle(q: Quaternion, outAxis: Listed<Vector3>, outAngle: Listed<Float64>): Void;
    // 
    public QuaternionFromEuler(pitch: Float64, yaw: Float64, roll: Float64): Quaternion;
    // 
    public QuaternionToEuler(q: Quaternion): Vector3;
    // 
    public QuaternionTransform(q: Quaternion, mat: Matrix): Quaternion;
    // 
    public QuaternionEquals(p: Quaternion, q: Quaternion): Int;
    // Choose the current matrix to be transformed
    public rlMatrixMode(mode: Int): Void;
    // Push the current matrix to stack
    public rlPushMatrix(): Void;
    // Pop latest inserted matrix from stack
    public rlPopMatrix(): Void;
    // Reset current matrix to identity matrix
    public rlLoadIdentity(): Void;
    // Multiply the current matrix by a translation matrix
    public rlTranslatef(x: Float64, y: Float64, z: Float64): Void;
    // Multiply the current matrix by a rotation matrix
    public rlRotatef(angle: Float64, x: Float64, y: Float64, z: Float64): Void;
    // Multiply the current matrix by a scaling matrix
    public rlScalef(x: Float64, y: Float64, z: Float64): Void;
    // Multiply the current matrix by another matrix
    public rlMultMatrixf(matf: Listed<Float64>): Void;
    // 
    public rlFrustum(left: Float64, right: Float64, bottom: Float64, top: Float64, znear: Float64, zfar: Float64): Void;
    // 
    public rlOrtho(left: Float64, right: Float64, bottom: Float64, top: Float64, znear: Float64, zfar: Float64): Void;
    // Set the viewport area
    public rlViewport(x: Int, y: Int, width: Int, height: Int): Void;
    // Initialize drawing mode (how to organize vertex)
    public rlBegin(mode: Int): Void;
    // Finish vertex providing
    public rlEnd(): Void;
    // Define one vertex (position) - 2 int
    public rlVertex2i(x: Int, y: Int): Void;
    // Define one vertex (position) - 2 float
    public rlVertex2f(x: Float64, y: Float64): Void;
    // Define one vertex (position) - 3 float
    public rlVertex3f(x: Float64, y: Float64, z: Float64): Void;
    // Define one vertex (texture coordinate) - 2 float
    public rlTexCoord2f(x: Float64, y: Float64): Void;
    // Define one vertex (normal) - 3 float
    public rlNormal3f(x: Float64, y: Float64, z: Float64): Void;
    // Define one vertex (color) - 4 byte
    public rlColor4ub(r: Int, g: Int, b: Int, a: Int): Void;
    // Define one vertex (color) - 3 float
    public rlColor3f(x: Float64, y: Float64, z: Float64): Void;
    // Define one vertex (color) - 4 float
    public rlColor4f(x: Float64, y: Float64, z: Float64, w: Float64): Void;
    // Enable vertex array (VAO, if supported)
    public rlEnableVertexArray(vaoId: Int): Boolean;
    // Disable vertex array (VAO, if supported)
    public rlDisableVertexArray(): Void;
    // Enable vertex buffer (VBO)
    public rlEnableVertexBuffer(id: Int): Void;
    // Disable vertex buffer (VBO)
    public rlDisableVertexBuffer(): Void;
    // Enable vertex buffer element (VBO element)
    public rlEnableVertexBufferElement(id: Int): Void;
    // Disable vertex buffer element (VBO element)
    public rlDisableVertexBufferElement(): Void;
    // Enable vertex attribute index
    public rlEnableVertexAttribute(index: Int): Void;
    // Disable vertex attribute index
    public rlDisableVertexAttribute(index: Int): Void;
    // Select and active a texture slot
    public rlActiveTextureSlot(slot: Int): Void;
    // Enable texture
    public rlEnableTexture(id: Int): Void;
    // Disable texture
    public rlDisableTexture(): Void;
    // Enable texture cubemap
    public rlEnableTextureCubemap(id: Int): Void;
    // Disable texture cubemap
    public rlDisableTextureCubemap(): Void;
    // Set texture parameters (filter, wrap)
    public rlTextureParameters(id: Int, param: Int, value: Int): Void;
    // Set cubemap parameters (filter, wrap)
    public rlCubemapParameters(id: Int, param: Int, value: Int): Void;
    // Enable shader program
    public rlEnableShader(id: Int): Void;
    // Disable shader program
    public rlDisableShader(): Void;
    // Enable render texture (fbo)
    public rlEnableFramebuffer(id: Int): Void;
    // Disable render texture (fbo), return to default framebuffer
    public rlDisableFramebuffer(): Void;
    // Activate multiple draw color buffers
    public rlActiveDrawBuffers(count: Int): Void;
    // Blit active framebuffer to main framebuffer
    public rlBlitFramebuffer(srcX: Int, srcY: Int, srcWidth: Int, srcHeight: Int, dstX: Int, dstY: Int, dstWidth: Int, dstHeight: Int, bufferMask: Int): Void;
    // Bind framebuffer (FBO) 
    public rlBindFramebuffer(target: Int, framebuffer: Int): Void;
    // Enable color blending
    public rlEnableColorBlend(): Void;
    // Disable color blending
    public rlDisableColorBlend(): Void;
    // Enable depth test
    public rlEnableDepthTest(): Void;
    // Disable depth test
    public rlDisableDepthTest(): Void;
    // Enable depth write
    public rlEnableDepthMask(): Void;
    // Disable depth write
    public rlDisableDepthMask(): Void;
    // Enable backface culling
    public rlEnableBackfaceCulling(): Void;
    // Disable backface culling
    public rlDisableBackfaceCulling(): Void;
    // Color mask control
    public rlColorMask(r: Boolean, g: Boolean, b: Boolean, a: Boolean): Void;
    // Set face culling mode
    public rlSetCullFace(mode: Int): Void;
    // Enable scissor test
    public rlEnableScissorTest(): Void;
    // Disable scissor test
    public rlDisableScissorTest(): Void;
    // Scissor test
    public rlScissor(x: Int, y: Int, width: Int, height: Int): Void;
    // Enable wire mode
    public rlEnableWireMode(): Void;
    // Enable point mode
    public rlEnablePointMode(): Void;
    // Disable wire mode ( and point ) maybe rename
    public rlDisableWireMode(): Void;
    // Set the line drawing width
    public rlSetLineWidth(width: Float64): Void;
    // Get the line drawing width
    public rlGetLineWidth(): Float64;
    // Enable line aliasing
    public rlEnableSmoothLines(): Void;
    // Disable line aliasing
    public rlDisableSmoothLines(): Void;
    // Enable stereo rendering
    public rlEnableStereoRender(): Void;
    // Disable stereo rendering
    public rlDisableStereoRender(): Void;
    // Check if stereo render is enabled
    public rlIsStereoRenderEnabled(): Boolean;
    // Clear color buffer with color
    public rlClearColor(r: Int, g: Int, b: Int, a: Int): Void;
    // Clear used screen buffers (color and depth)
    public rlClearScreenBuffers(): Void;
    // Check and log OpenGL error codes
    public rlCheckErrors(): Void;
    // Set blending mode
    public rlSetBlendMode(mode: Int): Void;
    // Set blending mode factor and equation (using OpenGL factors)
    public rlSetBlendFactors(glSrcFactor: Int, glDstFactor: Int, glEquation: Int): Void;
    // Set blending mode factors and equations separately (using OpenGL factors)
    public rlSetBlendFactorsSeparate(glSrcRGB: Int, glDstRGB: Int, glSrcAlpha: Int, glDstAlpha: Int, glEqRGB: Int, glEqAlpha: Int): Void;
    // Initialize rlgl (buffers, shaders, textures, states)
    public rlglInit(width: Int, height: Int): Void;
    // De-initialize rlgl (buffers, shaders, textures)
    public rlglClose(): Void;
    // Load OpenGL extensions (loader function required)
    public rlLoadExtensions(loader: DenseBitVector): Void;
    // Get current OpenGL version
    public rlGetVersion(): Int;
    // Set current framebuffer width
    public rlSetFramebufferWidth(width: Int): Void;
    // Get default framebuffer width
    public rlGetFramebufferWidth(): Int;
    // Set current framebuffer height
    public rlSetFramebufferHeight(height: Int): Void;
    // Get default framebuffer height
    public rlGetFramebufferHeight(): Int;
    // Get default texture id
    public rlGetTextureIdDefault(): Int;
    // Get default shader id
    public rlGetShaderIdDefault(): Int;
    // Get default shader locations
    public rlGetShaderLocsDefault(): Listed<Int>;
    // Load a render batch system
    public rlLoadRenderBatch(numBuffers: Int, bufferElements: Int): rlRenderBatch;
    // Unload render batch system
    public rlUnloadRenderBatch(batch: rlRenderBatch): Void;
    // Draw render batch data (Update->Draw->Reset)
    public rlDrawRenderBatch(batch: Listed<rlRenderBatch>): Void;
    // Set the active render batch for rlgl (NULL for default internal)
    public rlSetRenderBatchActive(batch: Listed<rlRenderBatch>): Void;
    // Update and draw internal render batch
    public rlDrawRenderBatchActive(): Void;
    // Check internal buffer overflow for a given number of vertex
    public rlCheckRenderBatchLimit(vCount: Int): Boolean;
    // Set current texture for render batch and check buffers limits
    public rlSetTexture(id: Int): Void;
    // Load vertex array (vao) if supported
    public rlLoadVertexArray(): Int;
    // Load a vertex buffer object
    public rlLoadVertexBuffer(buffer: DenseBitVector, size: Int, dynamic: Boolean): Int;
    // Load vertex buffer elements object
    public rlLoadVertexBufferElement(buffer: DenseBitVector, size: Int, dynamic: Boolean): Int;
    // Update vertex buffer object data on GPU buffer
    public rlUpdateVertexBuffer(bufferId: Int, data: DenseBitVector, dataSize: Int, offset: Int): Void;
    // Update vertex buffer elements data on GPU buffer
    public rlUpdateVertexBufferElements(id: Int, data: DenseBitVector, dataSize: Int, offset: Int): Void;
    // Unload vertex array (vao)
    public rlUnloadVertexArray(vaoId: Int): Void;
    // Unload vertex buffer object
    public rlUnloadVertexBuffer(vboId: Int): Void;
    // Set vertex attribute data configuration
    public rlSetVertexAttribute(index: Int, compSize: Int, type: Int, normalized: Boolean, stride: Int, pointer: DenseBitVector): Void;
    // Set vertex attribute data divisor
    public rlSetVertexAttributeDivisor(index: Int, divisor: Int): Void;
    // Set vertex attribute default value, when attribute to provided
    public rlSetVertexAttributeDefault(locIndex: Int, value: DenseBitVector, attribType: Int, count: Int): Void;
    // Draw vertex array (currently active vao)
    public rlDrawVertexArray(offset: Int, count: Int): Void;
    // Draw vertex array elements
    public rlDrawVertexArrayElements(offset: Int, count: Int, buffer: DenseBitVector): Void;
    // Draw vertex array (currently active vao) with instancing
    public rlDrawVertexArrayInstanced(offset: Int, count: Int, instances: Int): Void;
    // Draw vertex array elements with instancing
    public rlDrawVertexArrayElementsInstanced(offset: Int, count: Int, buffer: DenseBitVector, instances: Int): Void;
    // Load texture data
    public rlLoadTexture(data: DenseBitVector, width: Int, height: Int, format: Int, mipmapCount: Int): Int;
    // Load depth texture/renderbuffer (to be attached to fbo)
    public rlLoadTextureDepth(width: Int, height: Int, useRenderBuffer: Boolean): Int;
    // Load texture cubemap data
    public rlLoadTextureCubemap(data: DenseBitVector, size: Int, format: Int): Int;
    // Update texture with new data on GPU
    public rlUpdateTexture(id: Int, offsetX: Int, offsetY: Int, width: Int, height: Int, format: Int, data: DenseBitVector): Void;
    // Get OpenGL internal formats
    public rlGetGlTextureFormats(format: Int, glInternalFormat: Listed<Int>, glFormat: Listed<Int>, glType: Listed<Int>): Void;
    // Get name string for pixel format
    public rlGetPixelFormatName(format: Int): String;
    // Unload texture from GPU memory
    public rlUnloadTexture(id: Int): Void;
    // Generate mipmap data for selected texture
    public rlGenTextureMipmaps(id: Int, width: Int, height: Int, format: Int, mipmaps: Listed<Int>): Void;
    // Read texture pixel data
    public rlReadTexturePixels(id: Int, width: Int, height: Int, format: Int): DenseBitVector;
    // Read screen pixel data (color buffer)
    public rlReadScreenPixels(width: Int, height: Int): Listed<Int>;
    // Load an empty framebuffer
    public rlLoadFramebuffer(width: Int, height: Int): Int;
    // Attach texture/renderbuffer to a framebuffer
    public rlFramebufferAttach(fboId: Int, texId: Int, attachType: Int, texType: Int, mipLevel: Int): Void;
    // Verify framebuffer is complete
    public rlFramebufferComplete(id: Int): Boolean;
    // Delete framebuffer from GPU
    public rlUnloadFramebuffer(id: Int): Void;
    // Load shader from code strings
    public rlLoadShaderCode(vsCode: String, fsCode: String): Int;
    // Compile custom shader and return shader id (type: RL_VERTEX_SHADER, RL_FRAGMENT_SHADER, RL_COMPUTE_SHADER)
    public rlCompileShader(shaderCode: String, type: Int): Int;
    // Load custom shader program
    public rlLoadShaderProgram(vShaderId: Int, fShaderId: Int): Int;
    // Unload shader program
    public rlUnloadShaderProgram(id: Int): Void;
    // Get shader location uniform
    public rlGetLocationUniform(shaderId: Int, uniformName: String): Int;
    // Get shader location attribute
    public rlGetLocationAttrib(shaderId: Int, attribName: String): Int;
    // Set shader value uniform
    public rlSetUniform(locIndex: Int, value: DenseBitVector, uniformType: Int, count: Int): Void;
    // Set shader value matrix
    public rlSetUniformMatrix(locIndex: Int, mat: Matrix): Void;
    // Set shader value sampler
    public rlSetUniformSampler(locIndex: Int, textureId: Int): Void;
    // Set shader currently active (id and locations)
    public rlSetShader(id: Int, locs: Listed<Int>): Void;
    // Load compute shader program
    public rlLoadComputeShaderProgram(shaderId: Int): Int;
    // Dispatch compute shader (equivalent to *draw* for graphics pipeline)
    public rlComputeShaderDispatch(groupX: Int, groupY: Int, groupZ: Int): Void;
    // Load shader storage buffer object (SSBO)
    public rlLoadShaderBuffer(size: Int, data: DenseBitVector, usageHint: Int): Int;
    // Unload shader storage buffer object (SSBO)
    public rlUnloadShaderBuffer(ssboId: Int): Void;
    // Update SSBO buffer data
    public rlUpdateShaderBuffer(id: Int, data: DenseBitVector, dataSize: Int, offset: Int): Void;
    // Bind SSBO buffer
    public rlBindShaderBuffer(id: Int, index: Int): Void;
    // Read SSBO buffer data (GPU->CPU)
    public rlReadShaderBuffer(id: Int, dest: DenseBitVector, count: Int, offset: Int): Void;
    // Copy SSBO data between buffers
    public rlCopyShaderBuffer(destId: Int, srcId: Int, destOffset: Int, srcOffset: Int, count: Int): Void;
    // Get SSBO buffer size
    public rlGetShaderBufferSize(id: Int): Int;
    // Bind image texture
    public rlBindImageTexture(id: Int, index: Int, format: Int, readonly: Boolean): Void;
    // Get internal modelview matrix
    public rlGetMatrixModelview(): Matrix;
    // Get internal projection matrix
    public rlGetMatrixProjection(): Matrix;
    // Get internal accumulated transform matrix
    public rlGetMatrixTransform(): Matrix;
    // Get internal projection matrix for stereo render (selected eye)
    public rlGetMatrixProjectionStereo(eye: Int): Matrix;
    // Get internal view offset matrix for stereo render (selected eye)
    public rlGetMatrixViewOffsetStereo(eye: Int): Matrix;
    // Set a custom projection matrix (replaces internal projection matrix)
    public rlSetMatrixProjection(proj: Matrix): Void;
    // Set a custom modelview matrix (replaces internal modelview matrix)
    public rlSetMatrixModelview(view: Matrix): Void;
    // Set eyes projection matrices for stereo rendering
    public rlSetMatrixProjectionStereo(right: Matrix, left: Matrix): Void;
    // Set eyes view offsets matrices for stereo rendering
    public rlSetMatrixViewOffsetStereo(right: Matrix, left: Matrix): Void;
    // Load and draw a cube
    public rlLoadDrawCube(): Void;
    // Load and draw a quad
    public rlLoadDrawQuad(): Void;
}

let rl: Raylib;
export let use(impl: Raylib): Void { rl = impl; }
// Enable gui controls (global state)
export let GuiEnable(): Void {
    rl.GuiEnable();
}
// Disable gui controls (global state)
export let GuiDisable(): Void {
    rl.GuiDisable();
}
// Lock gui controls (global state)
export let GuiLock(): Void {
    rl.GuiLock();
}
// Unlock gui controls (global state)
export let GuiUnlock(): Void {
    rl.GuiUnlock();
}
// Check if gui is locked (global state)
export let GuiIsLocked(): Boolean {
    return rl.GuiIsLocked();
}
// Set gui controls alpha (global state), alpha goes from 0.0f to 1.0f
export let GuiSetAlpha(alpha: Float64): Void {
    rl.GuiSetAlpha(alpha);
}
// Set gui state (global state)
export let GuiSetState(state: Int): Void {
    rl.GuiSetState(state);
}
// Get gui state (global state)
export let GuiGetState(): Int {
    return rl.GuiGetState();
}
// Set gui custom font (global state)
export let GuiSetFont(font: Font): Void {
    rl.GuiSetFont(font);
}
// Get gui custom font (global state)
export let GuiGetFont(): Font {
    return rl.GuiGetFont();
}
// Set one style property
export let GuiSetStyle(control: Int, property: Int, value: Int): Void {
    rl.GuiSetStyle(control, property, value);
}
// Get one style property
export let GuiGetStyle(control: Int, property: Int): Int {
    return rl.GuiGetStyle(control, property);
}
// Load style file over global style variable (.rgs)
export let GuiLoadStyle(fileName: String): Void {
    rl.GuiLoadStyle(fileName);
}
// Load style default over global style
export let GuiLoadStyleDefault(): Void {
    rl.GuiLoadStyleDefault();
}
// Enable gui tooltips (global state)
export let GuiEnableTooltip(): Void {
    rl.GuiEnableTooltip();
}
// Disable gui tooltips (global state)
export let GuiDisableTooltip(): Void {
    rl.GuiDisableTooltip();
}
// Set tooltip string
export let GuiSetTooltip(tooltip: String): Void {
    rl.GuiSetTooltip(tooltip);
}
// Get text with icon id prepended (if supported)
export let GuiIconText(iconId: Int, text: String): String {
    return rl.GuiIconText(iconId, text);
}
// Window Box control, shows a window that can be closed
export let GuiWindowBox(bounds: Rectangle, title: String): Int {
    return rl.GuiWindowBox(bounds, title);
}
// Group Box control with text name
export let GuiGroupBox(bounds: Rectangle, text: String): Int {
    return rl.GuiGroupBox(bounds, text);
}
// Line separator control, could contain text
export let GuiLine(bounds: Rectangle, text: String): Int {
    return rl.GuiLine(bounds, text);
}
// Panel control, useful to group controls
export let GuiPanel(bounds: Rectangle, text: String): Int {
    return rl.GuiPanel(bounds, text);
}
// Tab Bar control, returns TAB to be closed or -1
export let GuiTabBar(bounds: Rectangle, text: Listed<String>, count: Int, active: Listed<Int>): Int {
    return rl.GuiTabBar(bounds, text, count, active);
}
// Scroll Panel control
export let GuiScrollPanel(bounds: Rectangle, text: String, content: Rectangle, scroll: Listed<Vector2>, view: Listed<Rectangle>): Int {
    return rl.GuiScrollPanel(bounds, text, content, scroll, view);
}
// Label control, shows text
export let GuiLabel(bounds: Rectangle, text: String): Int {
    return rl.GuiLabel(bounds, text);
}
// Button control, returns true when clicked
export let GuiButton(bounds: Rectangle, text: String): Int {
    return rl.GuiButton(bounds, text);
}
// Label button control, show true when clicked
export let GuiLabelButton(bounds: Rectangle, text: String): Int {
    return rl.GuiLabelButton(bounds, text);
}
// Toggle Button control, returns true when active
export let GuiToggle(bounds: Rectangle, text: String, active: Listed<Boolean>): Int {
    return rl.GuiToggle(bounds, text, active);
}
// Toggle Group control, returns active toggle index
export let GuiToggleGroup(bounds: Rectangle, text: String, active: Listed<Int>): Int {
    return rl.GuiToggleGroup(bounds, text, active);
}
// Toggle Slider control, returns true when clicked
export let GuiToggleSlider(bounds: Rectangle, text: String, active: Listed<Int>): Int {
    return rl.GuiToggleSlider(bounds, text, active);
}
// Check Box control, returns true when active
export let GuiCheckBox(bounds: Rectangle, text: String, checked: Listed<Boolean>): Int {
    return rl.GuiCheckBox(bounds, text, checked);
}
// Combo Box control, returns selected item index
export let GuiComboBox(bounds: Rectangle, text: String, active: Listed<Int>): Int {
    return rl.GuiComboBox(bounds, text, active);
}
// Dropdown Box control, returns selected item
export let GuiDropdownBox(bounds: Rectangle, text: String, active: Listed<Int>, editMode: Boolean): Int {
    return rl.GuiDropdownBox(bounds, text, active, editMode);
}
// Spinner control, returns selected value
export let GuiSpinner(bounds: Rectangle, text: String, value: Listed<Int>, minValue: Int, maxValue: Int, editMode: Boolean): Int {
    return rl.GuiSpinner(bounds, text, value, minValue, maxValue, editMode);
}
// Value Box control, updates input text with numbers
export let GuiValueBox(bounds: Rectangle, text: String, value: Listed<Int>, minValue: Int, maxValue: Int, editMode: Boolean): Int {
    return rl.GuiValueBox(bounds, text, value, minValue, maxValue, editMode);
}
// Text Box control, updates input text
export let GuiTextBox(bounds: Rectangle, text: String, textSize: Int, editMode: Boolean): Int {
    return rl.GuiTextBox(bounds, text, textSize, editMode);
}
// Slider control, returns selected value
export let GuiSlider(bounds: Rectangle, textLeft: String, textRight: String, value: Listed<Float64>, minValue: Float64, maxValue: Float64): Int {
    return rl.GuiSlider(bounds, textLeft, textRight, value, minValue, maxValue);
}
// Slider Bar control, returns selected value
export let GuiSliderBar(bounds: Rectangle, textLeft: String, textRight: String, value: Listed<Float64>, minValue: Float64, maxValue: Float64): Int {
    return rl.GuiSliderBar(bounds, textLeft, textRight, value, minValue, maxValue);
}
// Progress Bar control, shows current progress value
export let GuiProgressBar(bounds: Rectangle, textLeft: String, textRight: String, value: Listed<Float64>, minValue: Float64, maxValue: Float64): Int {
    return rl.GuiProgressBar(bounds, textLeft, textRight, value, minValue, maxValue);
}
// Status Bar control, shows info text
export let GuiStatusBar(bounds: Rectangle, text: String): Int {
    return rl.GuiStatusBar(bounds, text);
}
// Dummy control for placeholders
export let GuiDummyRec(bounds: Rectangle, text: String): Int {
    return rl.GuiDummyRec(bounds, text);
}
// Grid control, returns mouse cell position
export let GuiGrid(bounds: Rectangle, text: String, spacing: Float64, subdivs: Int, mouseCell: Listed<Vector2>): Int {
    return rl.GuiGrid(bounds, text, spacing, subdivs, mouseCell);
}
// List View control, returns selected list item index
export let GuiListView(bounds: Rectangle, text: String, scrollIndex: Listed<Int>, active: Listed<Int>): Int {
    return rl.GuiListView(bounds, text, scrollIndex, active);
}
// List View with extended parameters
export let GuiListViewEx(bounds: Rectangle, text: Listed<String>, count: Int, scrollIndex: Listed<Int>, active: Listed<Int>, focus: Listed<Int>): Int {
    return rl.GuiListViewEx(bounds, text, count, scrollIndex, active, focus);
}
// Message Box control, displays a message
export let GuiMessageBox(bounds: Rectangle, title: String, message: String, buttons: String): Int {
    return rl.GuiMessageBox(bounds, title, message, buttons);
}
// Text Input Box control, ask for text, supports secret
export let GuiTextInputBox(bounds: Rectangle, title: String, message: String, buttons: String, text: String, textMaxSize: Int, secretViewActive: Listed<Boolean>): Int {
    return rl.GuiTextInputBox(bounds, title, message, buttons, text, textMaxSize, secretViewActive);
}
// Color Picker control (multiple color controls)
export let GuiColorPicker(bounds: Rectangle, text: String, color: Listed<Color>): Int {
    return rl.GuiColorPicker(bounds, text, color);
}
// Color Panel control
export let GuiColorPanel(bounds: Rectangle, text: String, color: Listed<Color>): Int {
    return rl.GuiColorPanel(bounds, text, color);
}
// Color Bar Alpha control
export let GuiColorBarAlpha(bounds: Rectangle, text: String, alpha: Listed<Float64>): Int {
    return rl.GuiColorBarAlpha(bounds, text, alpha);
}
// Color Bar Hue control
export let GuiColorBarHue(bounds: Rectangle, text: String, value: Listed<Float64>): Int {
    return rl.GuiColorBarHue(bounds, text, value);
}
// Color Picker control that avoids conversion to RGB on each call (multiple color controls)
export let GuiColorPickerHSV(bounds: Rectangle, text: String, colorHsv: Listed<Vector3>): Int {
    return rl.GuiColorPickerHSV(bounds, text, colorHsv);
}
// Color Panel control that returns HSV color value, used by GuiColorPickerHSV()
export let GuiColorPanelHSV(bounds: Rectangle, text: String, colorHsv: Listed<Vector3>): Int {
    return rl.GuiColorPanelHSV(bounds, text, colorHsv);
}
// Initialize window and OpenGL context
export let InitWindow(width: Int, height: Int, title: String): Void {
    rl.InitWindow(width, height, title);
}
// Close window and unload OpenGL context
export let CloseWindow(): Void {
    rl.CloseWindow();
}
// Check if application should close (KEY_ESCAPE pressed or windows close icon clicked)
export let WindowShouldClose(): Boolean {
    return rl.WindowShouldClose();
}
// Check if window has been initialized successfully
export let IsWindowReady(): Boolean {
    return rl.IsWindowReady();
}
// Check if window is currently fullscreen
export let IsWindowFullscreen(): Boolean {
    return rl.IsWindowFullscreen();
}
// Check if window is currently hidden (only PLATFORM_DESKTOP)
export let IsWindowHidden(): Boolean {
    return rl.IsWindowHidden();
}
// Check if window is currently minimized (only PLATFORM_DESKTOP)
export let IsWindowMinimized(): Boolean {
    return rl.IsWindowMinimized();
}
// Check if window is currently maximized (only PLATFORM_DESKTOP)
export let IsWindowMaximized(): Boolean {
    return rl.IsWindowMaximized();
}
// Check if window is currently focused (only PLATFORM_DESKTOP)
export let IsWindowFocused(): Boolean {
    return rl.IsWindowFocused();
}
// Check if window has been resized last frame
export let IsWindowResized(): Boolean {
    return rl.IsWindowResized();
}
// Check if one specific window flag is enabled
export let IsWindowState(flag: Int): Boolean {
    return rl.IsWindowState(flag);
}
// Set window configuration state using flags (only PLATFORM_DESKTOP)
export let SetWindowState(flags: Int): Void {
    rl.SetWindowState(flags);
}
// Clear window configuration state flags
export let ClearWindowState(flags: Int): Void {
    rl.ClearWindowState(flags);
}
// Toggle window state: fullscreen/windowed (only PLATFORM_DESKTOP)
export let ToggleFullscreen(): Void {
    rl.ToggleFullscreen();
}
// Toggle window state: borderless windowed (only PLATFORM_DESKTOP)
export let ToggleBorderlessWindowed(): Void {
    rl.ToggleBorderlessWindowed();
}
// Set window state: maximized, if resizable (only PLATFORM_DESKTOP)
export let MaximizeWindow(): Void {
    rl.MaximizeWindow();
}
// Set window state: minimized, if resizable (only PLATFORM_DESKTOP)
export let MinimizeWindow(): Void {
    rl.MinimizeWindow();
}
// Set window state: not minimized/maximized (only PLATFORM_DESKTOP)
export let RestoreWindow(): Void {
    rl.RestoreWindow();
}
// Set icon for window (single image, RGBA 32bit, only PLATFORM_DESKTOP)
export let SetWindowIcon(image: Image): Void {
    rl.SetWindowIcon(image);
}
// Set icon for window (multiple images, RGBA 32bit, only PLATFORM_DESKTOP)
export let SetWindowIcons(images: Listed<Image>, count: Int): Void {
    rl.SetWindowIcons(images, count);
}
// Set title for window (only PLATFORM_DESKTOP and PLATFORM_WEB)
export let SetWindowTitle(title: String): Void {
    rl.SetWindowTitle(title);
}
// Set window position on screen (only PLATFORM_DESKTOP)
export let SetWindowPosition(x: Int, y: Int): Void {
    rl.SetWindowPosition(x, y);
}
// Set monitor for the current window
export let SetWindowMonitor(monitor: Int): Void {
    rl.SetWindowMonitor(monitor);
}
// Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)
export let SetWindowMinSize(width: Int, height: Int): Void {
    rl.SetWindowMinSize(width, height);
}
// Set window maximum dimensions (for FLAG_WINDOW_RESIZABLE)
export let SetWindowMaxSize(width: Int, height: Int): Void {
    rl.SetWindowMaxSize(width, height);
}
// Set window dimensions
export let SetWindowSize(width: Int, height: Int): Void {
    rl.SetWindowSize(width, height);
}
// Set window opacity [0.0f..1.0f] (only PLATFORM_DESKTOP)
export let SetWindowOpacity(opacity: Float64): Void {
    rl.SetWindowOpacity(opacity);
}
// Set window focused (only PLATFORM_DESKTOP)
export let SetWindowFocused(): Void {
    rl.SetWindowFocused();
}
// Get native window handle
export let GetWindowHandle(): DenseBitVector {
    return rl.GetWindowHandle();
}
// Get current screen width
export let GetScreenWidth(): Int {
    return rl.GetScreenWidth();
}
// Get current screen height
export let GetScreenHeight(): Int {
    return rl.GetScreenHeight();
}
// Get current render width (it considers HiDPI)
export let GetRenderWidth(): Int {
    return rl.GetRenderWidth();
}
// Get current render height (it considers HiDPI)
export let GetRenderHeight(): Int {
    return rl.GetRenderHeight();
}
// Get number of connected monitors
export let GetMonitorCount(): Int {
    return rl.GetMonitorCount();
}
// Get current connected monitor
export let GetCurrentMonitor(): Int {
    return rl.GetCurrentMonitor();
}
// Get specified monitor position
export let GetMonitorPosition(monitor: Int): Vector2 {
    return rl.GetMonitorPosition(monitor);
}
// Get specified monitor width (current video mode used by monitor)
export let GetMonitorWidth(monitor: Int): Int {
    return rl.GetMonitorWidth(monitor);
}
// Get specified monitor height (current video mode used by monitor)
export let GetMonitorHeight(monitor: Int): Int {
    return rl.GetMonitorHeight(monitor);
}
// Get specified monitor physical width in millimetres
export let GetMonitorPhysicalWidth(monitor: Int): Int {
    return rl.GetMonitorPhysicalWidth(monitor);
}
// Get specified monitor physical height in millimetres
export let GetMonitorPhysicalHeight(monitor: Int): Int {
    return rl.GetMonitorPhysicalHeight(monitor);
}
// Get specified monitor refresh rate
export let GetMonitorRefreshRate(monitor: Int): Int {
    return rl.GetMonitorRefreshRate(monitor);
}
// Get window position XY on monitor
export let GetWindowPosition(): Vector2 {
    return rl.GetWindowPosition();
}
// Get window scale DPI factor
export let GetWindowScaleDPI(): Vector2 {
    return rl.GetWindowScaleDPI();
}
// Get the human-readable, UTF-8 encoded name of the specified monitor
export let GetMonitorName(monitor: Int): String {
    return rl.GetMonitorName(monitor);
}
// Set clipboard text content
export let SetClipboardText(text: String): Void {
    rl.SetClipboardText(text);
}
// Get clipboard text content
export let GetClipboardText(): String {
    return rl.GetClipboardText();
}
// Enable waiting for events on EndDrawing(), no automatic event polling
export let EnableEventWaiting(): Void {
    rl.EnableEventWaiting();
}
// Disable waiting for events on EndDrawing(), automatic events polling
export let DisableEventWaiting(): Void {
    rl.DisableEventWaiting();
}
// Shows cursor
export let ShowCursor(): Void {
    rl.ShowCursor();
}
// Hides cursor
export let HideCursor(): Void {
    rl.HideCursor();
}
// Check if cursor is not visible
export let IsCursorHidden(): Boolean {
    return rl.IsCursorHidden();
}
// Enables cursor (unlock cursor)
export let EnableCursor(): Void {
    rl.EnableCursor();
}
// Disables cursor (lock cursor)
export let DisableCursor(): Void {
    rl.DisableCursor();
}
// Check if cursor is on the screen
export let IsCursorOnScreen(): Boolean {
    return rl.IsCursorOnScreen();
}
// Set background color (framebuffer clear color)
export let ClearBackground(color: Color): Void {
    rl.ClearBackground(color);
}
// Setup canvas (framebuffer) to start drawing
export let BeginDrawing(): Void {
    rl.BeginDrawing();
}
// End canvas drawing and swap buffers (double buffering)
export let EndDrawing(): Void {
    rl.EndDrawing();
}
// Begin 2D mode with custom camera (2D)
export let BeginMode2D(camera: Camera2D): Void {
    rl.BeginMode2D(camera);
}
// Ends 2D mode with custom camera
export let EndMode2D(): Void {
    rl.EndMode2D();
}
// Begin 3D mode with custom camera (3D)
export let BeginMode3D(camera: Camera3D): Void {
    rl.BeginMode3D(camera);
}
// Ends 3D mode and returns to default 2D orthographic mode
export let EndMode3D(): Void {
    rl.EndMode3D();
}
// Begin drawing to render texture
export let BeginTextureMode(target: RenderTexture2D): Void {
    rl.BeginTextureMode(target);
}
// Ends drawing to render texture
export let EndTextureMode(): Void {
    rl.EndTextureMode();
}
// Begin custom shader drawing
export let BeginShaderMode(shader: Shader): Void {
    rl.BeginShaderMode(shader);
}
// End custom shader drawing (use default shader)
export let EndShaderMode(): Void {
    rl.EndShaderMode();
}
// Begin blending mode (alpha, additive, multiplied, subtract, custom)
export let BeginBlendMode(mode: Int): Void {
    rl.BeginBlendMode(mode);
}
// End blending mode (reset to default: alpha blending)
export let EndBlendMode(): Void {
    rl.EndBlendMode();
}
// Begin scissor mode (define screen area for following drawing)
export let BeginScissorMode(x: Int, y: Int, width: Int, height: Int): Void {
    rl.BeginScissorMode(x, y, width, height);
}
// End scissor mode
export let EndScissorMode(): Void {
    rl.EndScissorMode();
}
// Begin stereo rendering (requires VR simulator)
export let BeginVrStereoMode(config: VrStereoConfig): Void {
    rl.BeginVrStereoMode(config);
}
// End stereo rendering (requires VR simulator)
export let EndVrStereoMode(): Void {
    rl.EndVrStereoMode();
}
// Load VR stereo config for VR simulator device parameters
export let LoadVrStereoConfig(device: VrDeviceInfo): VrStereoConfig {
    return rl.LoadVrStereoConfig(device);
}
// Unload VR stereo config
export let UnloadVrStereoConfig(config: VrStereoConfig): Void {
    rl.UnloadVrStereoConfig(config);
}
// Load shader from files and bind default locations
export let LoadShader(vsFileName: String, fsFileName: String): Shader {
    return rl.LoadShader(vsFileName, fsFileName);
}
// Load shader from code strings and bind default locations
export let LoadShaderFromMemory(vsCode: String, fsCode: String): Shader {
    return rl.LoadShaderFromMemory(vsCode, fsCode);
}
// Check if a shader is ready
export let IsShaderReady(shader: Shader): Boolean {
    return rl.IsShaderReady(shader);
}
// Get shader uniform location
export let GetShaderLocation(shader: Shader, uniformName: String): Int {
    return rl.GetShaderLocation(shader, uniformName);
}
// Get shader attribute location
export let GetShaderLocationAttrib(shader: Shader, attribName: String): Int {
    return rl.GetShaderLocationAttrib(shader, attribName);
}
// Set shader uniform value
export let SetShaderValue(shader: Shader, locIndex: Int, value: DenseBitVector, uniformType: Int): Void {
    rl.SetShaderValue(shader, locIndex, value, uniformType);
}
// Set shader uniform value vector
export let SetShaderValueV(shader: Shader, locIndex: Int, value: DenseBitVector, uniformType: Int, count: Int): Void {
    rl.SetShaderValueV(shader, locIndex, value, uniformType, count);
}
// Set shader uniform value (matrix 4x4)
export let SetShaderValueMatrix(shader: Shader, locIndex: Int, mat: Matrix): Void {
    rl.SetShaderValueMatrix(shader, locIndex, mat);
}
// Set shader uniform value for texture (sampler2d)
export let SetShaderValueTexture(shader: Shader, locIndex: Int, texture: Texture2D): Void {
    rl.SetShaderValueTexture(shader, locIndex, texture);
}
// Unload shader from GPU memory (VRAM)
export let UnloadShader(shader: Shader): Void {
    rl.UnloadShader(shader);
}
// Get a ray trace from mouse position
export let GetMouseRay(mousePosition: Vector2, camera: Camera): Ray {
    return rl.GetMouseRay(mousePosition, camera);
}
// Get camera transform matrix (view matrix)
export let GetCameraMatrix(camera: Camera): Matrix {
    return rl.GetCameraMatrix(camera);
}
// Get camera 2d transform matrix
export let GetCameraMatrix2D(camera: Camera2D): Matrix {
    return rl.GetCameraMatrix2D(camera);
}
// Get the screen space position for a 3d world space position
export let GetWorldToScreen(position: Vector3, camera: Camera): Vector2 {
    return rl.GetWorldToScreen(position, camera);
}
// Get the world space position for a 2d camera screen space position
export let GetScreenToWorld2D(position: Vector2, camera: Camera2D): Vector2 {
    return rl.GetScreenToWorld2D(position, camera);
}
// Get size position for a 3d world space position
export let GetWorldToScreenEx(position: Vector3, camera: Camera, width: Int, height: Int): Vector2 {
    return rl.GetWorldToScreenEx(position, camera, width, height);
}
// Get the screen space position for a 2d camera world space position
export let GetWorldToScreen2D(position: Vector2, camera: Camera2D): Vector2 {
    return rl.GetWorldToScreen2D(position, camera);
}
// Set target FPS (maximum)
export let SetTargetFPS(fps: Int): Void {
    rl.SetTargetFPS(fps);
}
// Get time in seconds for last frame drawn (delta time)
export let GetFrameTime(): Float64 {
    return rl.GetFrameTime();
}
// Get elapsed time in seconds since InitWindow()
export let GetTime(): Float64 {
    return rl.GetTime();
}
// Get current FPS
export let GetFPS(): Int {
    return rl.GetFPS();
}
// Swap back buffer with front buffer (screen drawing)
export let SwapScreenBuffer(): Void {
    rl.SwapScreenBuffer();
}
// Register all input events
export let PollInputEvents(): Void {
    rl.PollInputEvents();
}
// Wait for some time (halt program execution)
export let WaitTime(seconds: Float64): Void {
    rl.WaitTime(seconds);
}
// Set the seed for the random number generator
export let SetRandomSeed(seed: Int): Void {
    rl.SetRandomSeed(seed);
}
// Get a random value between min and max (both included)
export let GetRandomValue(min: Int, max: Int): Int {
    return rl.GetRandomValue(min, max);
}
// Load random values sequence, no values repeated
export let LoadRandomSequence(count: Int, min: Int, max: Int): Listed<Int> {
    return rl.LoadRandomSequence(count, min, max);
}
// Unload random values sequence
export let UnloadRandomSequence(sequence: Listed<Int>): Void {
    rl.UnloadRandomSequence(sequence);
}
// Takes a screenshot of current screen (filename extension defines format)
export let TakeScreenshot(fileName: String): Void {
    rl.TakeScreenshot(fileName);
}
// Setup init configuration flags (view FLAGS)
export let SetConfigFlags(flags: Int): Void {
    rl.SetConfigFlags(flags);
}
// Open URL with default system browser (if available)
export let OpenURL(url: String): Void {
    rl.OpenURL(url);
}
// Set the current threshold (minimum) log level
export let SetTraceLogLevel(logLevel: Int): Void {
    rl.SetTraceLogLevel(logLevel);
}
// Internal memory allocator
export let MemAlloc(size: Int): DenseBitVector {
    return rl.MemAlloc(size);
}
// Internal memory reallocator
export let MemRealloc(ptr: DenseBitVector, size: Int): DenseBitVector {
    return rl.MemRealloc(ptr, size);
}
// Internal memory free
export let MemFree(ptr: DenseBitVector): Void {
    rl.MemFree(ptr);
}
// Load file data as byte array (read)
export let LoadFileData(fileName: String, dataSize: Listed<Int>): Listed<Int> {
    return rl.LoadFileData(fileName, dataSize);
}
// Unload file data allocated by LoadFileData()
export let UnloadFileData(data: Listed<Int>): Void {
    rl.UnloadFileData(data);
}
// Save data to file from byte array (write), returns true on success
export let SaveFileData(fileName: String, data: DenseBitVector, dataSize: Int): Boolean {
    return rl.SaveFileData(fileName, data, dataSize);
}
// Export data to code (.h), returns true on success
export let ExportDataAsCode(data: Listed<Int>, dataSize: Int, fileName: String): Boolean {
    return rl.ExportDataAsCode(data, dataSize, fileName);
}
// Load text data from file (read), returns a '\0' terminated string
export let LoadFileText(fileName: String): String {
    return rl.LoadFileText(fileName);
}
// Unload file text data allocated by LoadFileText()
export let UnloadFileText(text: String): Void {
    rl.UnloadFileText(text);
}
// Save text data to file (write), string must be '\0' terminated, returns true on success
export let SaveFileText(fileName: String, text: String): Boolean {
    return rl.SaveFileText(fileName, text);
}
// Check if file exists
export let FileExists(fileName: String): Boolean {
    return rl.FileExists(fileName);
}
// Check if a directory path exists
export let DirectoryExists(dirPath: String): Boolean {
    return rl.DirectoryExists(dirPath);
}
// Check file extension (including point: .png, .wav)
export let IsFileExtension(fileName: String, ext: String): Boolean {
    return rl.IsFileExtension(fileName, ext);
}
// Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)
export let GetFileLength(fileName: String): Int {
    return rl.GetFileLength(fileName);
}
// Get pointer to extension for a filename string (includes dot: '.png')
export let GetFileExtension(fileName: String): String {
    return rl.GetFileExtension(fileName);
}
// Get pointer to filename for a path string
export let GetFileName(filePath: String): String {
    return rl.GetFileName(filePath);
}
// Get filename string without extension (uses static string)
export let GetFileNameWithoutExt(filePath: String): String {
    return rl.GetFileNameWithoutExt(filePath);
}
// Get full path for a given fileName with path (uses static string)
export let GetDirectoryPath(filePath: String): String {
    return rl.GetDirectoryPath(filePath);
}
// Get previous directory path for a given path (uses static string)
export let GetPrevDirectoryPath(dirPath: String): String {
    return rl.GetPrevDirectoryPath(dirPath);
}
// Get current working directory (uses static string)
export let GetWorkingDirectory(): String {
    return rl.GetWorkingDirectory();
}
// Get the directory of the running application (uses static string)
export let GetApplicationDirectory(): String {
    return rl.GetApplicationDirectory();
}
// Change working directory, return true on success
export let ChangeDirectory(dir: String): Boolean {
    return rl.ChangeDirectory(dir);
}
// Check if a given path is a file or a directory
export let IsPathFile(path: String): Boolean {
    return rl.IsPathFile(path);
}
// Load directory filepaths
export let LoadDirectoryFiles(dirPath: String): FilePathList {
    return rl.LoadDirectoryFiles(dirPath);
}
// Load directory filepaths with extension filtering and recursive directory scan
export let LoadDirectoryFilesEx(basePath: String, filter: String, scanSubdirs: Boolean): FilePathList {
    return rl.LoadDirectoryFilesEx(basePath, filter, scanSubdirs);
}
// Unload filepaths
export let UnloadDirectoryFiles(files: FilePathList): Void {
    rl.UnloadDirectoryFiles(files);
}
// Check if a file has been dropped into window
export let IsFileDropped(): Boolean {
    return rl.IsFileDropped();
}
// Load dropped filepaths
export let LoadDroppedFiles(): FilePathList {
    return rl.LoadDroppedFiles();
}
// Unload dropped filepaths
export let UnloadDroppedFiles(files: FilePathList): Void {
    rl.UnloadDroppedFiles(files);
}
// Get file modification time (last write time)
export let GetFileModTime(fileName: String): Int {
    return rl.GetFileModTime(fileName);
}
// Compress data (DEFLATE algorithm), memory must be MemFree()
export let CompressData(data: Listed<Int>, dataSize: Int, compDataSize: Listed<Int>): Listed<Int> {
    return rl.CompressData(data, dataSize, compDataSize);
}
// Decompress data (DEFLATE algorithm), memory must be MemFree()
export let DecompressData(compData: Listed<Int>, compDataSize: Int, dataSize: Listed<Int>): Listed<Int> {
    return rl.DecompressData(compData, compDataSize, dataSize);
}
// Encode data to Base64 string, memory must be MemFree()
export let EncodeDataBase64(data: Listed<Int>, dataSize: Int, outputSize: Listed<Int>): String {
    return rl.EncodeDataBase64(data, dataSize, outputSize);
}
// Decode Base64 string data, memory must be MemFree()
export let DecodeDataBase64(data: Listed<Int>, outputSize: Listed<Int>): Listed<Int> {
    return rl.DecodeDataBase64(data, outputSize);
}
// Load automation events list from file, NULL for empty list, capacity = MAX_AUTOMATION_EVENTS
export let LoadAutomationEventList(fileName: String): AutomationEventList {
    return rl.LoadAutomationEventList(fileName);
}
// Unload automation events list from file
export let UnloadAutomationEventList(list: AutomationEventList): Void {
    rl.UnloadAutomationEventList(list);
}
// Export automation events list as text file
export let ExportAutomationEventList(list: AutomationEventList, fileName: String): Boolean {
    return rl.ExportAutomationEventList(list, fileName);
}
// Set automation event list to record to
export let SetAutomationEventList(list: Listed<AutomationEventList>): Void {
    rl.SetAutomationEventList(list);
}
// Set automation event internal base frame to start recording
export let SetAutomationEventBaseFrame(frame: Int): Void {
    rl.SetAutomationEventBaseFrame(frame);
}
// Start recording automation events (AutomationEventList must be set)
export let StartAutomationEventRecording(): Void {
    rl.StartAutomationEventRecording();
}
// Stop recording automation events
export let StopAutomationEventRecording(): Void {
    rl.StopAutomationEventRecording();
}
// Play a recorded automation event
export let PlayAutomationEvent(event: AutomationEvent): Void {
    rl.PlayAutomationEvent(event);
}
// Check if a key has been pressed once
export let IsKeyPressed(key: Int): Boolean {
    return rl.IsKeyPressed(key);
}
// Check if a key has been pressed again (Only PLATFORM_DESKTOP)
export let IsKeyPressedRepeat(key: Int): Boolean {
    return rl.IsKeyPressedRepeat(key);
}
// Check if a key is being pressed
export let IsKeyDown(key: Int): Boolean {
    return rl.IsKeyDown(key);
}
// Check if a key has been released once
export let IsKeyReleased(key: Int): Boolean {
    return rl.IsKeyReleased(key);
}
// Check if a key is NOT being pressed
export let IsKeyUp(key: Int): Boolean {
    return rl.IsKeyUp(key);
}
// Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty
export let GetKeyPressed(): Int {
    return rl.GetKeyPressed();
}
// Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty
export let GetCharPressed(): Int {
    return rl.GetCharPressed();
}
// Set a custom key to exit program (default is ESC)
export let SetExitKey(key: Int): Void {
    rl.SetExitKey(key);
}
// Check if a gamepad is available
export let IsGamepadAvailable(gamepad: Int): Boolean {
    return rl.IsGamepadAvailable(gamepad);
}
// Get gamepad internal name id
export let GetGamepadName(gamepad: Int): String {
    return rl.GetGamepadName(gamepad);
}
// Check if a gamepad button has been pressed once
export let IsGamepadButtonPressed(gamepad: Int, button: Int): Boolean {
    return rl.IsGamepadButtonPressed(gamepad, button);
}
// Check if a gamepad button is being pressed
export let IsGamepadButtonDown(gamepad: Int, button: Int): Boolean {
    return rl.IsGamepadButtonDown(gamepad, button);
}
// Check if a gamepad button has been released once
export let IsGamepadButtonReleased(gamepad: Int, button: Int): Boolean {
    return rl.IsGamepadButtonReleased(gamepad, button);
}
// Check if a gamepad button is NOT being pressed
export let IsGamepadButtonUp(gamepad: Int, button: Int): Boolean {
    return rl.IsGamepadButtonUp(gamepad, button);
}
// Get the last gamepad button pressed
export let GetGamepadButtonPressed(): Int {
    return rl.GetGamepadButtonPressed();
}
// Get gamepad axis count for a gamepad
export let GetGamepadAxisCount(gamepad: Int): Int {
    return rl.GetGamepadAxisCount(gamepad);
}
// Get axis movement value for a gamepad axis
export let GetGamepadAxisMovement(gamepad: Int, axis: Int): Float64 {
    return rl.GetGamepadAxisMovement(gamepad, axis);
}
// Set internal gamepad mappings (SDL_GameControllerDB)
export let SetGamepadMappings(mappings: String): Int {
    return rl.SetGamepadMappings(mappings);
}
// Check if a mouse button has been pressed once
export let IsMouseButtonPressed(button: Int): Boolean {
    return rl.IsMouseButtonPressed(button);
}
// Check if a mouse button is being pressed
export let IsMouseButtonDown(button: Int): Boolean {
    return rl.IsMouseButtonDown(button);
}
// Check if a mouse button has been released once
export let IsMouseButtonReleased(button: Int): Boolean {
    return rl.IsMouseButtonReleased(button);
}
// Check if a mouse button is NOT being pressed
export let IsMouseButtonUp(button: Int): Boolean {
    return rl.IsMouseButtonUp(button);
}
// Get mouse position X
export let GetMouseX(): Int {
    return rl.GetMouseX();
}
// Get mouse position Y
export let GetMouseY(): Int {
    return rl.GetMouseY();
}
// Get mouse position XY
export let GetMousePosition(): Vector2 {
    return rl.GetMousePosition();
}
// Get mouse delta between frames
export let GetMouseDelta(): Vector2 {
    return rl.GetMouseDelta();
}
// Set mouse position XY
export let SetMousePosition(x: Int, y: Int): Void {
    rl.SetMousePosition(x, y);
}
// Set mouse offset
export let SetMouseOffset(offsetX: Int, offsetY: Int): Void {
    rl.SetMouseOffset(offsetX, offsetY);
}
// Set mouse scaling
export let SetMouseScale(scaleX: Float64, scaleY: Float64): Void {
    rl.SetMouseScale(scaleX, scaleY);
}
// Get mouse wheel movement for X or Y, whichever is larger
export let GetMouseWheelMove(): Float64 {
    return rl.GetMouseWheelMove();
}
// Get mouse wheel movement for both X and Y
export let GetMouseWheelMoveV(): Vector2 {
    return rl.GetMouseWheelMoveV();
}
// Set mouse cursor
export let SetMouseCursor(cursor: Int): Void {
    rl.SetMouseCursor(cursor);
}
// Get touch position X for touch point 0 (relative to screen size)
export let GetTouchX(): Int {
    return rl.GetTouchX();
}
// Get touch position Y for touch point 0 (relative to screen size)
export let GetTouchY(): Int {
    return rl.GetTouchY();
}
// Get touch position XY for a touch point index (relative to screen size)
export let GetTouchPosition(index: Int): Vector2 {
    return rl.GetTouchPosition(index);
}
// Get touch point identifier for given index
export let GetTouchPointId(index: Int): Int {
    return rl.GetTouchPointId(index);
}
// Get number of touch points
export let GetTouchPointCount(): Int {
    return rl.GetTouchPointCount();
}
// Enable a set of gestures using flags
export let SetGesturesEnabled(flags: Int): Void {
    rl.SetGesturesEnabled(flags);
}
// Check if a gesture have been detected
export let IsGestureDetected(gesture: Int): Boolean {
    return rl.IsGestureDetected(gesture);
}
// Get latest detected gesture
export let GetGestureDetected(): Int {
    return rl.GetGestureDetected();
}
// Get gesture hold time in milliseconds
export let GetGestureHoldDuration(): Float64 {
    return rl.GetGestureHoldDuration();
}
// Get gesture drag vector
export let GetGestureDragVector(): Vector2 {
    return rl.GetGestureDragVector();
}
// Get gesture drag angle
export let GetGestureDragAngle(): Float64 {
    return rl.GetGestureDragAngle();
}
// Get gesture pinch delta
export let GetGesturePinchVector(): Vector2 {
    return rl.GetGesturePinchVector();
}
// Get gesture pinch angle
export let GetGesturePinchAngle(): Float64 {
    return rl.GetGesturePinchAngle();
}
// Update camera position for selected mode
export let UpdateCamera(camera: Listed<Camera>, mode: Int): Void {
    rl.UpdateCamera(camera, mode);
}
// Update camera movement/rotation
export let UpdateCameraPro(camera: Listed<Camera>, movement: Vector3, rotation: Vector3, zoom: Float64): Void {
    rl.UpdateCameraPro(camera, movement, rotation, zoom);
}
// Set texture and rectangle to be used on shapes drawing
export let SetShapesTexture(texture: Texture2D, source: Rectangle): Void {
    rl.SetShapesTexture(texture, source);
}
// Get texture that is used for shapes drawing
export let GetShapesTexture(): Texture2D {
    return rl.GetShapesTexture();
}
// Get texture source rectangle that is used for shapes drawing
export let GetShapesTextureRectangle(): Rectangle {
    return rl.GetShapesTextureRectangle();
}
// Draw a pixel
export let DrawPixel(posX: Int, posY: Int, color: Color): Void {
    rl.DrawPixel(posX, posY, color);
}
// Draw a pixel (Vector version)
export let DrawPixelV(position: Vector2, color: Color): Void {
    rl.DrawPixelV(position, color);
}
// Draw a line
export let DrawLine(startPosX: Int, startPosY: Int, endPosX: Int, endPosY: Int, color: Color): Void {
    rl.DrawLine(startPosX, startPosY, endPosX, endPosY, color);
}
// Draw a line (using gl lines)
export let DrawLineV(startPos: Vector2, endPos: Vector2, color: Color): Void {
    rl.DrawLineV(startPos, endPos, color);
}
// Draw a line (using triangles/quads)
export let DrawLineEx(startPos: Vector2, endPos: Vector2, thick: Float64, color: Color): Void {
    rl.DrawLineEx(startPos, endPos, thick, color);
}
// Draw lines sequence (using gl lines)
export let DrawLineStrip(points: Listed<Vector2>, pointCount: Int, color: Color): Void {
    rl.DrawLineStrip(points, pointCount, color);
}
// Draw line segment cubic-bezier in-out interpolation
export let DrawLineBezier(startPos: Vector2, endPos: Vector2, thick: Float64, color: Color): Void {
    rl.DrawLineBezier(startPos, endPos, thick, color);
}
// Draw a color-filled circle
export let DrawCircle(centerX: Int, centerY: Int, radius: Float64, color: Color): Void {
    rl.DrawCircle(centerX, centerY, radius, color);
}
// Draw a piece of a circle
export let DrawCircleSector(center: Vector2, radius: Float64, startAngle: Float64, endAngle: Float64, segments: Int, color: Color): Void {
    rl.DrawCircleSector(center, radius, startAngle, endAngle, segments, color);
}
// Draw circle sector outline
export let DrawCircleSectorLines(center: Vector2, radius: Float64, startAngle: Float64, endAngle: Float64, segments: Int, color: Color): Void {
    rl.DrawCircleSectorLines(center, radius, startAngle, endAngle, segments, color);
}
// Draw a gradient-filled circle
export let DrawCircleGradient(centerX: Int, centerY: Int, radius: Float64, color1: Color, color2: Color): Void {
    rl.DrawCircleGradient(centerX, centerY, radius, color1, color2);
}
// Draw a color-filled circle (Vector version)
export let DrawCircleV(center: Vector2, radius: Float64, color: Color): Void {
    rl.DrawCircleV(center, radius, color);
}
// Draw circle outline
export let DrawCircleLines(centerX: Int, centerY: Int, radius: Float64, color: Color): Void {
    rl.DrawCircleLines(centerX, centerY, radius, color);
}
// Draw circle outline (Vector version)
export let DrawCircleLinesV(center: Vector2, radius: Float64, color: Color): Void {
    rl.DrawCircleLinesV(center, radius, color);
}
// Draw ellipse
export let DrawEllipse(centerX: Int, centerY: Int, radiusH: Float64, radiusV: Float64, color: Color): Void {
    rl.DrawEllipse(centerX, centerY, radiusH, radiusV, color);
}
// Draw ellipse outline
export let DrawEllipseLines(centerX: Int, centerY: Int, radiusH: Float64, radiusV: Float64, color: Color): Void {
    rl.DrawEllipseLines(centerX, centerY, radiusH, radiusV, color);
}
// Draw ring
export let DrawRing(center: Vector2, innerRadius: Float64, outerRadius: Float64, startAngle: Float64, endAngle: Float64, segments: Int, color: Color): Void {
    rl.DrawRing(center, innerRadius, outerRadius, startAngle, endAngle, segments, color);
}
// Draw ring outline
export let DrawRingLines(center: Vector2, innerRadius: Float64, outerRadius: Float64, startAngle: Float64, endAngle: Float64, segments: Int, color: Color): Void {
    rl.DrawRingLines(center, innerRadius, outerRadius, startAngle, endAngle, segments, color);
}
// Draw a color-filled rectangle
export let DrawRectangle(posX: Int, posY: Int, width: Int, height: Int, color: Color): Void {
    rl.DrawRectangle(posX, posY, width, height, color);
}
// Draw a color-filled rectangle (Vector version)
export let DrawRectangleV(position: Vector2, size: Vector2, color: Color): Void {
    rl.DrawRectangleV(position, size, color);
}
// Draw a color-filled rectangle
export let DrawRectangleRec(rec: Rectangle, color: Color): Void {
    rl.DrawRectangleRec(rec, color);
}
// Draw a color-filled rectangle with pro parameters
export let DrawRectanglePro(rec: Rectangle, origin: Vector2, rotation: Float64, color: Color): Void {
    rl.DrawRectanglePro(rec, origin, rotation, color);
}
// Draw a vertical-gradient-filled rectangle
export let DrawRectangleGradientV(posX: Int, posY: Int, width: Int, height: Int, color1: Color, color2: Color): Void {
    rl.DrawRectangleGradientV(posX, posY, width, height, color1, color2);
}
// Draw a horizontal-gradient-filled rectangle
export let DrawRectangleGradientH(posX: Int, posY: Int, width: Int, height: Int, color1: Color, color2: Color): Void {
    rl.DrawRectangleGradientH(posX, posY, width, height, color1, color2);
}
// Draw a gradient-filled rectangle with custom vertex colors
export let DrawRectangleGradientEx(rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color): Void {
    rl.DrawRectangleGradientEx(rec, col1, col2, col3, col4);
}
// Draw rectangle outline
export let DrawRectangleLines(posX: Int, posY: Int, width: Int, height: Int, color: Color): Void {
    rl.DrawRectangleLines(posX, posY, width, height, color);
}
// Draw rectangle outline with extended parameters
export let DrawRectangleLinesEx(rec: Rectangle, lineThick: Float64, color: Color): Void {
    rl.DrawRectangleLinesEx(rec, lineThick, color);
}
// Draw rectangle with rounded edges
export let DrawRectangleRounded(rec: Rectangle, roundness: Float64, segments: Int, color: Color): Void {
    rl.DrawRectangleRounded(rec, roundness, segments, color);
}
// Draw rectangle with rounded edges outline
export let DrawRectangleRoundedLines(rec: Rectangle, roundness: Float64, segments: Int, lineThick: Float64, color: Color): Void {
    rl.DrawRectangleRoundedLines(rec, roundness, segments, lineThick, color);
}
// Draw a color-filled triangle (vertex in counter-clockwise order!)
export let DrawTriangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color): Void {
    rl.DrawTriangle(v1, v2, v3, color);
}
// Draw triangle outline (vertex in counter-clockwise order!)
export let DrawTriangleLines(v1: Vector2, v2: Vector2, v3: Vector2, color: Color): Void {
    rl.DrawTriangleLines(v1, v2, v3, color);
}
// Draw a triangle fan defined by points (first vertex is the center)
export let DrawTriangleFan(points: Listed<Vector2>, pointCount: Int, color: Color): Void {
    rl.DrawTriangleFan(points, pointCount, color);
}
// Draw a triangle strip defined by points
export let DrawTriangleStrip(points: Listed<Vector2>, pointCount: Int, color: Color): Void {
    rl.DrawTriangleStrip(points, pointCount, color);
}
// Draw a regular polygon (Vector version)
export let DrawPoly(center: Vector2, sides: Int, radius: Float64, rotation: Float64, color: Color): Void {
    rl.DrawPoly(center, sides, radius, rotation, color);
}
// Draw a polygon outline of n sides
export let DrawPolyLines(center: Vector2, sides: Int, radius: Float64, rotation: Float64, color: Color): Void {
    rl.DrawPolyLines(center, sides, radius, rotation, color);
}
// Draw a polygon outline of n sides with extended parameters
export let DrawPolyLinesEx(center: Vector2, sides: Int, radius: Float64, rotation: Float64, lineThick: Float64, color: Color): Void {
    rl.DrawPolyLinesEx(center, sides, radius, rotation, lineThick, color);
}
// Draw spline: Linear, minimum 2 points
export let DrawSplineLinear(points: Listed<Vector2>, pointCount: Int, thick: Float64, color: Color): Void {
    rl.DrawSplineLinear(points, pointCount, thick, color);
}
// Draw spline: B-Spline, minimum 4 points
export let DrawSplineBasis(points: Listed<Vector2>, pointCount: Int, thick: Float64, color: Color): Void {
    rl.DrawSplineBasis(points, pointCount, thick, color);
}
// Draw spline: Catmull-Rom, minimum 4 points
export let DrawSplineCatmullRom(points: Listed<Vector2>, pointCount: Int, thick: Float64, color: Color): Void {
    rl.DrawSplineCatmullRom(points, pointCount, thick, color);
}
// Draw spline: Quadratic Bezier, minimum 3 points (1 control point): [p1, c2, p3, c4...]
export let DrawSplineBezierQuadratic(points: Listed<Vector2>, pointCount: Int, thick: Float64, color: Color): Void {
    rl.DrawSplineBezierQuadratic(points, pointCount, thick, color);
}
// Draw spline: Cubic Bezier, minimum 4 points (2 control points): [p1, c2, c3, p4, c5, c6...]
export let DrawSplineBezierCubic(points: Listed<Vector2>, pointCount: Int, thick: Float64, color: Color): Void {
    rl.DrawSplineBezierCubic(points, pointCount, thick, color);
}
// Draw spline segment: Linear, 2 points
export let DrawSplineSegmentLinear(p1: Vector2, p2: Vector2, thick: Float64, color: Color): Void {
    rl.DrawSplineSegmentLinear(p1, p2, thick, color);
}
// Draw spline segment: B-Spline, 4 points
export let DrawSplineSegmentBasis(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: Float64, color: Color): Void {
    rl.DrawSplineSegmentBasis(p1, p2, p3, p4, thick, color);
}
// Draw spline segment: Catmull-Rom, 4 points
export let DrawSplineSegmentCatmullRom(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: Float64, color: Color): Void {
    rl.DrawSplineSegmentCatmullRom(p1, p2, p3, p4, thick, color);
}
// Draw spline segment: Quadratic Bezier, 2 points, 1 control point
export let DrawSplineSegmentBezierQuadratic(p1: Vector2, c2: Vector2, p3: Vector2, thick: Float64, color: Color): Void {
    rl.DrawSplineSegmentBezierQuadratic(p1, c2, p3, thick, color);
}
// Draw spline segment: Cubic Bezier, 2 points, 2 control points
export let DrawSplineSegmentBezierCubic(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, thick: Float64, color: Color): Void {
    rl.DrawSplineSegmentBezierCubic(p1, c2, c3, p4, thick, color);
}
// Get (evaluate) spline point: Linear
export let GetSplinePointLinear(startPos: Vector2, endPos: Vector2, t: Float64): Vector2 {
    return rl.GetSplinePointLinear(startPos, endPos, t);
}
// Get (evaluate) spline point: B-Spline
export let GetSplinePointBasis(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: Float64): Vector2 {
    return rl.GetSplinePointBasis(p1, p2, p3, p4, t);
}
// Get (evaluate) spline point: Catmull-Rom
export let GetSplinePointCatmullRom(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: Float64): Vector2 {
    return rl.GetSplinePointCatmullRom(p1, p2, p3, p4, t);
}
// Get (evaluate) spline point: Quadratic Bezier
export let GetSplinePointBezierQuad(p1: Vector2, c2: Vector2, p3: Vector2, t: Float64): Vector2 {
    return rl.GetSplinePointBezierQuad(p1, c2, p3, t);
}
// Get (evaluate) spline point: Cubic Bezier
export let GetSplinePointBezierCubic(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, t: Float64): Vector2 {
    return rl.GetSplinePointBezierCubic(p1, c2, c3, p4, t);
}
// Check collision between two rectangles
export let CheckCollisionRecs(rec1: Rectangle, rec2: Rectangle): Boolean {
    return rl.CheckCollisionRecs(rec1, rec2);
}
// Check collision between two circles
export let CheckCollisionCircles(center1: Vector2, radius1: Float64, center2: Vector2, radius2: Float64): Boolean {
    return rl.CheckCollisionCircles(center1, radius1, center2, radius2);
}
// Check collision between circle and rectangle
export let CheckCollisionCircleRec(center: Vector2, radius: Float64, rec: Rectangle): Boolean {
    return rl.CheckCollisionCircleRec(center, radius, rec);
}
// Check if point is inside rectangle
export let CheckCollisionPointRec(point: Vector2, rec: Rectangle): Boolean {
    return rl.CheckCollisionPointRec(point, rec);
}
// Check if point is inside circle
export let CheckCollisionPointCircle(point: Vector2, center: Vector2, radius: Float64): Boolean {
    return rl.CheckCollisionPointCircle(point, center, radius);
}
// Check if point is inside a triangle
export let CheckCollisionPointTriangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2): Boolean {
    return rl.CheckCollisionPointTriangle(point, p1, p2, p3);
}
// Check if point is within a polygon described by array of vertices
export let CheckCollisionPointPoly(point: Vector2, points: Listed<Vector2>, pointCount: Int): Boolean {
    return rl.CheckCollisionPointPoly(point, points, pointCount);
}
// Check the collision between two lines defined by two points each, returns collision point by reference
export let CheckCollisionLines(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: Listed<Vector2>): Boolean {
    return rl.CheckCollisionLines(startPos1, endPos1, startPos2, endPos2, collisionPoint);
}
// Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]
export let CheckCollisionPointLine(point: Vector2, p1: Vector2, p2: Vector2, threshold: Int): Boolean {
    return rl.CheckCollisionPointLine(point, p1, p2, threshold);
}
// Get collision rectangle for two rectangles collision
export let GetCollisionRec(rec1: Rectangle, rec2: Rectangle): Rectangle {
    return rl.GetCollisionRec(rec1, rec2);
}
// Load image from file into CPU memory (RAM)
export let LoadImage(fileName: String): Image {
    return rl.LoadImage(fileName);
}
// Load image from RAW file data
export let LoadImageRaw(fileName: String, width: Int, height: Int, format: Int, headerSize: Int): Image {
    return rl.LoadImageRaw(fileName, width, height, format, headerSize);
}
// Load image from SVG file data or string with specified size
export let LoadImageSvg(fileNameOrString: String, width: Int, height: Int): Image {
    return rl.LoadImageSvg(fileNameOrString, width, height);
}
// Load image sequence from file (frames appended to image.data)
export let LoadImageAnim(fileName: String, frames: Listed<Int>): Image {
    return rl.LoadImageAnim(fileName, frames);
}
// Load image sequence from memory buffer
export let LoadImageAnimFromMemory(fileType: String, fileData: Listed<Int>, dataSize: Int, frames: Listed<Int>): Image {
    return rl.LoadImageAnimFromMemory(fileType, fileData, dataSize, frames);
}
// Load image from memory buffer, fileType refers to extension: i.e. '.png'
export let LoadImageFromMemory(fileType: String, fileData: Listed<Int>, dataSize: Int): Image {
    return rl.LoadImageFromMemory(fileType, fileData, dataSize);
}
// Load image from GPU texture data
export let LoadImageFromTexture(texture: Texture2D): Image {
    return rl.LoadImageFromTexture(texture);
}
// Load image from screen buffer and (screenshot)
export let LoadImageFromScreen(): Image {
    return rl.LoadImageFromScreen();
}
// Check if an image is ready
export let IsImageReady(image: Image): Boolean {
    return rl.IsImageReady(image);
}
// Unload image from CPU memory (RAM)
export let UnloadImage(image: Image): Void {
    rl.UnloadImage(image);
}
// Export image data to file, returns true on success
export let ExportImage(image: Image, fileName: String): Boolean {
    return rl.ExportImage(image, fileName);
}
// Export image to memory buffer
export let ExportImageToMemory(image: Image, fileType: String, fileSize: Listed<Int>): Listed<Int> {
    return rl.ExportImageToMemory(image, fileType, fileSize);
}
// Export image as code file defining an array of bytes, returns true on success
export let ExportImageAsCode(image: Image, fileName: String): Boolean {
    return rl.ExportImageAsCode(image, fileName);
}
// Generate image: plain color
export let GenImageColor(width: Int, height: Int, color: Color): Image {
    return rl.GenImageColor(width, height, color);
}
// Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient
export let GenImageGradientLinear(width: Int, height: Int, direction: Int, start: Color, end: Color): Image {
    return rl.GenImageGradientLinear(width, height, direction, start, end);
}
// Generate image: radial gradient
export let GenImageGradientRadial(width: Int, height: Int, density: Float64, inner: Color, outer: Color): Image {
    return rl.GenImageGradientRadial(width, height, density, inner, outer);
}
// Generate image: square gradient
export let GenImageGradientSquare(width: Int, height: Int, density: Float64, inner: Color, outer: Color): Image {
    return rl.GenImageGradientSquare(width, height, density, inner, outer);
}
// Generate image: checked
export let GenImageChecked(width: Int, height: Int, checksX: Int, checksY: Int, col1: Color, col2: Color): Image {
    return rl.GenImageChecked(width, height, checksX, checksY, col1, col2);
}
// Generate image: white noise
export let GenImageWhiteNoise(width: Int, height: Int, factor: Float64): Image {
    return rl.GenImageWhiteNoise(width, height, factor);
}
// Generate image: perlin noise
export let GenImagePerlinNoise(width: Int, height: Int, offsetX: Int, offsetY: Int, scale: Float64): Image {
    return rl.GenImagePerlinNoise(width, height, offsetX, offsetY, scale);
}
// Generate image: cellular algorithm, bigger tileSize means bigger cells
export let GenImageCellular(width: Int, height: Int, tileSize: Int): Image {
    return rl.GenImageCellular(width, height, tileSize);
}
// Generate image: grayscale image from text data
export let GenImageText(width: Int, height: Int, text: String): Image {
    return rl.GenImageText(width, height, text);
}
// Create an image duplicate (useful for transformations)
export let ImageCopy(image: Image): Image {
    return rl.ImageCopy(image);
}
// Create an image from another image piece
export let ImageFromImage(image: Image, rec: Rectangle): Image {
    return rl.ImageFromImage(image, rec);
}
// Create an image from text (default font)
export let ImageText(text: String, fontSize: Int, color: Color): Image {
    return rl.ImageText(text, fontSize, color);
}
// Create an image from text (custom sprite font)
export let ImageTextEx(font: Font, text: String, fontSize: Float64, spacing: Float64, tint: Color): Image {
    return rl.ImageTextEx(font, text, fontSize, spacing, tint);
}
// Convert image data to desired format
export let ImageFormat(image: Listed<Image>, newFormat: Int): Void {
    rl.ImageFormat(image, newFormat);
}
// Convert image to POT (power-of-two)
export let ImageToPOT(image: Listed<Image>, fill: Color): Void {
    rl.ImageToPOT(image, fill);
}
// Crop an image to a defined rectangle
export let ImageCrop(image: Listed<Image>, crop: Rectangle): Void {
    rl.ImageCrop(image, crop);
}
// Crop image depending on alpha value
export let ImageAlphaCrop(image: Listed<Image>, threshold: Float64): Void {
    rl.ImageAlphaCrop(image, threshold);
}
// Clear alpha channel to desired color
export let ImageAlphaClear(image: Listed<Image>, color: Color, threshold: Float64): Void {
    rl.ImageAlphaClear(image, color, threshold);
}
// Apply alpha mask to image
export let ImageAlphaMask(image: Listed<Image>, alphaMask: Image): Void {
    rl.ImageAlphaMask(image, alphaMask);
}
// Premultiply alpha channel
export let ImageAlphaPremultiply(image: Listed<Image>): Void {
    rl.ImageAlphaPremultiply(image);
}
// Apply Gaussian blur using a box blur approximation
export let ImageBlurGaussian(image: Listed<Image>, blurSize: Int): Void {
    rl.ImageBlurGaussian(image, blurSize);
}
// Apply Custom Square image convolution kernel
export let ImageKernelConvolution(image: Listed<Image>, kernel: Listed<Float64>, kernelSize: Int): Void {
    rl.ImageKernelConvolution(image, kernel, kernelSize);
}
// Resize image (Bicubic scaling algorithm)
export let ImageResize(image: Listed<Image>, newWidth: Int, newHeight: Int): Void {
    rl.ImageResize(image, newWidth, newHeight);
}
// Resize image (Nearest-Neighbor scaling algorithm)
export let ImageResizeNN(image: Listed<Image>, newWidth: Int, newHeight: Int): Void {
    rl.ImageResizeNN(image, newWidth, newHeight);
}
// Resize canvas and fill with color
export let ImageResizeCanvas(image: Listed<Image>, newWidth: Int, newHeight: Int, offsetX: Int, offsetY: Int, fill: Color): Void {
    rl.ImageResizeCanvas(image, newWidth, newHeight, offsetX, offsetY, fill);
}
// Compute all mipmap levels for a provided image
export let ImageMipmaps(image: Listed<Image>): Void {
    rl.ImageMipmaps(image);
}
// Dither image data to 16bpp or lower (Floyd-Steinberg dithering)
export let ImageDither(image: Listed<Image>, rBpp: Int, gBpp: Int, bBpp: Int, aBpp: Int): Void {
    rl.ImageDither(image, rBpp, gBpp, bBpp, aBpp);
}
// Flip image vertically
export let ImageFlipVertical(image: Listed<Image>): Void {
    rl.ImageFlipVertical(image);
}
// Flip image horizontally
export let ImageFlipHorizontal(image: Listed<Image>): Void {
    rl.ImageFlipHorizontal(image);
}
// Rotate image by input angle in degrees (-359 to 359)
export let ImageRotate(image: Listed<Image>, degrees: Int): Void {
    rl.ImageRotate(image, degrees);
}
// Rotate image clockwise 90deg
export let ImageRotateCW(image: Listed<Image>): Void {
    rl.ImageRotateCW(image);
}
// Rotate image counter-clockwise 90deg
export let ImageRotateCCW(image: Listed<Image>): Void {
    rl.ImageRotateCCW(image);
}
// Modify image color: tint
export let ImageColorTint(image: Listed<Image>, color: Color): Void {
    rl.ImageColorTint(image, color);
}
// Modify image color: invert
export let ImageColorInvert(image: Listed<Image>): Void {
    rl.ImageColorInvert(image);
}
// Modify image color: grayscale
export let ImageColorGrayscale(image: Listed<Image>): Void {
    rl.ImageColorGrayscale(image);
}
// Modify image color: contrast (-100 to 100)
export let ImageColorContrast(image: Listed<Image>, contrast: Float64): Void {
    rl.ImageColorContrast(image, contrast);
}
// Modify image color: brightness (-255 to 255)
export let ImageColorBrightness(image: Listed<Image>, brightness: Int): Void {
    rl.ImageColorBrightness(image, brightness);
}
// Modify image color: replace color
export let ImageColorReplace(image: Listed<Image>, color: Color, replace: Color): Void {
    rl.ImageColorReplace(image, color, replace);
}
// Load color data from image as a Color array (RGBA - 32bit)
export let LoadImageColors(image: Image): Listed<Color> {
    return rl.LoadImageColors(image);
}
// Load colors palette from image as a Color array (RGBA - 32bit)
export let LoadImagePalette(image: Image, maxPaletteSize: Int, colorCount: Listed<Int>): Listed<Color> {
    return rl.LoadImagePalette(image, maxPaletteSize, colorCount);
}
// Unload color data loaded with LoadImageColors()
export let UnloadImageColors(colors: Listed<Color>): Void {
    rl.UnloadImageColors(colors);
}
// Unload colors palette loaded with LoadImagePalette()
export let UnloadImagePalette(colors: Listed<Color>): Void {
    rl.UnloadImagePalette(colors);
}
// Get image alpha border rectangle
export let GetImageAlphaBorder(image: Image, threshold: Float64): Rectangle {
    return rl.GetImageAlphaBorder(image, threshold);
}
// Get image pixel color at (x, y) position
export let GetImageColor(image: Image, x: Int, y: Int): Color {
    return rl.GetImageColor(image, x, y);
}
// Clear image background with given color
export let ImageClearBackground(dst: Listed<Image>, color: Color): Void {
    rl.ImageClearBackground(dst, color);
}
// Draw pixel within an image
export let ImageDrawPixel(dst: Listed<Image>, posX: Int, posY: Int, color: Color): Void {
    rl.ImageDrawPixel(dst, posX, posY, color);
}
// Draw pixel within an image (Vector version)
export let ImageDrawPixelV(dst: Listed<Image>, position: Vector2, color: Color): Void {
    rl.ImageDrawPixelV(dst, position, color);
}
// Draw line within an image
export let ImageDrawLine(dst: Listed<Image>, startPosX: Int, startPosY: Int, endPosX: Int, endPosY: Int, color: Color): Void {
    rl.ImageDrawLine(dst, startPosX, startPosY, endPosX, endPosY, color);
}
// Draw line within an image (Vector version)
export let ImageDrawLineV(dst: Listed<Image>, start: Vector2, end: Vector2, color: Color): Void {
    rl.ImageDrawLineV(dst, start, end, color);
}
// Draw a filled circle within an image
export let ImageDrawCircle(dst: Listed<Image>, centerX: Int, centerY: Int, radius: Int, color: Color): Void {
    rl.ImageDrawCircle(dst, centerX, centerY, radius, color);
}
// Draw a filled circle within an image (Vector version)
export let ImageDrawCircleV(dst: Listed<Image>, center: Vector2, radius: Int, color: Color): Void {
    rl.ImageDrawCircleV(dst, center, radius, color);
}
// Draw circle outline within an image
export let ImageDrawCircleLines(dst: Listed<Image>, centerX: Int, centerY: Int, radius: Int, color: Color): Void {
    rl.ImageDrawCircleLines(dst, centerX, centerY, radius, color);
}
// Draw circle outline within an image (Vector version)
export let ImageDrawCircleLinesV(dst: Listed<Image>, center: Vector2, radius: Int, color: Color): Void {
    rl.ImageDrawCircleLinesV(dst, center, radius, color);
}
// Draw rectangle within an image
export let ImageDrawRectangle(dst: Listed<Image>, posX: Int, posY: Int, width: Int, height: Int, color: Color): Void {
    rl.ImageDrawRectangle(dst, posX, posY, width, height, color);
}
// Draw rectangle within an image (Vector version)
export let ImageDrawRectangleV(dst: Listed<Image>, position: Vector2, size: Vector2, color: Color): Void {
    rl.ImageDrawRectangleV(dst, position, size, color);
}
// Draw rectangle within an image
export let ImageDrawRectangleRec(dst: Listed<Image>, rec: Rectangle, color: Color): Void {
    rl.ImageDrawRectangleRec(dst, rec, color);
}
// Draw rectangle lines within an image
export let ImageDrawRectangleLines(dst: Listed<Image>, rec: Rectangle, thick: Int, color: Color): Void {
    rl.ImageDrawRectangleLines(dst, rec, thick, color);
}
// Draw a source image within a destination image (tint applied to source)
export let ImageDraw(dst: Listed<Image>, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color): Void {
    rl.ImageDraw(dst, src, srcRec, dstRec, tint);
}
// Draw text (using default font) within an image (destination)
export let ImageDrawText(dst: Listed<Image>, text: String, posX: Int, posY: Int, fontSize: Int, color: Color): Void {
    rl.ImageDrawText(dst, text, posX, posY, fontSize, color);
}
// Draw text (custom sprite font) within an image (destination)
export let ImageDrawTextEx(dst: Listed<Image>, font: Font, text: String, position: Vector2, fontSize: Float64, spacing: Float64, tint: Color): Void {
    rl.ImageDrawTextEx(dst, font, text, position, fontSize, spacing, tint);
}
// Load texture from file into GPU memory (VRAM)
export let LoadTexture(fileName: String): Texture2D {
    return rl.LoadTexture(fileName);
}
// Load texture from image data
export let LoadTextureFromImage(image: Image): Texture2D {
    return rl.LoadTextureFromImage(image);
}
// Load cubemap from image, multiple image cubemap layouts supported
export let LoadTextureCubemap(image: Image, layout: Int): TextureCubemap {
    return rl.LoadTextureCubemap(image, layout);
}
// Load texture for rendering (framebuffer)
export let LoadRenderTexture(width: Int, height: Int): RenderTexture2D {
    return rl.LoadRenderTexture(width, height);
}
// Check if a texture is ready
export let IsTextureReady(texture: Texture2D): Boolean {
    return rl.IsTextureReady(texture);
}
// Unload texture from GPU memory (VRAM)
export let UnloadTexture(texture: Texture2D): Void {
    rl.UnloadTexture(texture);
}
// Check if a render texture is ready
export let IsRenderTextureReady(target: RenderTexture2D): Boolean {
    return rl.IsRenderTextureReady(target);
}
// Unload render texture from GPU memory (VRAM)
export let UnloadRenderTexture(target: RenderTexture2D): Void {
    rl.UnloadRenderTexture(target);
}
// Update GPU texture with new data
export let UpdateTexture(texture: Texture2D, pixels: DenseBitVector): Void {
    rl.UpdateTexture(texture, pixels);
}
// Update GPU texture rectangle with new data
export let UpdateTextureRec(texture: Texture2D, rec: Rectangle, pixels: DenseBitVector): Void {
    rl.UpdateTextureRec(texture, rec, pixels);
}
// Generate GPU mipmaps for a texture
export let GenTextureMipmaps(texture: Listed<Texture2D>): Void {
    rl.GenTextureMipmaps(texture);
}
// Set texture scaling filter mode
export let SetTextureFilter(texture: Texture2D, filter: Int): Void {
    rl.SetTextureFilter(texture, filter);
}
// Set texture wrapping mode
export let SetTextureWrap(texture: Texture2D, wrap: Int): Void {
    rl.SetTextureWrap(texture, wrap);
}
// Draw a Texture2D
export let DrawTexture(texture: Texture2D, posX: Int, posY: Int, tint: Color): Void {
    rl.DrawTexture(texture, posX, posY, tint);
}
// Draw a Texture2D with position defined as Vector2
export let DrawTextureV(texture: Texture2D, position: Vector2, tint: Color): Void {
    rl.DrawTextureV(texture, position, tint);
}
// Draw a Texture2D with extended parameters
export let DrawTextureEx(texture: Texture2D, position: Vector2, rotation: Float64, scale: Float64, tint: Color): Void {
    rl.DrawTextureEx(texture, position, rotation, scale, tint);
}
// Draw a part of a texture defined by a rectangle
export let DrawTextureRec(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color): Void {
    rl.DrawTextureRec(texture, source, position, tint);
}
// Draw a part of a texture defined by a rectangle with 'pro' parameters
export let DrawTexturePro(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: Float64, tint: Color): Void {
    rl.DrawTexturePro(texture, source, dest, origin, rotation, tint);
}
// Draws a texture (or part of it) that stretches or shrinks nicely
export let DrawTextureNPatch(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: Float64, tint: Color): Void {
    rl.DrawTextureNPatch(texture, nPatchInfo, dest, origin, rotation, tint);
}
// Get color with alpha applied, alpha goes from 0.0f to 1.0f
export let Fade(color: Color, alpha: Float64): Color {
    return rl.Fade(color, alpha);
}
// Get hexadecimal value for a Color
export let ColorToInt(color: Color): Int {
    return rl.ColorToInt(color);
}
// Get Color normalized as float [0..1]
export let ColorNormalize(color: Color): Vector4 {
    return rl.ColorNormalize(color);
}
// Get Color from normalized values [0..1]
export let ColorFromNormalized(normalized: Vector4): Color {
    return rl.ColorFromNormalized(normalized);
}
// Get HSV values for a Color, hue [0..360], saturation/value [0..1]
export let ColorToHSV(color: Color): Vector3 {
    return rl.ColorToHSV(color);
}
// Get a Color from HSV values, hue [0..360], saturation/value [0..1]
export let ColorFromHSV(hue: Float64, saturation: Float64, value: Float64): Color {
    return rl.ColorFromHSV(hue, saturation, value);
}
// Get color multiplied with another color
export let ColorTint(color: Color, tint: Color): Color {
    return rl.ColorTint(color, tint);
}
// Get color with brightness correction, brightness factor goes from -1.0f to 1.0f
export let ColorBrightness(color: Color, factor: Float64): Color {
    return rl.ColorBrightness(color, factor);
}
// Get color with contrast correction, contrast values between -1.0f and 1.0f
export let ColorContrast(color: Color, contrast: Float64): Color {
    return rl.ColorContrast(color, contrast);
}
// Get color with alpha applied, alpha goes from 0.0f to 1.0f
export let ColorAlpha(color: Color, alpha: Float64): Color {
    return rl.ColorAlpha(color, alpha);
}
// Get src alpha-blended into dst color with tint
export let ColorAlphaBlend(dst: Color, src: Color, tint: Color): Color {
    return rl.ColorAlphaBlend(dst, src, tint);
}
// Get Color structure from hexadecimal value
export let GetColor(hexValue: Int): Color {
    return rl.GetColor(hexValue);
}
// Get Color from a source pixel pointer of certain format
export let GetPixelColor(srcPtr: DenseBitVector, format: Int): Color {
    return rl.GetPixelColor(srcPtr, format);
}
// Set color formatted into destination pixel pointer
export let SetPixelColor(dstPtr: DenseBitVector, color: Color, format: Int): Void {
    rl.SetPixelColor(dstPtr, color, format);
}
// Get pixel data size in bytes for certain format
export let GetPixelDataSize(width: Int, height: Int, format: Int): Int {
    return rl.GetPixelDataSize(width, height, format);
}
// Get the default Font
export let GetFontDefault(): Font {
    return rl.GetFontDefault();
}
// Load font from file into GPU memory (VRAM)
export let LoadFont(fileName: String): Font {
    return rl.LoadFont(fileName);
}
// Load font from file with extended parameters, use NULL for codepoints and 0 for codepointCount to load the default character setFont
export let LoadFontEx(fileName: String, fontSize: Int, codepoints: Listed<Int>, codepointCount: Int): Font {
    return rl.LoadFontEx(fileName, fontSize, codepoints, codepointCount);
}
// Load font from Image (XNA style)
export let LoadFontFromImage(image: Image, key: Color, firstChar: Int): Font {
    return rl.LoadFontFromImage(image, key, firstChar);
}
// Load font from memory buffer, fileType refers to extension: i.e. '.ttf'
export let LoadFontFromMemory(fileType: String, fileData: Listed<Int>, dataSize: Int, fontSize: Int, codepoints: Listed<Int>, codepointCount: Int): Font {
    return rl.LoadFontFromMemory(fileType, fileData, dataSize, fontSize, codepoints, codepointCount);
}
// Check if a font is ready
export let IsFontReady(font: Font): Boolean {
    return rl.IsFontReady(font);
}
// Load font data for further use
export let LoadFontData(fileData: Listed<Int>, dataSize: Int, fontSize: Int, codepoints: Listed<Int>, codepointCount: Int, type: Int): Listed<GlyphInfo> {
    return rl.LoadFontData(fileData, dataSize, fontSize, codepoints, codepointCount, type);
}
// Generate image font atlas using chars info
export let GenImageFontAtlas(glyphs: Listed<GlyphInfo>, glyphRecs: Listed<Listed<Rectangle>>, glyphCount: Int, fontSize: Int, padding: Int, packMethod: Int): Image {
    return rl.GenImageFontAtlas(glyphs, glyphRecs, glyphCount, fontSize, padding, packMethod);
}
// Unload font chars info data (RAM)
export let UnloadFontData(glyphs: Listed<GlyphInfo>, glyphCount: Int): Void {
    rl.UnloadFontData(glyphs, glyphCount);
}
// Unload font from GPU memory (VRAM)
export let UnloadFont(font: Font): Void {
    rl.UnloadFont(font);
}
// Export font as code file, returns true on success
export let ExportFontAsCode(font: Font, fileName: String): Boolean {
    return rl.ExportFontAsCode(font, fileName);
}
// Draw current FPS
export let DrawFPS(posX: Int, posY: Int): Void {
    rl.DrawFPS(posX, posY);
}
// Draw text (using default font)
export let DrawText(text: String, posX: Int, posY: Int, fontSize: Int, color: Color): Void {
    rl.DrawText(text, posX, posY, fontSize, color);
}
// Draw text using font and additional parameters
export let DrawTextEx(font: Font, text: String, position: Vector2, fontSize: Float64, spacing: Float64, tint: Color): Void {
    rl.DrawTextEx(font, text, position, fontSize, spacing, tint);
}
// Draw text using Font and pro parameters (rotation)
export let DrawTextPro(font: Font, text: String, position: Vector2, origin: Vector2, rotation: Float64, fontSize: Float64, spacing: Float64, tint: Color): Void {
    rl.DrawTextPro(font, text, position, origin, rotation, fontSize, spacing, tint);
}
// Draw one character (codepoint)
export let DrawTextCodepoint(font: Font, codepoint: Int, position: Vector2, fontSize: Float64, tint: Color): Void {
    rl.DrawTextCodepoint(font, codepoint, position, fontSize, tint);
}
// Draw multiple character (codepoint)
export let DrawTextCodepoints(font: Font, codepoints: Listed<Int>, codepointCount: Int, position: Vector2, fontSize: Float64, spacing: Float64, tint: Color): Void {
    rl.DrawTextCodepoints(font, codepoints, codepointCount, position, fontSize, spacing, tint);
}
// Set vertical line spacing when drawing with line-breaks
export let SetTextLineSpacing(spacing: Int): Void {
    rl.SetTextLineSpacing(spacing);
}
// Measure string width for default font
export let MeasureText(text: String, fontSize: Int): Int {
    return rl.MeasureText(text, fontSize);
}
// Measure string size for Font
export let MeasureTextEx(font: Font, text: String, fontSize: Float64, spacing: Float64): Vector2 {
    return rl.MeasureTextEx(font, text, fontSize, spacing);
}
// Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found
export let GetGlyphIndex(font: Font, codepoint: Int): Int {
    return rl.GetGlyphIndex(font, codepoint);
}
// Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found
export let GetGlyphInfo(font: Font, codepoint: Int): GlyphInfo {
    return rl.GetGlyphInfo(font, codepoint);
}
// Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found
export let GetGlyphAtlasRec(font: Font, codepoint: Int): Rectangle {
    return rl.GetGlyphAtlasRec(font, codepoint);
}
// Load UTF-8 text encoded from codepoints array
export let LoadUTF8(codepoints: Listed<Int>, length: Int): String {
    return rl.LoadUTF8(codepoints, length);
}
// Unload UTF-8 text encoded from codepoints array
export let UnloadUTF8(text: String): Void {
    rl.UnloadUTF8(text);
}
// Load all codepoints from a UTF-8 text string, codepoints count returned by parameter
export let LoadCodepoints(text: String, count: Listed<Int>): Listed<Int> {
    return rl.LoadCodepoints(text, count);
}
// Unload codepoints data from memory
export let UnloadCodepoints(codepoints: Listed<Int>): Void {
    rl.UnloadCodepoints(codepoints);
}
// Get total number of codepoints in a UTF-8 encoded string
export let GetCodepointCount(text: String): Int {
    return rl.GetCodepointCount(text);
}
// Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
export let GetCodepoint(text: String, codepointSize: Listed<Int>): Int {
    return rl.GetCodepoint(text, codepointSize);
}
// Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
export let GetCodepointNext(text: String, codepointSize: Listed<Int>): Int {
    return rl.GetCodepointNext(text, codepointSize);
}
// Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
export let GetCodepointPrevious(text: String, codepointSize: Listed<Int>): Int {
    return rl.GetCodepointPrevious(text, codepointSize);
}
// Encode one codepoint into UTF-8 byte array (array length returned as parameter)
export let CodepointToUTF8(codepoint: Int, utf8Size: Listed<Int>): String {
    return rl.CodepointToUTF8(codepoint, utf8Size);
}
// Copy one string to another, returns bytes copied
export let TextCopy(dst: String, src: String): Int {
    return rl.TextCopy(dst, src);
}
// Check if two text string are equal
export let TextIsEqual(text1: String, text2: String): Boolean {
    return rl.TextIsEqual(text1, text2);
}
// Get text length, checks for '\0' ending
export let TextLength(text: String): Int {
    return rl.TextLength(text);
}
// Get a piece of a text string
export let TextSubtext(text: String, position: Int, length: Int): String {
    return rl.TextSubtext(text, position, length);
}
// Replace text string (WARNING: memory must be freed!)
export let TextReplace(text: String, replace: String, by: String): String {
    return rl.TextReplace(text, replace, by);
}
// Insert text in a position (WARNING: memory must be freed!)
export let TextInsert(text: String, insert: String, position: Int): String {
    return rl.TextInsert(text, insert, position);
}
// Join text strings with delimiter
export let TextJoin(textList: Listed<String>, count: Int, delimiter: String): String {
    return rl.TextJoin(textList, count, delimiter);
}
// Split text into multiple strings
export let TextSplit(text: String, delimiter: Int, count: Listed<Int>): Listed<String> {
    return rl.TextSplit(text, delimiter, count);
}
// Append text at specific position and move cursor!
export let TextAppend(text: String, append: String, position: Listed<Int>): Void {
    rl.TextAppend(text, append, position);
}
// Find first text occurrence within a string
export let TextFindIndex(text: String, find: String): Int {
    return rl.TextFindIndex(text, find);
}
// Get upper case version of provided string
export let TextToUpper(text: String): String {
    return rl.TextToUpper(text);
}
// Get lower case version of provided string
export let TextToLower(text: String): String {
    return rl.TextToLower(text);
}
// Get Pascal case notation version of provided string
export let TextToPascal(text: String): String {
    return rl.TextToPascal(text);
}
// Get integer value from text (negative values not supported)
export let TextToInteger(text: String): Int {
    return rl.TextToInteger(text);
}
// Get float value from text (negative values not supported)
export let TextToFloat(text: String): Float64 {
    return rl.TextToFloat(text);
}
// Draw a line in 3D world space
export let DrawLine3D(startPos: Vector3, endPos: Vector3, color: Color): Void {
    rl.DrawLine3D(startPos, endPos, color);
}
// Draw a point in 3D space, actually a small line
export let DrawPoint3D(position: Vector3, color: Color): Void {
    rl.DrawPoint3D(position, color);
}
// Draw a circle in 3D world space
export let DrawCircle3D(center: Vector3, radius: Float64, rotationAxis: Vector3, rotationAngle: Float64, color: Color): Void {
    rl.DrawCircle3D(center, radius, rotationAxis, rotationAngle, color);
}
// Draw a color-filled triangle (vertex in counter-clockwise order!)
export let DrawTriangle3D(v1: Vector3, v2: Vector3, v3: Vector3, color: Color): Void {
    rl.DrawTriangle3D(v1, v2, v3, color);
}
// Draw a triangle strip defined by points
export let DrawTriangleStrip3D(points: Listed<Vector3>, pointCount: Int, color: Color): Void {
    rl.DrawTriangleStrip3D(points, pointCount, color);
}
// Draw cube
export let DrawCube(position: Vector3, width: Float64, height: Float64, length: Float64, color: Color): Void {
    rl.DrawCube(position, width, height, length, color);
}
// Draw cube (Vector version)
export let DrawCubeV(position: Vector3, size: Vector3, color: Color): Void {
    rl.DrawCubeV(position, size, color);
}
// Draw cube wires
export let DrawCubeWires(position: Vector3, width: Float64, height: Float64, length: Float64, color: Color): Void {
    rl.DrawCubeWires(position, width, height, length, color);
}
// Draw cube wires (Vector version)
export let DrawCubeWiresV(position: Vector3, size: Vector3, color: Color): Void {
    rl.DrawCubeWiresV(position, size, color);
}
// Draw sphere
export let DrawSphere(centerPos: Vector3, radius: Float64, color: Color): Void {
    rl.DrawSphere(centerPos, radius, color);
}
// Draw sphere with extended parameters
export let DrawSphereEx(centerPos: Vector3, radius: Float64, rings: Int, slices: Int, color: Color): Void {
    rl.DrawSphereEx(centerPos, radius, rings, slices, color);
}
// Draw sphere wires
export let DrawSphereWires(centerPos: Vector3, radius: Float64, rings: Int, slices: Int, color: Color): Void {
    rl.DrawSphereWires(centerPos, radius, rings, slices, color);
}
// Draw a cylinder/cone
export let DrawCylinder(position: Vector3, radiusTop: Float64, radiusBottom: Float64, height: Float64, slices: Int, color: Color): Void {
    rl.DrawCylinder(position, radiusTop, radiusBottom, height, slices, color);
}
// Draw a cylinder with base at startPos and top at endPos
export let DrawCylinderEx(startPos: Vector3, endPos: Vector3, startRadius: Float64, endRadius: Float64, sides: Int, color: Color): Void {
    rl.DrawCylinderEx(startPos, endPos, startRadius, endRadius, sides, color);
}
// Draw a cylinder/cone wires
export let DrawCylinderWires(position: Vector3, radiusTop: Float64, radiusBottom: Float64, height: Float64, slices: Int, color: Color): Void {
    rl.DrawCylinderWires(position, radiusTop, radiusBottom, height, slices, color);
}
// Draw a cylinder wires with base at startPos and top at endPos
export let DrawCylinderWiresEx(startPos: Vector3, endPos: Vector3, startRadius: Float64, endRadius: Float64, sides: Int, color: Color): Void {
    rl.DrawCylinderWiresEx(startPos, endPos, startRadius, endRadius, sides, color);
}
// Draw a capsule with the center of its sphere caps at startPos and endPos
export let DrawCapsule(startPos: Vector3, endPos: Vector3, radius: Float64, slices: Int, rings: Int, color: Color): Void {
    rl.DrawCapsule(startPos, endPos, radius, slices, rings, color);
}
// Draw capsule wireframe with the center of its sphere caps at startPos and endPos
export let DrawCapsuleWires(startPos: Vector3, endPos: Vector3, radius: Float64, slices: Int, rings: Int, color: Color): Void {
    rl.DrawCapsuleWires(startPos, endPos, radius, slices, rings, color);
}
// Draw a plane XZ
export let DrawPlane(centerPos: Vector3, size: Vector2, color: Color): Void {
    rl.DrawPlane(centerPos, size, color);
}
// Draw a ray line
export let DrawRay(ray: Ray, color: Color): Void {
    rl.DrawRay(ray, color);
}
// Draw a grid (centered at (0, 0, 0))
export let DrawGrid(slices: Int, spacing: Float64): Void {
    rl.DrawGrid(slices, spacing);
}
// Load model from files (meshes and materials)
export let LoadModel(fileName: String): Model {
    return rl.LoadModel(fileName);
}
// Load model from generated mesh (default material)
export let LoadModelFromMesh(mesh: Mesh): Model {
    return rl.LoadModelFromMesh(mesh);
}
// Check if a model is ready
export let IsModelReady(model: Model): Boolean {
    return rl.IsModelReady(model);
}
// Unload model (including meshes) from memory (RAM and/or VRAM)
export let UnloadModel(model: Model): Void {
    rl.UnloadModel(model);
}
// Compute model bounding box limits (considers all meshes)
export let GetModelBoundingBox(model: Model): BoundingBox {
    return rl.GetModelBoundingBox(model);
}
// Draw a model (with texture if set)
export let DrawModel(model: Model, position: Vector3, scale: Float64, tint: Color): Void {
    rl.DrawModel(model, position, scale, tint);
}
// Draw a model with extended parameters
export let DrawModelEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: Float64, scale: Vector3, tint: Color): Void {
    rl.DrawModelEx(model, position, rotationAxis, rotationAngle, scale, tint);
}
// Draw a model wires (with texture if set)
export let DrawModelWires(model: Model, position: Vector3, scale: Float64, tint: Color): Void {
    rl.DrawModelWires(model, position, scale, tint);
}
// Draw a model wires (with texture if set) with extended parameters
export let DrawModelWiresEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: Float64, scale: Vector3, tint: Color): Void {
    rl.DrawModelWiresEx(model, position, rotationAxis, rotationAngle, scale, tint);
}
// Draw bounding box (wires)
export let DrawBoundingBox(box: BoundingBox, color: Color): Void {
    rl.DrawBoundingBox(box, color);
}
// Draw a billboard texture
export let DrawBillboard(camera: Camera, texture: Texture2D, position: Vector3, size: Float64, tint: Color): Void {
    rl.DrawBillboard(camera, texture, position, size, tint);
}
// Draw a billboard texture defined by source
export let DrawBillboardRec(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color): Void {
    rl.DrawBillboardRec(camera, texture, source, position, size, tint);
}
// Draw a billboard texture defined by source and rotation
export let DrawBillboardPro(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: Float64, tint: Color): Void {
    rl.DrawBillboardPro(camera, texture, source, position, up, size, origin, rotation, tint);
}
// Upload mesh vertex data in GPU and provide VAO/VBO ids
export let UploadMesh(mesh: Listed<Mesh>, dynamic: Boolean): Void {
    rl.UploadMesh(mesh, dynamic);
}
// Update mesh vertex data in GPU for a specific buffer index
export let UpdateMeshBuffer(mesh: Mesh, index: Int, data: DenseBitVector, dataSize: Int, offset: Int): Void {
    rl.UpdateMeshBuffer(mesh, index, data, dataSize, offset);
}
// Unload mesh data from CPU and GPU
export let UnloadMesh(mesh: Mesh): Void {
    rl.UnloadMesh(mesh);
}
// Draw a 3d mesh with material and transform
export let DrawMesh(mesh: Mesh, material: Material, transform: Matrix): Void {
    rl.DrawMesh(mesh, material, transform);
}
// Draw multiple mesh instances with material and different transforms
export let DrawMeshInstanced(mesh: Mesh, material: Material, transforms: Listed<Matrix>, instances: Int): Void {
    rl.DrawMeshInstanced(mesh, material, transforms, instances);
}
// Compute mesh bounding box limits
export let GetMeshBoundingBox(mesh: Mesh): BoundingBox {
    return rl.GetMeshBoundingBox(mesh);
}
// Compute mesh tangents
export let GenMeshTangents(mesh: Listed<Mesh>): Void {
    rl.GenMeshTangents(mesh);
}
// Export mesh data to file, returns true on success
export let ExportMesh(mesh: Mesh, fileName: String): Boolean {
    return rl.ExportMesh(mesh, fileName);
}
// Export mesh as code file (.h) defining multiple arrays of vertex attributes
export let ExportMeshAsCode(mesh: Mesh, fileName: String): Boolean {
    return rl.ExportMeshAsCode(mesh, fileName);
}
// Generate polygonal mesh
export let GenMeshPoly(sides: Int, radius: Float64): Mesh {
    return rl.GenMeshPoly(sides, radius);
}
// Generate plane mesh (with subdivisions)
export let GenMeshPlane(width: Float64, length: Float64, resX: Int, resZ: Int): Mesh {
    return rl.GenMeshPlane(width, length, resX, resZ);
}
// Generate cuboid mesh
export let GenMeshCube(width: Float64, height: Float64, length: Float64): Mesh {
    return rl.GenMeshCube(width, height, length);
}
// Generate sphere mesh (standard sphere)
export let GenMeshSphere(radius: Float64, rings: Int, slices: Int): Mesh {
    return rl.GenMeshSphere(radius, rings, slices);
}
// Generate half-sphere mesh (no bottom cap)
export let GenMeshHemiSphere(radius: Float64, rings: Int, slices: Int): Mesh {
    return rl.GenMeshHemiSphere(radius, rings, slices);
}
// Generate cylinder mesh
export let GenMeshCylinder(radius: Float64, height: Float64, slices: Int): Mesh {
    return rl.GenMeshCylinder(radius, height, slices);
}
// Generate cone/pyramid mesh
export let GenMeshCone(radius: Float64, height: Float64, slices: Int): Mesh {
    return rl.GenMeshCone(radius, height, slices);
}
// Generate torus mesh
export let GenMeshTorus(radius: Float64, size: Float64, radSeg: Int, sides: Int): Mesh {
    return rl.GenMeshTorus(radius, size, radSeg, sides);
}
// Generate trefoil knot mesh
export let GenMeshKnot(radius: Float64, size: Float64, radSeg: Int, sides: Int): Mesh {
    return rl.GenMeshKnot(radius, size, radSeg, sides);
}
// Generate heightmap mesh from image data
export let GenMeshHeightmap(heightmap: Image, size: Vector3): Mesh {
    return rl.GenMeshHeightmap(heightmap, size);
}
// Generate cubes-based map mesh from image data
export let GenMeshCubicmap(cubicmap: Image, cubeSize: Vector3): Mesh {
    return rl.GenMeshCubicmap(cubicmap, cubeSize);
}
// Load materials from model file
export let LoadMaterials(fileName: String, materialCount: Listed<Int>): Listed<Material> {
    return rl.LoadMaterials(fileName, materialCount);
}
// Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)
export let LoadMaterialDefault(): Material {
    return rl.LoadMaterialDefault();
}
// Check if a material is ready
export let IsMaterialReady(material: Material): Boolean {
    return rl.IsMaterialReady(material);
}
// Unload material from GPU memory (VRAM)
export let UnloadMaterial(material: Material): Void {
    rl.UnloadMaterial(material);
}
// Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)
export let SetMaterialTexture(material: Listed<Material>, mapType: Int, texture: Texture2D): Void {
    rl.SetMaterialTexture(material, mapType, texture);
}
// Set material for a mesh
export let SetModelMeshMaterial(model: Listed<Model>, meshId: Int, materialId: Int): Void {
    rl.SetModelMeshMaterial(model, meshId, materialId);
}
// Load model animations from file
export let LoadModelAnimations(fileName: String, animCount: Listed<Int>): Listed<ModelAnimation> {
    return rl.LoadModelAnimations(fileName, animCount);
}
// Update model animation pose
export let UpdateModelAnimation(model: Model, anim: ModelAnimation, frame: Int): Void {
    rl.UpdateModelAnimation(model, anim, frame);
}
// Unload animation data
export let UnloadModelAnimation(anim: ModelAnimation): Void {
    rl.UnloadModelAnimation(anim);
}
// Unload animation array data
export let UnloadModelAnimations(animations: Listed<ModelAnimation>, animCount: Int): Void {
    rl.UnloadModelAnimations(animations, animCount);
}
// Check model animation skeleton match
export let IsModelAnimationValid(model: Model, anim: ModelAnimation): Boolean {
    return rl.IsModelAnimationValid(model, anim);
}
// Check collision between two spheres
export let CheckCollisionSpheres(center1: Vector3, radius1: Float64, center2: Vector3, radius2: Float64): Boolean {
    return rl.CheckCollisionSpheres(center1, radius1, center2, radius2);
}
// Check collision between two bounding boxes
export let CheckCollisionBoxes(box1: BoundingBox, box2: BoundingBox): Boolean {
    return rl.CheckCollisionBoxes(box1, box2);
}
// Check collision between box and sphere
export let CheckCollisionBoxSphere(box: BoundingBox, center: Vector3, radius: Float64): Boolean {
    return rl.CheckCollisionBoxSphere(box, center, radius);
}
// Get collision info between ray and sphere
export let GetRayCollisionSphere(ray: Ray, center: Vector3, radius: Float64): RayCollision {
    return rl.GetRayCollisionSphere(ray, center, radius);
}
// Get collision info between ray and box
export let GetRayCollisionBox(ray: Ray, box: BoundingBox): RayCollision {
    return rl.GetRayCollisionBox(ray, box);
}
// Get collision info between ray and mesh
export let GetRayCollisionMesh(ray: Ray, mesh: Mesh, transform: Matrix): RayCollision {
    return rl.GetRayCollisionMesh(ray, mesh, transform);
}
// Get collision info between ray and triangle
export let GetRayCollisionTriangle(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3): RayCollision {
    return rl.GetRayCollisionTriangle(ray, p1, p2, p3);
}
// Get collision info between ray and quad
export let GetRayCollisionQuad(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3): RayCollision {
    return rl.GetRayCollisionQuad(ray, p1, p2, p3, p4);
}
// Initialize audio device and context
export let InitAudioDevice(): Void {
    rl.InitAudioDevice();
}
// Close the audio device and context
export let CloseAudioDevice(): Void {
    rl.CloseAudioDevice();
}
// Check if audio device has been initialized successfully
export let IsAudioDeviceReady(): Boolean {
    return rl.IsAudioDeviceReady();
}
// Set master volume (listener)
export let SetMasterVolume(volume: Float64): Void {
    rl.SetMasterVolume(volume);
}
// Get master volume (listener)
export let GetMasterVolume(): Float64 {
    return rl.GetMasterVolume();
}
// Load wave data from file
export let LoadWave(fileName: String): Wave {
    return rl.LoadWave(fileName);
}
// Load wave from memory buffer, fileType refers to extension: i.e. '.wav'
export let LoadWaveFromMemory(fileType: String, fileData: Listed<Int>, dataSize: Int): Wave {
    return rl.LoadWaveFromMemory(fileType, fileData, dataSize);
}
// Checks if wave data is ready
export let IsWaveReady(wave: Wave): Boolean {
    return rl.IsWaveReady(wave);
}
// Unload wave data
export let UnloadWave(wave: Wave): Void {
    rl.UnloadWave(wave);
}
// Export wave data to file, returns true on success
export let ExportWave(wave: Wave, fileName: String): Boolean {
    return rl.ExportWave(wave, fileName);
}
// Export wave sample data to code (.h), returns true on success
export let ExportWaveAsCode(wave: Wave, fileName: String): Boolean {
    return rl.ExportWaveAsCode(wave, fileName);
}
// Copy a wave to a new wave
export let WaveCopy(wave: Wave): Wave {
    return rl.WaveCopy(wave);
}
// Crop a wave to defined samples range
export let WaveCrop(wave: Listed<Wave>, initSample: Int, finalSample: Int): Void {
    rl.WaveCrop(wave, initSample, finalSample);
}
// Convert wave data to desired format
export let WaveFormat(wave: Listed<Wave>, sampleRate: Int, sampleSize: Int, channels: Int): Void {
    rl.WaveFormat(wave, sampleRate, sampleSize, channels);
}
// Load samples data from wave as a 32bit float data array
export let LoadWaveSamples(wave: Wave): Listed<Float64> {
    return rl.LoadWaveSamples(wave);
}
// Unload samples data loaded with LoadWaveSamples()
export let UnloadWaveSamples(samples: Listed<Float64>): Void {
    rl.UnloadWaveSamples(samples);
}
// Load music stream from file
export let LoadMusicStream(fileName: String): Music {
    return rl.LoadMusicStream(fileName);
}
// Load music stream from data
export let LoadMusicStreamFromMemory(fileType: String, data: Listed<Int>, dataSize: Int): Music {
    return rl.LoadMusicStreamFromMemory(fileType, data, dataSize);
}
// Checks if a music stream is ready
export let IsMusicReady(music: Music): Boolean {
    return rl.IsMusicReady(music);
}
// Unload music stream
export let UnloadMusicStream(music: Music): Void {
    rl.UnloadMusicStream(music);
}
// Start music playing
export let PlayMusicStream(music: Music): Void {
    rl.PlayMusicStream(music);
}
// Check if music is playing
export let IsMusicStreamPlaying(music: Music): Boolean {
    return rl.IsMusicStreamPlaying(music);
}
// Updates buffers for music streaming
export let UpdateMusicStream(music: Music): Void {
    rl.UpdateMusicStream(music);
}
// Stop music playing
export let StopMusicStream(music: Music): Void {
    rl.StopMusicStream(music);
}
// Pause music playing
export let PauseMusicStream(music: Music): Void {
    rl.PauseMusicStream(music);
}
// Resume playing paused music
export let ResumeMusicStream(music: Music): Void {
    rl.ResumeMusicStream(music);
}
// Seek music to a position (in seconds)
export let SeekMusicStream(music: Music, position: Float64): Void {
    rl.SeekMusicStream(music, position);
}
// Set volume for music (1.0 is max level)
export let SetMusicVolume(music: Music, volume: Float64): Void {
    rl.SetMusicVolume(music, volume);
}
// Set pitch for a music (1.0 is base level)
export let SetMusicPitch(music: Music, pitch: Float64): Void {
    rl.SetMusicPitch(music, pitch);
}
// Set pan for a music (0.5 is center)
export let SetMusicPan(music: Music, pan: Float64): Void {
    rl.SetMusicPan(music, pan);
}
// Get music time length (in seconds)
export let GetMusicTimeLength(music: Music): Float64 {
    return rl.GetMusicTimeLength(music);
}
// Get current music time played (in seconds)
export let GetMusicTimePlayed(music: Music): Float64 {
    return rl.GetMusicTimePlayed(music);
}
// Load audio stream (to stream raw audio pcm data)
export let LoadAudioStream(sampleRate: Int, sampleSize: Int, channels: Int): AudioStream {
    return rl.LoadAudioStream(sampleRate, sampleSize, channels);
}
// Checks if an audio stream is ready
export let IsAudioStreamReady(stream: AudioStream): Boolean {
    return rl.IsAudioStreamReady(stream);
}
// Unload audio stream and free memory
export let UnloadAudioStream(stream: AudioStream): Void {
    rl.UnloadAudioStream(stream);
}
// Update audio stream buffers with data
export let UpdateAudioStream(stream: AudioStream, data: DenseBitVector, frameCount: Int): Void {
    rl.UpdateAudioStream(stream, data, frameCount);
}
// Check if any audio stream buffers requires refill
export let IsAudioStreamProcessed(stream: AudioStream): Boolean {
    return rl.IsAudioStreamProcessed(stream);
}
// Play audio stream
export let PlayAudioStream(stream: AudioStream): Void {
    rl.PlayAudioStream(stream);
}
// Pause audio stream
export let PauseAudioStream(stream: AudioStream): Void {
    rl.PauseAudioStream(stream);
}
// Resume audio stream
export let ResumeAudioStream(stream: AudioStream): Void {
    rl.ResumeAudioStream(stream);
}
// Check if audio stream is playing
export let IsAudioStreamPlaying(stream: AudioStream): Boolean {
    return rl.IsAudioStreamPlaying(stream);
}
// Stop audio stream
export let StopAudioStream(stream: AudioStream): Void {
    rl.StopAudioStream(stream);
}
// Set volume for audio stream (1.0 is max level)
export let SetAudioStreamVolume(stream: AudioStream, volume: Float64): Void {
    rl.SetAudioStreamVolume(stream, volume);
}
// Set pitch for audio stream (1.0 is base level)
export let SetAudioStreamPitch(stream: AudioStream, pitch: Float64): Void {
    rl.SetAudioStreamPitch(stream, pitch);
}
// Set pan for audio stream (0.5 is centered)
export let SetAudioStreamPan(stream: AudioStream, pan: Float64): Void {
    rl.SetAudioStreamPan(stream, pan);
}
// Default size for new audio streams
export let SetAudioStreamBufferSizeDefault(size: Int): Void {
    rl.SetAudioStreamBufferSizeDefault(size);
}
// 
export let Clamp(value: Float64, min: Float64, max: Float64): Float64 {
    return rl.Clamp(value, min, max);
}
// 
export let Lerp(start: Float64, end: Float64, amount: Float64): Float64 {
    return rl.Lerp(start, end, amount);
}
// 
export let Normalize(value: Float64, start: Float64, end: Float64): Float64 {
    return rl.Normalize(value, start, end);
}
// 
export let Remap(value: Float64, inputStart: Float64, inputEnd: Float64, outputStart: Float64, outputEnd: Float64): Float64 {
    return rl.Remap(value, inputStart, inputEnd, outputStart, outputEnd);
}
// 
export let Wrap(value: Float64, min: Float64, max: Float64): Float64 {
    return rl.Wrap(value, min, max);
}
// 
export let FloatEquals(x: Float64, y: Float64): Int {
    return rl.FloatEquals(x, y);
}
// 
export let Vector2Zero(): Vector2 {
    return rl.Vector2Zero();
}
// 
export let Vector2One(): Vector2 {
    return rl.Vector2One();
}
// 
export let Vector2Add(v1: Vector2, v2: Vector2): Vector2 {
    return rl.Vector2Add(v1, v2);
}
// 
export let Vector2AddValue(v: Vector2, add: Float64): Vector2 {
    return rl.Vector2AddValue(v, add);
}
// 
export let Vector2Subtract(v1: Vector2, v2: Vector2): Vector2 {
    return rl.Vector2Subtract(v1, v2);
}
// 
export let Vector2SubtractValue(v: Vector2, sub: Float64): Vector2 {
    return rl.Vector2SubtractValue(v, sub);
}
// 
export let Vector2Length(v: Vector2): Float64 {
    return rl.Vector2Length(v);
}
// 
export let Vector2LengthSqr(v: Vector2): Float64 {
    return rl.Vector2LengthSqr(v);
}
// 
export let Vector2DotProduct(v1: Vector2, v2: Vector2): Float64 {
    return rl.Vector2DotProduct(v1, v2);
}
// 
export let Vector2Distance(v1: Vector2, v2: Vector2): Float64 {
    return rl.Vector2Distance(v1, v2);
}
// 
export let Vector2DistanceSqr(v1: Vector2, v2: Vector2): Float64 {
    return rl.Vector2DistanceSqr(v1, v2);
}
// 
export let Vector2Angle(v1: Vector2, v2: Vector2): Float64 {
    return rl.Vector2Angle(v1, v2);
}
// 
export let Vector2LineAngle(start: Vector2, end: Vector2): Float64 {
    return rl.Vector2LineAngle(start, end);
}
// 
export let Vector2Scale(v: Vector2, scale: Float64): Vector2 {
    return rl.Vector2Scale(v, scale);
}
// 
export let Vector2Multiply(v1: Vector2, v2: Vector2): Vector2 {
    return rl.Vector2Multiply(v1, v2);
}
// 
export let Vector2Negate(v: Vector2): Vector2 {
    return rl.Vector2Negate(v);
}
// 
export let Vector2Divide(v1: Vector2, v2: Vector2): Vector2 {
    return rl.Vector2Divide(v1, v2);
}
// 
export let Vector2Normalize(v: Vector2): Vector2 {
    return rl.Vector2Normalize(v);
}
// 
export let Vector2Transform(v: Vector2, mat: Matrix): Vector2 {
    return rl.Vector2Transform(v, mat);
}
// 
export let Vector2Lerp(v1: Vector2, v2: Vector2, amount: Float64): Vector2 {
    return rl.Vector2Lerp(v1, v2, amount);
}
// 
export let Vector2Reflect(v: Vector2, normal: Vector2): Vector2 {
    return rl.Vector2Reflect(v, normal);
}
// 
export let Vector2Rotate(v: Vector2, angle: Float64): Vector2 {
    return rl.Vector2Rotate(v, angle);
}
// 
export let Vector2MoveTowards(v: Vector2, target: Vector2, maxDistance: Float64): Vector2 {
    return rl.Vector2MoveTowards(v, target, maxDistance);
}
// 
export let Vector2Invert(v: Vector2): Vector2 {
    return rl.Vector2Invert(v);
}
// 
export let Vector2Clamp(v: Vector2, min: Vector2, max: Vector2): Vector2 {
    return rl.Vector2Clamp(v, min, max);
}
// 
export let Vector2ClampValue(v: Vector2, min: Float64, max: Float64): Vector2 {
    return rl.Vector2ClampValue(v, min, max);
}
// 
export let Vector2Equals(p: Vector2, q: Vector2): Int {
    return rl.Vector2Equals(p, q);
}
// 
export let Vector3Zero(): Vector3 {
    return rl.Vector3Zero();
}
// 
export let Vector3One(): Vector3 {
    return rl.Vector3One();
}
// 
export let Vector3Add(v1: Vector3, v2: Vector3): Vector3 {
    return rl.Vector3Add(v1, v2);
}
// 
export let Vector3AddValue(v: Vector3, add: Float64): Vector3 {
    return rl.Vector3AddValue(v, add);
}
// 
export let Vector3Subtract(v1: Vector3, v2: Vector3): Vector3 {
    return rl.Vector3Subtract(v1, v2);
}
// 
export let Vector3SubtractValue(v: Vector3, sub: Float64): Vector3 {
    return rl.Vector3SubtractValue(v, sub);
}
// 
export let Vector3Scale(v: Vector3, scalar: Float64): Vector3 {
    return rl.Vector3Scale(v, scalar);
}
// 
export let Vector3Multiply(v1: Vector3, v2: Vector3): Vector3 {
    return rl.Vector3Multiply(v1, v2);
}
// 
export let Vector3CrossProduct(v1: Vector3, v2: Vector3): Vector3 {
    return rl.Vector3CrossProduct(v1, v2);
}
// 
export let Vector3Perpendicular(v: Vector3): Vector3 {
    return rl.Vector3Perpendicular(v);
}
// 
export let Vector3Length(v: Vector3): Float64 {
    return rl.Vector3Length(v);
}
// 
export let Vector3LengthSqr(v: Vector3): Float64 {
    return rl.Vector3LengthSqr(v);
}
// 
export let Vector3DotProduct(v1: Vector3, v2: Vector3): Float64 {
    return rl.Vector3DotProduct(v1, v2);
}
// 
export let Vector3Distance(v1: Vector3, v2: Vector3): Float64 {
    return rl.Vector3Distance(v1, v2);
}
// 
export let Vector3DistanceSqr(v1: Vector3, v2: Vector3): Float64 {
    return rl.Vector3DistanceSqr(v1, v2);
}
// 
export let Vector3Angle(v1: Vector3, v2: Vector3): Float64 {
    return rl.Vector3Angle(v1, v2);
}
// 
export let Vector3Negate(v: Vector3): Vector3 {
    return rl.Vector3Negate(v);
}
// 
export let Vector3Divide(v1: Vector3, v2: Vector3): Vector3 {
    return rl.Vector3Divide(v1, v2);
}
// 
export let Vector3Normalize(v: Vector3): Vector3 {
    return rl.Vector3Normalize(v);
}
// 
export let Vector3Project(v1: Vector3, v2: Vector3): Vector3 {
    return rl.Vector3Project(v1, v2);
}
// 
export let Vector3Reject(v1: Vector3, v2: Vector3): Vector3 {
    return rl.Vector3Reject(v1, v2);
}
// 
export let Vector3OrthoNormalize(v1: Listed<Vector3>, v2: Listed<Vector3>): Void {
    rl.Vector3OrthoNormalize(v1, v2);
}
// 
export let Vector3Transform(v: Vector3, mat: Matrix): Vector3 {
    return rl.Vector3Transform(v, mat);
}
// 
export let Vector3RotateByQuaternion(v: Vector3, q: Quaternion): Vector3 {
    return rl.Vector3RotateByQuaternion(v, q);
}
// 
export let Vector3RotateByAxisAngle(v: Vector3, axis: Vector3, angle: Float64): Vector3 {
    return rl.Vector3RotateByAxisAngle(v, axis, angle);
}
// 
export let Vector3Lerp(v1: Vector3, v2: Vector3, amount: Float64): Vector3 {
    return rl.Vector3Lerp(v1, v2, amount);
}
// 
export let Vector3Reflect(v: Vector3, normal: Vector3): Vector3 {
    return rl.Vector3Reflect(v, normal);
}
// 
export let Vector3Min(v1: Vector3, v2: Vector3): Vector3 {
    return rl.Vector3Min(v1, v2);
}
// 
export let Vector3Max(v1: Vector3, v2: Vector3): Vector3 {
    return rl.Vector3Max(v1, v2);
}
// 
export let Vector3Barycenter(p: Vector3, a: Vector3, b: Vector3, c: Vector3): Vector3 {
    return rl.Vector3Barycenter(p, a, b, c);
}
// 
export let Vector3Unproject(source: Vector3, projection: Matrix, view: Matrix): Vector3 {
    return rl.Vector3Unproject(source, projection, view);
}
// 
export let Vector3ToFloatV(v: Vector3): float3 {
    return rl.Vector3ToFloatV(v);
}
// 
export let Vector3Invert(v: Vector3): Vector3 {
    return rl.Vector3Invert(v);
}
// 
export let Vector3Clamp(v: Vector3, min: Vector3, max: Vector3): Vector3 {
    return rl.Vector3Clamp(v, min, max);
}
// 
export let Vector3ClampValue(v: Vector3, min: Float64, max: Float64): Vector3 {
    return rl.Vector3ClampValue(v, min, max);
}
// 
export let Vector3Equals(p: Vector3, q: Vector3): Int {
    return rl.Vector3Equals(p, q);
}
// 
export let Vector3Refract(v: Vector3, n: Vector3, r: Float64): Vector3 {
    return rl.Vector3Refract(v, n, r);
}
// 
export let MatrixDeterminant(mat: Matrix): Float64 {
    return rl.MatrixDeterminant(mat);
}
// 
export let MatrixTrace(mat: Matrix): Float64 {
    return rl.MatrixTrace(mat);
}
// 
export let MatrixTranspose(mat: Matrix): Matrix {
    return rl.MatrixTranspose(mat);
}
// 
export let MatrixInvert(mat: Matrix): Matrix {
    return rl.MatrixInvert(mat);
}
// 
export let MatrixIdentity(): Matrix {
    return rl.MatrixIdentity();
}
// 
export let MatrixAdd(left: Matrix, right: Matrix): Matrix {
    return rl.MatrixAdd(left, right);
}
// 
export let MatrixSubtract(left: Matrix, right: Matrix): Matrix {
    return rl.MatrixSubtract(left, right);
}
// 
export let MatrixMultiply(left: Matrix, right: Matrix): Matrix {
    return rl.MatrixMultiply(left, right);
}
// 
export let MatrixTranslate(x: Float64, y: Float64, z: Float64): Matrix {
    return rl.MatrixTranslate(x, y, z);
}
// 
export let MatrixRotate(axis: Vector3, angle: Float64): Matrix {
    return rl.MatrixRotate(axis, angle);
}
// 
export let MatrixRotateX(angle: Float64): Matrix {
    return rl.MatrixRotateX(angle);
}
// 
export let MatrixRotateY(angle: Float64): Matrix {
    return rl.MatrixRotateY(angle);
}
// 
export let MatrixRotateZ(angle: Float64): Matrix {
    return rl.MatrixRotateZ(angle);
}
// 
export let MatrixRotateXYZ(angle: Vector3): Matrix {
    return rl.MatrixRotateXYZ(angle);
}
// 
export let MatrixRotateZYX(angle: Vector3): Matrix {
    return rl.MatrixRotateZYX(angle);
}
// 
export let MatrixScale(x: Float64, y: Float64, z: Float64): Matrix {
    return rl.MatrixScale(x, y, z);
}
// 
export let MatrixFrustum(left: Float64, right: Float64, bottom: Float64, top: Float64, near: Float64, far: Float64): Matrix {
    return rl.MatrixFrustum(left, right, bottom, top, near, far);
}
// 
export let MatrixPerspective(fovY: Float64, aspect: Float64, nearPlane: Float64, farPlane: Float64): Matrix {
    return rl.MatrixPerspective(fovY, aspect, nearPlane, farPlane);
}
// 
export let MatrixOrtho(left: Float64, right: Float64, bottom: Float64, top: Float64, nearPlane: Float64, farPlane: Float64): Matrix {
    return rl.MatrixOrtho(left, right, bottom, top, nearPlane, farPlane);
}
// 
export let MatrixLookAt(eye: Vector3, target: Vector3, up: Vector3): Matrix {
    return rl.MatrixLookAt(eye, target, up);
}
// 
export let MatrixToFloatV(mat: Matrix): float16 {
    return rl.MatrixToFloatV(mat);
}
// 
export let QuaternionAdd(q1: Quaternion, q2: Quaternion): Quaternion {
    return rl.QuaternionAdd(q1, q2);
}
// 
export let QuaternionAddValue(q: Quaternion, add: Float64): Quaternion {
    return rl.QuaternionAddValue(q, add);
}
// 
export let QuaternionSubtract(q1: Quaternion, q2: Quaternion): Quaternion {
    return rl.QuaternionSubtract(q1, q2);
}
// 
export let QuaternionSubtractValue(q: Quaternion, sub: Float64): Quaternion {
    return rl.QuaternionSubtractValue(q, sub);
}
// 
export let QuaternionIdentity(): Quaternion {
    return rl.QuaternionIdentity();
}
// 
export let QuaternionLength(q: Quaternion): Float64 {
    return rl.QuaternionLength(q);
}
// 
export let QuaternionNormalize(q: Quaternion): Quaternion {
    return rl.QuaternionNormalize(q);
}
// 
export let QuaternionInvert(q: Quaternion): Quaternion {
    return rl.QuaternionInvert(q);
}
// 
export let QuaternionMultiply(q1: Quaternion, q2: Quaternion): Quaternion {
    return rl.QuaternionMultiply(q1, q2);
}
// 
export let QuaternionScale(q: Quaternion, mul: Float64): Quaternion {
    return rl.QuaternionScale(q, mul);
}
// 
export let QuaternionDivide(q1: Quaternion, q2: Quaternion): Quaternion {
    return rl.QuaternionDivide(q1, q2);
}
// 
export let QuaternionLerp(q1: Quaternion, q2: Quaternion, amount: Float64): Quaternion {
    return rl.QuaternionLerp(q1, q2, amount);
}
// 
export let QuaternionNlerp(q1: Quaternion, q2: Quaternion, amount: Float64): Quaternion {
    return rl.QuaternionNlerp(q1, q2, amount);
}
// 
export let QuaternionSlerp(q1: Quaternion, q2: Quaternion, amount: Float64): Quaternion {
    return rl.QuaternionSlerp(q1, q2, amount);
}
// 
export let QuaternionFromVector3ToVector3(from: Vector3, to: Vector3): Quaternion {
    return rl.QuaternionFromVector3ToVector3(from, to);
}
// 
export let QuaternionFromMatrix(mat: Matrix): Quaternion {
    return rl.QuaternionFromMatrix(mat);
}
// 
export let QuaternionToMatrix(q: Quaternion): Matrix {
    return rl.QuaternionToMatrix(q);
}
// 
export let QuaternionFromAxisAngle(axis: Vector3, angle: Float64): Quaternion {
    return rl.QuaternionFromAxisAngle(axis, angle);
}
// 
export let QuaternionToAxisAngle(q: Quaternion, outAxis: Listed<Vector3>, outAngle: Listed<Float64>): Void {
    rl.QuaternionToAxisAngle(q, outAxis, outAngle);
}
// 
export let QuaternionFromEuler(pitch: Float64, yaw: Float64, roll: Float64): Quaternion {
    return rl.QuaternionFromEuler(pitch, yaw, roll);
}
// 
export let QuaternionToEuler(q: Quaternion): Vector3 {
    return rl.QuaternionToEuler(q);
}
// 
export let QuaternionTransform(q: Quaternion, mat: Matrix): Quaternion {
    return rl.QuaternionTransform(q, mat);
}
// 
export let QuaternionEquals(p: Quaternion, q: Quaternion): Int {
    return rl.QuaternionEquals(p, q);
}
// Choose the current matrix to be transformed
export let rlMatrixMode(mode: Int): Void {
    rl.rlMatrixMode(mode);
}
// Push the current matrix to stack
export let rlPushMatrix(): Void {
    rl.rlPushMatrix();
}
// Pop latest inserted matrix from stack
export let rlPopMatrix(): Void {
    rl.rlPopMatrix();
}
// Reset current matrix to identity matrix
export let rlLoadIdentity(): Void {
    rl.rlLoadIdentity();
}
// Multiply the current matrix by a translation matrix
export let rlTranslatef(x: Float64, y: Float64, z: Float64): Void {
    rl.rlTranslatef(x, y, z);
}
// Multiply the current matrix by a rotation matrix
export let rlRotatef(angle: Float64, x: Float64, y: Float64, z: Float64): Void {
    rl.rlRotatef(angle, x, y, z);
}
// Multiply the current matrix by a scaling matrix
export let rlScalef(x: Float64, y: Float64, z: Float64): Void {
    rl.rlScalef(x, y, z);
}
// Multiply the current matrix by another matrix
export let rlMultMatrixf(matf: Listed<Float64>): Void {
    rl.rlMultMatrixf(matf);
}
// 
export let rlFrustum(left: Float64, right: Float64, bottom: Float64, top: Float64, znear: Float64, zfar: Float64): Void {
    rl.rlFrustum(left, right, bottom, top, znear, zfar);
}
// 
export let rlOrtho(left: Float64, right: Float64, bottom: Float64, top: Float64, znear: Float64, zfar: Float64): Void {
    rl.rlOrtho(left, right, bottom, top, znear, zfar);
}
// Set the viewport area
export let rlViewport(x: Int, y: Int, width: Int, height: Int): Void {
    rl.rlViewport(x, y, width, height);
}
// Initialize drawing mode (how to organize vertex)
export let rlBegin(mode: Int): Void {
    rl.rlBegin(mode);
}
// Finish vertex providing
export let rlEnd(): Void {
    rl.rlEnd();
}
// Define one vertex (position) - 2 int
export let rlVertex2i(x: Int, y: Int): Void {
    rl.rlVertex2i(x, y);
}
// Define one vertex (position) - 2 float
export let rlVertex2f(x: Float64, y: Float64): Void {
    rl.rlVertex2f(x, y);
}
// Define one vertex (position) - 3 float
export let rlVertex3f(x: Float64, y: Float64, z: Float64): Void {
    rl.rlVertex3f(x, y, z);
}
// Define one vertex (texture coordinate) - 2 float
export let rlTexCoord2f(x: Float64, y: Float64): Void {
    rl.rlTexCoord2f(x, y);
}
// Define one vertex (normal) - 3 float
export let rlNormal3f(x: Float64, y: Float64, z: Float64): Void {
    rl.rlNormal3f(x, y, z);
}
// Define one vertex (color) - 4 byte
export let rlColor4ub(r: Int, g: Int, b: Int, a: Int): Void {
    rl.rlColor4ub(r, g, b, a);
}
// Define one vertex (color) - 3 float
export let rlColor3f(x: Float64, y: Float64, z: Float64): Void {
    rl.rlColor3f(x, y, z);
}
// Define one vertex (color) - 4 float
export let rlColor4f(x: Float64, y: Float64, z: Float64, w: Float64): Void {
    rl.rlColor4f(x, y, z, w);
}
// Enable vertex array (VAO, if supported)
export let rlEnableVertexArray(vaoId: Int): Boolean {
    return rl.rlEnableVertexArray(vaoId);
}
// Disable vertex array (VAO, if supported)
export let rlDisableVertexArray(): Void {
    rl.rlDisableVertexArray();
}
// Enable vertex buffer (VBO)
export let rlEnableVertexBuffer(id: Int): Void {
    rl.rlEnableVertexBuffer(id);
}
// Disable vertex buffer (VBO)
export let rlDisableVertexBuffer(): Void {
    rl.rlDisableVertexBuffer();
}
// Enable vertex buffer element (VBO element)
export let rlEnableVertexBufferElement(id: Int): Void {
    rl.rlEnableVertexBufferElement(id);
}
// Disable vertex buffer element (VBO element)
export let rlDisableVertexBufferElement(): Void {
    rl.rlDisableVertexBufferElement();
}
// Enable vertex attribute index
export let rlEnableVertexAttribute(index: Int): Void {
    rl.rlEnableVertexAttribute(index);
}
// Disable vertex attribute index
export let rlDisableVertexAttribute(index: Int): Void {
    rl.rlDisableVertexAttribute(index);
}
// Select and active a texture slot
export let rlActiveTextureSlot(slot: Int): Void {
    rl.rlActiveTextureSlot(slot);
}
// Enable texture
export let rlEnableTexture(id: Int): Void {
    rl.rlEnableTexture(id);
}
// Disable texture
export let rlDisableTexture(): Void {
    rl.rlDisableTexture();
}
// Enable texture cubemap
export let rlEnableTextureCubemap(id: Int): Void {
    rl.rlEnableTextureCubemap(id);
}
// Disable texture cubemap
export let rlDisableTextureCubemap(): Void {
    rl.rlDisableTextureCubemap();
}
// Set texture parameters (filter, wrap)
export let rlTextureParameters(id: Int, param: Int, value: Int): Void {
    rl.rlTextureParameters(id, param, value);
}
// Set cubemap parameters (filter, wrap)
export let rlCubemapParameters(id: Int, param: Int, value: Int): Void {
    rl.rlCubemapParameters(id, param, value);
}
// Enable shader program
export let rlEnableShader(id: Int): Void {
    rl.rlEnableShader(id);
}
// Disable shader program
export let rlDisableShader(): Void {
    rl.rlDisableShader();
}
// Enable render texture (fbo)
export let rlEnableFramebuffer(id: Int): Void {
    rl.rlEnableFramebuffer(id);
}
// Disable render texture (fbo), return to default framebuffer
export let rlDisableFramebuffer(): Void {
    rl.rlDisableFramebuffer();
}
// Activate multiple draw color buffers
export let rlActiveDrawBuffers(count: Int): Void {
    rl.rlActiveDrawBuffers(count);
}
// Blit active framebuffer to main framebuffer
export let rlBlitFramebuffer(srcX: Int, srcY: Int, srcWidth: Int, srcHeight: Int, dstX: Int, dstY: Int, dstWidth: Int, dstHeight: Int, bufferMask: Int): Void {
    rl.rlBlitFramebuffer(srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight, bufferMask);
}
// Bind framebuffer (FBO) 
export let rlBindFramebuffer(target: Int, framebuffer: Int): Void {
    rl.rlBindFramebuffer(target, framebuffer);
}
// Enable color blending
export let rlEnableColorBlend(): Void {
    rl.rlEnableColorBlend();
}
// Disable color blending
export let rlDisableColorBlend(): Void {
    rl.rlDisableColorBlend();
}
// Enable depth test
export let rlEnableDepthTest(): Void {
    rl.rlEnableDepthTest();
}
// Disable depth test
export let rlDisableDepthTest(): Void {
    rl.rlDisableDepthTest();
}
// Enable depth write
export let rlEnableDepthMask(): Void {
    rl.rlEnableDepthMask();
}
// Disable depth write
export let rlDisableDepthMask(): Void {
    rl.rlDisableDepthMask();
}
// Enable backface culling
export let rlEnableBackfaceCulling(): Void {
    rl.rlEnableBackfaceCulling();
}
// Disable backface culling
export let rlDisableBackfaceCulling(): Void {
    rl.rlDisableBackfaceCulling();
}
// Color mask control
export let rlColorMask(r: Boolean, g: Boolean, b: Boolean, a: Boolean): Void {
    rl.rlColorMask(r, g, b, a);
}
// Set face culling mode
export let rlSetCullFace(mode: Int): Void {
    rl.rlSetCullFace(mode);
}
// Enable scissor test
export let rlEnableScissorTest(): Void {
    rl.rlEnableScissorTest();
}
// Disable scissor test
export let rlDisableScissorTest(): Void {
    rl.rlDisableScissorTest();
}
// Scissor test
export let rlScissor(x: Int, y: Int, width: Int, height: Int): Void {
    rl.rlScissor(x, y, width, height);
}
// Enable wire mode
export let rlEnableWireMode(): Void {
    rl.rlEnableWireMode();
}
// Enable point mode
export let rlEnablePointMode(): Void {
    rl.rlEnablePointMode();
}
// Disable wire mode ( and point ) maybe rename
export let rlDisableWireMode(): Void {
    rl.rlDisableWireMode();
}
// Set the line drawing width
export let rlSetLineWidth(width: Float64): Void {
    rl.rlSetLineWidth(width);
}
// Get the line drawing width
export let rlGetLineWidth(): Float64 {
    return rl.rlGetLineWidth();
}
// Enable line aliasing
export let rlEnableSmoothLines(): Void {
    rl.rlEnableSmoothLines();
}
// Disable line aliasing
export let rlDisableSmoothLines(): Void {
    rl.rlDisableSmoothLines();
}
// Enable stereo rendering
export let rlEnableStereoRender(): Void {
    rl.rlEnableStereoRender();
}
// Disable stereo rendering
export let rlDisableStereoRender(): Void {
    rl.rlDisableStereoRender();
}
// Check if stereo render is enabled
export let rlIsStereoRenderEnabled(): Boolean {
    return rl.rlIsStereoRenderEnabled();
}
// Clear color buffer with color
export let rlClearColor(r: Int, g: Int, b: Int, a: Int): Void {
    rl.rlClearColor(r, g, b, a);
}
// Clear used screen buffers (color and depth)
export let rlClearScreenBuffers(): Void {
    rl.rlClearScreenBuffers();
}
// Check and log OpenGL error codes
export let rlCheckErrors(): Void {
    rl.rlCheckErrors();
}
// Set blending mode
export let rlSetBlendMode(mode: Int): Void {
    rl.rlSetBlendMode(mode);
}
// Set blending mode factor and equation (using OpenGL factors)
export let rlSetBlendFactors(glSrcFactor: Int, glDstFactor: Int, glEquation: Int): Void {
    rl.rlSetBlendFactors(glSrcFactor, glDstFactor, glEquation);
}
// Set blending mode factors and equations separately (using OpenGL factors)
export let rlSetBlendFactorsSeparate(glSrcRGB: Int, glDstRGB: Int, glSrcAlpha: Int, glDstAlpha: Int, glEqRGB: Int, glEqAlpha: Int): Void {
    rl.rlSetBlendFactorsSeparate(glSrcRGB, glDstRGB, glSrcAlpha, glDstAlpha, glEqRGB, glEqAlpha);
}
// Initialize rlgl (buffers, shaders, textures, states)
export let rlglInit(width: Int, height: Int): Void {
    rl.rlglInit(width, height);
}
// De-initialize rlgl (buffers, shaders, textures)
export let rlglClose(): Void {
    rl.rlglClose();
}
// Load OpenGL extensions (loader function required)
export let rlLoadExtensions(loader: DenseBitVector): Void {
    rl.rlLoadExtensions(loader);
}
// Get current OpenGL version
export let rlGetVersion(): Int {
    return rl.rlGetVersion();
}
// Set current framebuffer width
export let rlSetFramebufferWidth(width: Int): Void {
    rl.rlSetFramebufferWidth(width);
}
// Get default framebuffer width
export let rlGetFramebufferWidth(): Int {
    return rl.rlGetFramebufferWidth();
}
// Set current framebuffer height
export let rlSetFramebufferHeight(height: Int): Void {
    rl.rlSetFramebufferHeight(height);
}
// Get default framebuffer height
export let rlGetFramebufferHeight(): Int {
    return rl.rlGetFramebufferHeight();
}
// Get default texture id
export let rlGetTextureIdDefault(): Int {
    return rl.rlGetTextureIdDefault();
}
// Get default shader id
export let rlGetShaderIdDefault(): Int {
    return rl.rlGetShaderIdDefault();
}
// Get default shader locations
export let rlGetShaderLocsDefault(): Listed<Int> {
    return rl.rlGetShaderLocsDefault();
}
// Load a render batch system
export let rlLoadRenderBatch(numBuffers: Int, bufferElements: Int): rlRenderBatch {
    return rl.rlLoadRenderBatch(numBuffers, bufferElements);
}
// Unload render batch system
export let rlUnloadRenderBatch(batch: rlRenderBatch): Void {
    rl.rlUnloadRenderBatch(batch);
}
// Draw render batch data (Update->Draw->Reset)
export let rlDrawRenderBatch(batch: Listed<rlRenderBatch>): Void {
    rl.rlDrawRenderBatch(batch);
}
// Set the active render batch for rlgl (NULL for default internal)
export let rlSetRenderBatchActive(batch: Listed<rlRenderBatch>): Void {
    rl.rlSetRenderBatchActive(batch);
}
// Update and draw internal render batch
export let rlDrawRenderBatchActive(): Void {
    rl.rlDrawRenderBatchActive();
}
// Check internal buffer overflow for a given number of vertex
export let rlCheckRenderBatchLimit(vCount: Int): Boolean {
    return rl.rlCheckRenderBatchLimit(vCount);
}
// Set current texture for render batch and check buffers limits
export let rlSetTexture(id: Int): Void {
    rl.rlSetTexture(id);
}
// Load vertex array (vao) if supported
export let rlLoadVertexArray(): Int {
    return rl.rlLoadVertexArray();
}
// Load a vertex buffer object
export let rlLoadVertexBuffer(buffer: DenseBitVector, size: Int, dynamic: Boolean): Int {
    return rl.rlLoadVertexBuffer(buffer, size, dynamic);
}
// Load vertex buffer elements object
export let rlLoadVertexBufferElement(buffer: DenseBitVector, size: Int, dynamic: Boolean): Int {
    return rl.rlLoadVertexBufferElement(buffer, size, dynamic);
}
// Update vertex buffer object data on GPU buffer
export let rlUpdateVertexBuffer(bufferId: Int, data: DenseBitVector, dataSize: Int, offset: Int): Void {
    rl.rlUpdateVertexBuffer(bufferId, data, dataSize, offset);
}
// Update vertex buffer elements data on GPU buffer
export let rlUpdateVertexBufferElements(id: Int, data: DenseBitVector, dataSize: Int, offset: Int): Void {
    rl.rlUpdateVertexBufferElements(id, data, dataSize, offset);
}
// Unload vertex array (vao)
export let rlUnloadVertexArray(vaoId: Int): Void {
    rl.rlUnloadVertexArray(vaoId);
}
// Unload vertex buffer object
export let rlUnloadVertexBuffer(vboId: Int): Void {
    rl.rlUnloadVertexBuffer(vboId);
}
// Set vertex attribute data configuration
export let rlSetVertexAttribute(index: Int, compSize: Int, type: Int, normalized: Boolean, stride: Int, pointer: DenseBitVector): Void {
    rl.rlSetVertexAttribute(index, compSize, type, normalized, stride, pointer);
}
// Set vertex attribute data divisor
export let rlSetVertexAttributeDivisor(index: Int, divisor: Int): Void {
    rl.rlSetVertexAttributeDivisor(index, divisor);
}
// Set vertex attribute default value, when attribute to provided
export let rlSetVertexAttributeDefault(locIndex: Int, value: DenseBitVector, attribType: Int, count: Int): Void {
    rl.rlSetVertexAttributeDefault(locIndex, value, attribType, count);
}
// Draw vertex array (currently active vao)
export let rlDrawVertexArray(offset: Int, count: Int): Void {
    rl.rlDrawVertexArray(offset, count);
}
// Draw vertex array elements
export let rlDrawVertexArrayElements(offset: Int, count: Int, buffer: DenseBitVector): Void {
    rl.rlDrawVertexArrayElements(offset, count, buffer);
}
// Draw vertex array (currently active vao) with instancing
export let rlDrawVertexArrayInstanced(offset: Int, count: Int, instances: Int): Void {
    rl.rlDrawVertexArrayInstanced(offset, count, instances);
}
// Draw vertex array elements with instancing
export let rlDrawVertexArrayElementsInstanced(offset: Int, count: Int, buffer: DenseBitVector, instances: Int): Void {
    rl.rlDrawVertexArrayElementsInstanced(offset, count, buffer, instances);
}
// Load texture data
export let rlLoadTexture(data: DenseBitVector, width: Int, height: Int, format: Int, mipmapCount: Int): Int {
    return rl.rlLoadTexture(data, width, height, format, mipmapCount);
}
// Load depth texture/renderbuffer (to be attached to fbo)
export let rlLoadTextureDepth(width: Int, height: Int, useRenderBuffer: Boolean): Int {
    return rl.rlLoadTextureDepth(width, height, useRenderBuffer);
}
// Load texture cubemap data
export let rlLoadTextureCubemap(data: DenseBitVector, size: Int, format: Int): Int {
    return rl.rlLoadTextureCubemap(data, size, format);
}
// Update texture with new data on GPU
export let rlUpdateTexture(id: Int, offsetX: Int, offsetY: Int, width: Int, height: Int, format: Int, data: DenseBitVector): Void {
    rl.rlUpdateTexture(id, offsetX, offsetY, width, height, format, data);
}
// Get OpenGL internal formats
export let rlGetGlTextureFormats(format: Int, glInternalFormat: Listed<Int>, glFormat: Listed<Int>, glType: Listed<Int>): Void {
    rl.rlGetGlTextureFormats(format, glInternalFormat, glFormat, glType);
}
// Get name string for pixel format
export let rlGetPixelFormatName(format: Int): String {
    return rl.rlGetPixelFormatName(format);
}
// Unload texture from GPU memory
export let rlUnloadTexture(id: Int): Void {
    rl.rlUnloadTexture(id);
}
// Generate mipmap data for selected texture
export let rlGenTextureMipmaps(id: Int, width: Int, height: Int, format: Int, mipmaps: Listed<Int>): Void {
    rl.rlGenTextureMipmaps(id, width, height, format, mipmaps);
}
// Read texture pixel data
export let rlReadTexturePixels(id: Int, width: Int, height: Int, format: Int): DenseBitVector {
    return rl.rlReadTexturePixels(id, width, height, format);
}
// Read screen pixel data (color buffer)
export let rlReadScreenPixels(width: Int, height: Int): Listed<Int> {
    return rl.rlReadScreenPixels(width, height);
}
// Load an empty framebuffer
export let rlLoadFramebuffer(width: Int, height: Int): Int {
    return rl.rlLoadFramebuffer(width, height);
}
// Attach texture/renderbuffer to a framebuffer
export let rlFramebufferAttach(fboId: Int, texId: Int, attachType: Int, texType: Int, mipLevel: Int): Void {
    rl.rlFramebufferAttach(fboId, texId, attachType, texType, mipLevel);
}
// Verify framebuffer is complete
export let rlFramebufferComplete(id: Int): Boolean {
    return rl.rlFramebufferComplete(id);
}
// Delete framebuffer from GPU
export let rlUnloadFramebuffer(id: Int): Void {
    rl.rlUnloadFramebuffer(id);
}
// Load shader from code strings
export let rlLoadShaderCode(vsCode: String, fsCode: String): Int {
    return rl.rlLoadShaderCode(vsCode, fsCode);
}
// Compile custom shader and return shader id (type: RL_VERTEX_SHADER, RL_FRAGMENT_SHADER, RL_COMPUTE_SHADER)
export let rlCompileShader(shaderCode: String, type: Int): Int {
    return rl.rlCompileShader(shaderCode, type);
}
// Load custom shader program
export let rlLoadShaderProgram(vShaderId: Int, fShaderId: Int): Int {
    return rl.rlLoadShaderProgram(vShaderId, fShaderId);
}
// Unload shader program
export let rlUnloadShaderProgram(id: Int): Void {
    rl.rlUnloadShaderProgram(id);
}
// Get shader location uniform
export let rlGetLocationUniform(shaderId: Int, uniformName: String): Int {
    return rl.rlGetLocationUniform(shaderId, uniformName);
}
// Get shader location attribute
export let rlGetLocationAttrib(shaderId: Int, attribName: String): Int {
    return rl.rlGetLocationAttrib(shaderId, attribName);
}
// Set shader value uniform
export let rlSetUniform(locIndex: Int, value: DenseBitVector, uniformType: Int, count: Int): Void {
    rl.rlSetUniform(locIndex, value, uniformType, count);
}
// Set shader value matrix
export let rlSetUniformMatrix(locIndex: Int, mat: Matrix): Void {
    rl.rlSetUniformMatrix(locIndex, mat);
}
// Set shader value sampler
export let rlSetUniformSampler(locIndex: Int, textureId: Int): Void {
    rl.rlSetUniformSampler(locIndex, textureId);
}
// Set shader currently active (id and locations)
export let rlSetShader(id: Int, locs: Listed<Int>): Void {
    rl.rlSetShader(id, locs);
}
// Load compute shader program
export let rlLoadComputeShaderProgram(shaderId: Int): Int {
    return rl.rlLoadComputeShaderProgram(shaderId);
}
// Dispatch compute shader (equivalent to *draw* for graphics pipeline)
export let rlComputeShaderDispatch(groupX: Int, groupY: Int, groupZ: Int): Void {
    rl.rlComputeShaderDispatch(groupX, groupY, groupZ);
}
// Load shader storage buffer object (SSBO)
export let rlLoadShaderBuffer(size: Int, data: DenseBitVector, usageHint: Int): Int {
    return rl.rlLoadShaderBuffer(size, data, usageHint);
}
// Unload shader storage buffer object (SSBO)
export let rlUnloadShaderBuffer(ssboId: Int): Void {
    rl.rlUnloadShaderBuffer(ssboId);
}
// Update SSBO buffer data
export let rlUpdateShaderBuffer(id: Int, data: DenseBitVector, dataSize: Int, offset: Int): Void {
    rl.rlUpdateShaderBuffer(id, data, dataSize, offset);
}
// Bind SSBO buffer
export let rlBindShaderBuffer(id: Int, index: Int): Void {
    rl.rlBindShaderBuffer(id, index);
}
// Read SSBO buffer data (GPU->CPU)
export let rlReadShaderBuffer(id: Int, dest: DenseBitVector, count: Int, offset: Int): Void {
    rl.rlReadShaderBuffer(id, dest, count, offset);
}
// Copy SSBO data between buffers
export let rlCopyShaderBuffer(destId: Int, srcId: Int, destOffset: Int, srcOffset: Int, count: Int): Void {
    rl.rlCopyShaderBuffer(destId, srcId, destOffset, srcOffset, count);
}
// Get SSBO buffer size
export let rlGetShaderBufferSize(id: Int): Int {
    return rl.rlGetShaderBufferSize(id);
}
// Bind image texture
export let rlBindImageTexture(id: Int, index: Int, format: Int, readonly: Boolean): Void {
    rl.rlBindImageTexture(id, index, format, readonly);
}
// Get internal modelview matrix
export let rlGetMatrixModelview(): Matrix {
    return rl.rlGetMatrixModelview();
}
// Get internal projection matrix
export let rlGetMatrixProjection(): Matrix {
    return rl.rlGetMatrixProjection();
}
// Get internal accumulated transform matrix
export let rlGetMatrixTransform(): Matrix {
    return rl.rlGetMatrixTransform();
}
// Get internal projection matrix for stereo render (selected eye)
export let rlGetMatrixProjectionStereo(eye: Int): Matrix {
    return rl.rlGetMatrixProjectionStereo(eye);
}
// Get internal view offset matrix for stereo render (selected eye)
export let rlGetMatrixViewOffsetStereo(eye: Int): Matrix {
    return rl.rlGetMatrixViewOffsetStereo(eye);
}
// Set a custom projection matrix (replaces internal projection matrix)
export let rlSetMatrixProjection(proj: Matrix): Void {
    rl.rlSetMatrixProjection(proj);
}
// Set a custom modelview matrix (replaces internal modelview matrix)
export let rlSetMatrixModelview(view: Matrix): Void {
    rl.rlSetMatrixModelview(view);
}
// Set eyes projection matrices for stereo rendering
export let rlSetMatrixProjectionStereo(right: Matrix, left: Matrix): Void {
    rl.rlSetMatrixProjectionStereo(right, left);
}
// Set eyes view offsets matrices for stereo rendering
export let rlSetMatrixViewOffsetStereo(right: Matrix, left: Matrix): Void {
    rl.rlSetMatrixViewOffsetStereo(right, left);
}
// Load and draw a cube
export let rlLoadDrawCube(): Void {
    rl.rlLoadDrawCube();
}
// Load and draw a quad
export let rlLoadDrawQuad(): Void {
    rl.rlLoadDrawQuad();
}

export let SUPPORT_MODULE_RSHAPES: Int = 1;
export let SUPPORT_MODULE_RTEXTURES: Int = 1;
export let SUPPORT_MODULE_RTEXT: Int = 1;
export let SUPPORT_MODULE_RMODELS: Int = 1;
export let SUPPORT_MODULE_RAUDIO: Int = 1;
export let SUPPORT_CAMERA_SYSTEM: Int = 1;
export let SUPPORT_GESTURES_SYSTEM: Int = 1;
export let SUPPORT_RPRAND_GENERATOR: Int = 1;
export let SUPPORT_MOUSE_GESTURES: Int = 1;
export let SUPPORT_SSH_KEYBOARD_RPI: Int = 1;
export let SUPPORT_WINMM_HIGHRES_TIMER: Int = 1;
export let SUPPORT_PARTIALBUSY_WAIT_LOOP: Int = 1;
export let SUPPORT_SCREEN_CAPTURE: Int = 1;
export let SUPPORT_GIF_RECORDING: Int = 1;
export let SUPPORT_COMPRESSION_API: Int = 1;
export let SUPPORT_AUTOMATION_EVENTS: Int = 1;
export let MAX_FILEPATH_CAPACITY: Int = 8192;
export let MAX_FILEPATH_LENGTH: Int = 4096;
export let MAX_KEYBOARD_KEYS: Int = 512;
export let MAX_MOUSE_BUTTONS: Int = 8;
export let MAX_GAMEPADS: Int = 4;
export let MAX_GAMEPAD_AXIS: Int = 8;
export let MAX_GAMEPAD_BUTTONS: Int = 32;
export let MAX_TOUCH_POINTS: Int = 8;
export let MAX_KEY_PRESSED_QUEUE: Int = 16;
export let MAX_CHAR_PRESSED_QUEUE: Int = 16;
export let MAX_DECOMPRESSION_SIZE: Int = 64;
export let MAX_AUTOMATION_EVENTS: Int = 16384;
export let RL_DEFAULT_BATCH_BUFFERS: Int = 1;
export let RL_DEFAULT_BATCH_DRAWCALLS: Int = 256;
export let RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS: Int = 4;
export let RL_MAX_MATRIX_STACK_SIZE: Int = 32;
export let RL_MAX_SHADER_LOCATIONS: Int = 32;
export let RL_CULL_DISTANCE_NEAR: Float64 = 0.01;
export let RL_CULL_DISTANCE_FAR: Float64 = 1000.0;
export let RL_DEFAULT_SHADER_ATTRIB_NAME_POSITION: String = "vertexPosition";
export let RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD: String = "vertexTexCoord";
export let RL_DEFAULT_SHADER_ATTRIB_NAME_NORMAL: String = "vertexNormal";
export let RL_DEFAULT_SHADER_ATTRIB_NAME_COLOR: String = "vertexColor";
export let RL_DEFAULT_SHADER_ATTRIB_NAME_TANGENT: String = "vertexTangent";
export let RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD2: String = "vertexTexCoord2";
export let RL_DEFAULT_SHADER_UNIFORM_NAME_MVP: String = "mvp";
export let RL_DEFAULT_SHADER_UNIFORM_NAME_VIEW: String = "matView";
export let RL_DEFAULT_SHADER_UNIFORM_NAME_PROJECTION: String = "matProjection";
export let RL_DEFAULT_SHADER_UNIFORM_NAME_MODEL: String = "matModel";
export let RL_DEFAULT_SHADER_UNIFORM_NAME_NORMAL: String = "matNormal";
export let RL_DEFAULT_SHADER_UNIFORM_NAME_COLOR: String = "colDiffuse";
export let RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE0: String = "texture0";
export let RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE1: String = "texture1";
export let RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE2: String = "texture2";
export let SUPPORT_QUADS_DRAW_MODE: Int = 1;
export let SPLINE_SEGMENT_DIVISIONS: Int = 24;
export let SUPPORT_FILEFORMAT_PNG: Int = 1;
export let SUPPORT_FILEFORMAT_GIF: Int = 1;
export let SUPPORT_FILEFORMAT_QOI: Int = 1;
export let SUPPORT_FILEFORMAT_DDS: Int = 1;
export let SUPPORT_IMAGE_EXPORT: Int = 1;
export let SUPPORT_IMAGE_GENERATION: Int = 1;
export let SUPPORT_IMAGE_MANIPULATION: Int = 1;
export let SUPPORT_DEFAULT_FONT: Int = 1;
export let SUPPORT_FILEFORMAT_FNT: Int = 1;
export let SUPPORT_FILEFORMAT_TTF: Int = 1;
export let SUPPORT_TEXT_MANIPULATION: Int = 1;
export let SUPPORT_FONT_ATLAS_WHITE_REC: Int = 1;
export let MAX_TEXT_BUFFER_LENGTH: Int = 1024;
export let MAX_TEXTSPLIT_COUNT: Int = 128;
export let SUPPORT_FILEFORMAT_OBJ: Int = 1;
export let SUPPORT_FILEFORMAT_MTL: Int = 1;
export let SUPPORT_FILEFORMAT_IQM: Int = 1;
export let SUPPORT_FILEFORMAT_GLTF: Int = 1;
export let SUPPORT_FILEFORMAT_VOX: Int = 1;
export let SUPPORT_FILEFORMAT_M3D: Int = 1;
export let SUPPORT_MESH_GENERATION: Int = 1;
export let MAX_MATERIAL_MAPS: Int = 12;
export let MAX_MESH_VERTEX_BUFFERS: Int = 7;
export let SUPPORT_FILEFORMAT_WAV: Int = 1;
export let SUPPORT_FILEFORMAT_OGG: Int = 1;
export let SUPPORT_FILEFORMAT_MP3: Int = 1;
export let SUPPORT_FILEFORMAT_QOA: Int = 1;
export let SUPPORT_FILEFORMAT_XM: Int = 1;
export let SUPPORT_FILEFORMAT_MOD: Int = 1;
export let AUDIO_DEVICE_CHANNELS: Int = 2;
export let AUDIO_DEVICE_SAMPLE_RATE: Int = 0;
export let MAX_AUDIO_BUFFER_POOL_CHANNELS: Int = 16;
export let SUPPORT_STANDARD_FILEIO: Int = 1;
export let SUPPORT_TRACELOG: Int = 1;
export let MAX_TRACELOG_MSG_LENGTH: Int = 256;
export let RAYGUI_VERSION_MAJOR: Int = 4;
export let RAYGUI_VERSION_MINOR: Int = 0;
export let RAYGUI_VERSION_PATCH: Int = 0;
export let RAYGUI_VERSION: String = "4.0";
export let SCROLLBAR_LEFT_SIDE: Int = 0;
export let SCROLLBAR_RIGHT_SIDE: Int = 1;
export let RAYLIB_VERSION_MAJOR: Int = 5;
export let RAYLIB_VERSION_MINOR: Int = 1;
export let RAYLIB_VERSION_PATCH: Int = 0;
export let RAYLIB_VERSION: String = "5.1-dev";
export let PI: Float64 = 3.141592653589793;
export let LIGHTGRAY: Color = new Color(200, 200, 200, 255);
export let GRAY: Color = new Color(130, 130, 130, 255);
export let DARKGRAY: Color = new Color(80, 80, 80, 255);
export let YELLOW: Color = new Color(253, 249, 0, 255);
export let GOLD: Color = new Color(255, 203, 0, 255);
export let ORANGE: Color = new Color(255, 161, 0, 255);
export let PINK: Color = new Color(255, 109, 194, 255);
export let RED: Color = new Color(230, 41, 55, 255);
export let MAROON: Color = new Color(190, 33, 55, 255);
export let GREEN: Color = new Color(0, 228, 48, 255);
export let LIME: Color = new Color(0, 158, 47, 255);
export let DARKGREEN: Color = new Color(0, 117, 44, 255);
export let SKYBLUE: Color = new Color(102, 191, 255, 255);
export let BLUE: Color = new Color(0, 121, 241, 255);
export let DARKBLUE: Color = new Color(0, 82, 172, 255);
export let PURPLE: Color = new Color(200, 122, 255, 255);
export let VIOLET: Color = new Color(135, 60, 190, 255);
export let DARKPURPLE: Color = new Color(112, 31, 126, 255);
export let BEIGE: Color = new Color(211, 176, 131, 255);
export let BROWN: Color = new Color(127, 106, 79, 255);
export let DARKBROWN: Color = new Color(76, 63, 47, 255);
export let WHITE: Color = new Color(255, 255, 255, 255);
export let BLACK: Color = new Color(0, 0, 0, 255);
export let BLANK: Color = new Color(0, 0, 0, 0);
export let MAGENTA: Color = new Color(255, 0, 255, 255);
export let RAYWHITE: Color = new Color(245, 245, 245, 255);
export let EPSILON: Float64 = 1e-06;
export let RLGL_VERSION: String = "4.5";
export let RL_TEXTURE_WRAP_S: Int = 10242;
export let RL_TEXTURE_WRAP_T: Int = 10243;
export let RL_TEXTURE_MAG_FILTER: Int = 10240;
export let RL_TEXTURE_MIN_FILTER: Int = 10241;
export let RL_TEXTURE_FILTER_NEAREST: Int = 9728;
export let RL_TEXTURE_FILTER_LINEAR: Int = 9729;
export let RL_TEXTURE_FILTER_MIP_NEAREST: Int = 9984;
export let RL_TEXTURE_FILTER_NEAREST_MIP_LINEAR: Int = 9986;
export let RL_TEXTURE_FILTER_LINEAR_MIP_NEAREST: Int = 9985;
export let RL_TEXTURE_FILTER_MIP_LINEAR: Int = 9987;
export let RL_TEXTURE_FILTER_ANISOTROPIC: Int = 12288;
export let RL_TEXTURE_MIPMAP_BIAS_RATIO: Int = 16384;
export let RL_TEXTURE_WRAP_REPEAT: Int = 10497;
export let RL_TEXTURE_WRAP_CLAMP: Int = 33071;
export let RL_TEXTURE_WRAP_MIRROR_REPEAT: Int = 33648;
export let RL_TEXTURE_WRAP_MIRROR_CLAMP: Int = 34626;
export let RL_MODELVIEW: Int = 5888;
export let RL_PROJECTION: Int = 5889;
export let RL_TEXTURE: Int = 5890;
export let RL_LINES: Int = 1;
export let RL_TRIANGLES: Int = 4;
export let RL_QUADS: Int = 7;
export let RL_UNSIGNED_BYTE: Int = 5121;
export let RL_FLOAT: Int = 5126;
export let RL_STREAM_DRAW: Int = 35040;
export let RL_STREAM_READ: Int = 35041;
export let RL_STREAM_COPY: Int = 35042;
export let RL_STATIC_DRAW: Int = 35044;
export let RL_STATIC_READ: Int = 35045;
export let RL_STATIC_COPY: Int = 35046;
export let RL_DYNAMIC_DRAW: Int = 35048;
export let RL_DYNAMIC_READ: Int = 35049;
export let RL_DYNAMIC_COPY: Int = 35050;
export let RL_FRAGMENT_SHADER: Int = 35632;
export let RL_VERTEX_SHADER: Int = 35633;
export let RL_COMPUTE_SHADER: Int = 37305;
export let RL_ZERO: Int = 0;
export let RL_ONE: Int = 1;
export let RL_SRC_COLOR: Int = 768;
export let RL_ONE_MINUS_SRC_COLOR: Int = 769;
export let RL_SRC_ALPHA: Int = 770;
export let RL_ONE_MINUS_SRC_ALPHA: Int = 771;
export let RL_DST_ALPHA: Int = 772;
export let RL_ONE_MINUS_DST_ALPHA: Int = 773;
export let RL_DST_COLOR: Int = 774;
export let RL_ONE_MINUS_DST_COLOR: Int = 775;
export let RL_SRC_ALPHA_SATURATE: Int = 776;
export let RL_CONSTANT_COLOR: Int = 32769;
export let RL_ONE_MINUS_CONSTANT_COLOR: Int = 32770;
export let RL_CONSTANT_ALPHA: Int = 32771;
export let RL_ONE_MINUS_CONSTANT_ALPHA: Int = 32772;
export let RL_FUNC_ADD: Int = 32774;
export let RL_MIN: Int = 32775;
export let RL_MAX: Int = 32776;
export let RL_FUNC_SUBTRACT: Int = 32778;
export let RL_FUNC_REVERSE_SUBTRACT: Int = 32779;
export let RL_BLEND_EQUATION: Int = 32777;
export let RL_BLEND_EQUATION_RGB: Int = 32777;
export let RL_BLEND_EQUATION_ALPHA: Int = 34877;
export let RL_BLEND_DST_RGB: Int = 32968;
export let RL_BLEND_SRC_RGB: Int = 32969;
export let RL_BLEND_DST_ALPHA: Int = 32970;
export let RL_BLEND_SRC_ALPHA: Int = 32971;
export let RL_BLEND_COLOR: Int = 32773;
export let RL_READ_FRAMEBUFFER: Int = 36008;
export let RL_DRAW_FRAMEBUFFER: Int = 36009;

// GuiState
export let STATE_NORMAL = 0; // 
export let STATE_FOCUSED = 1; // 
export let STATE_PRESSED = 2; // 
export let STATE_DISABLED = 3; // 

// GuiTextAlignment
export let TEXT_ALIGN_LEFT = 0; // 
export let TEXT_ALIGN_CENTER = 1; // 
export let TEXT_ALIGN_RIGHT = 2; // 

// GuiTextAlignmentVertical
export let TEXT_ALIGN_TOP = 0; // 
export let TEXT_ALIGN_MIDDLE = 1; // 
export let TEXT_ALIGN_BOTTOM = 2; // 

// GuiTextWrapMode
export let TEXT_WRAP_NONE = 0; // 
export let TEXT_WRAP_CHAR = 1; // 
export let TEXT_WRAP_WORD = 2; // 

// GuiControl
export let DEFAULT = 0; // 
export let LABEL = 1; // Used also for: LABELBUTTON
export let BUTTON = 2; // 
export let TOGGLE = 3; // Used also for: TOGGLEGROUP
export let SLIDER = 4; // Used also for: SLIDERBAR, TOGGLESLIDER
export let PROGRESSBAR = 5; // 
export let CHECKBOX = 6; // 
export let COMBOBOX = 7; // 
export let DROPDOWNBOX = 8; // 
export let TEXTBOX = 9; // Used also for: TEXTBOXMULTI
export let VALUEBOX = 10; // 
export let SPINNER = 11; // Uses: BUTTON, VALUEBOX
export let LISTVIEW = 12; // 
export let COLORPICKER = 13; // 
export let SCROLLBAR = 14; // 
export let STATUSBAR = 15; // 

// GuiControlProperty
export let BORDER_COLOR_NORMAL = 0; // Control border color in STATE_NORMAL
export let BASE_COLOR_NORMAL = 1; // Control base color in STATE_NORMAL
export let TEXT_COLOR_NORMAL = 2; // Control text color in STATE_NORMAL
export let BORDER_COLOR_FOCUSED = 3; // Control border color in STATE_FOCUSED
export let BASE_COLOR_FOCUSED = 4; // Control base color in STATE_FOCUSED
export let TEXT_COLOR_FOCUSED = 5; // Control text color in STATE_FOCUSED
export let BORDER_COLOR_PRESSED = 6; // Control border color in STATE_PRESSED
export let BASE_COLOR_PRESSED = 7; // Control base color in STATE_PRESSED
export let TEXT_COLOR_PRESSED = 8; // Control text color in STATE_PRESSED
export let BORDER_COLOR_DISABLED = 9; // Control border color in STATE_DISABLED
export let BASE_COLOR_DISABLED = 10; // Control base color in STATE_DISABLED
export let TEXT_COLOR_DISABLED = 11; // Control text color in STATE_DISABLED
export let BORDER_WIDTH = 12; // Control border size, 0 for no border
export let TEXT_PADDING = 13; // Control text padding, not considering border
export let TEXT_ALIGNMENT = 14; // Control text horizontal alignment inside control text bound (after border and padding)

// GuiDefaultProperty
export let TEXT_SIZE = 16; // Text size (glyphs max height)
export let TEXT_SPACING = 17; // Text spacing between glyphs
export let LINE_COLOR = 18; // Line control color
export let BACKGROUND_COLOR = 19; // Background color
export let TEXT_LINE_SPACING = 20; // Text spacing between lines
export let TEXT_ALIGNMENT_VERTICAL = 21; // Text vertical alignment inside text bounds (after border and padding)
export let TEXT_WRAP_MODE = 22; // Text wrap-mode inside text bounds

// GuiToggleProperty
export let GROUP_PADDING = 16; // ToggleGroup separation between toggles

// GuiSliderProperty
export let SLIDER_WIDTH = 16; // Slider size of internal bar
export let SLIDER_PADDING = 17; // Slider/SliderBar internal bar padding

// GuiProgressBarProperty
export let PROGRESS_PADDING = 16; // ProgressBar internal padding

// GuiScrollBarProperty
export let ARROWS_SIZE = 16; // ScrollBar arrows size
export let ARROWS_VISIBLE = 17; // ScrollBar arrows visible
export let SCROLL_SLIDER_PADDING = 18; // ScrollBar slider internal padding
export let SCROLL_SLIDER_SIZE = 19; // ScrollBar slider size
export let SCROLL_PADDING = 20; // ScrollBar scroll padding from arrows
export let SCROLL_SPEED = 21; // ScrollBar scrolling speed

// GuiCheckBoxProperty
export let CHECK_PADDING = 16; // CheckBox internal check padding

// GuiComboBoxProperty
export let COMBO_BUTTON_WIDTH = 16; // ComboBox right button width
export let COMBO_BUTTON_SPACING = 17; // ComboBox button separation

// GuiDropdownBoxProperty
export let ARROW_PADDING = 16; // DropdownBox arrow separation from border and items
export let DROPDOWN_ITEMS_SPACING = 17; // DropdownBox items separation

// GuiTextBoxProperty
export let TEXT_READONLY = 16; // TextBox in read-only mode: 0-text editable, 1-text no-editable

// GuiSpinnerProperty
export let SPIN_BUTTON_WIDTH = 16; // Spinner left/right buttons width
export let SPIN_BUTTON_SPACING = 17; // Spinner buttons separation

// GuiListViewProperty
export let LIST_ITEMS_HEIGHT = 16; // ListView items height
export let LIST_ITEMS_SPACING = 17; // ListView items separation
export let SCROLLBAR_WIDTH = 18; // ListView scrollbar size (usually width)
export let SCROLLBAR_SIDE = 19; // ListView scrollbar side (0-SCROLLBAR_LEFT_SIDE, 1-SCROLLBAR_RIGHT_SIDE)

// GuiColorPickerProperty
export let COLOR_SELECTOR_SIZE = 16; // 
export let HUEBAR_WIDTH = 17; // ColorPicker right hue bar width
export let HUEBAR_PADDING = 18; // ColorPicker right hue bar separation from panel
export let HUEBAR_SELECTOR_HEIGHT = 19; // ColorPicker right hue bar selector height
export let HUEBAR_SELECTOR_OVERFLOW = 20; // ColorPicker right hue bar selector overflow

// ConfigFlags
export let FLAG_VSYNC_HINT = 64; // Set to try enabling V-Sync on GPU
export let FLAG_FULLSCREEN_MODE = 2; // Set to run program in fullscreen
export let FLAG_WINDOW_RESIZABLE = 4; // Set to allow resizable window
export let FLAG_WINDOW_UNDECORATED = 8; // Set to disable window decoration (frame and buttons)
export let FLAG_WINDOW_HIDDEN = 128; // Set to hide window
export let FLAG_WINDOW_MINIMIZED = 512; // Set to minimize window (iconify)
export let FLAG_WINDOW_MAXIMIZED = 1024; // Set to maximize window (expanded to monitor)
export let FLAG_WINDOW_UNFOCUSED = 2048; // Set to window non focused
export let FLAG_WINDOW_TOPMOST = 4096; // Set to window always on top
export let FLAG_WINDOW_ALWAYS_RUN = 256; // Set to allow windows running while minimized
export let FLAG_WINDOW_TRANSPARENT = 16; // Set to allow transparent framebuffer
export let FLAG_WINDOW_HIGHDPI = 8192; // Set to support HighDPI
export let FLAG_WINDOW_MOUSE_PASSTHROUGH = 16384; // Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED
export let FLAG_BORDERLESS_WINDOWED_MODE = 32768; // Set to run program in borderless windowed mode
export let FLAG_MSAA_4X_HINT = 32; // Set to try enabling MSAA 4X
export let FLAG_INTERLACED_HINT = 65536; // Set to try enabling interlaced video format (for V3D)

// TraceLogLevel
export let LOG_ALL = 0; // Display all logs
export let LOG_TRACE = 1; // Trace logging, intended for internal use only
export let LOG_DEBUG = 2; // Debug logging, used for internal debugging, it should be disabled on release builds
export let LOG_INFO = 3; // Info logging, used for program execution info
export let LOG_WARNING = 4; // Warning logging, used on recoverable failures
export let LOG_ERROR = 5; // Error logging, used on unrecoverable failures
export let LOG_FATAL = 6; // Fatal logging, used to abort program: exit(EXIT_FAILURE)
export let LOG_NONE = 7; // Disable logging

// KeyboardKey
export let KEY_NULL = 0; // Key: NULL, used for no key pressed
export let KEY_APOSTROPHE = 39; // Key: '
export let KEY_COMMA = 44; // Key: ,
export let KEY_MINUS = 45; // Key: -
export let KEY_PERIOD = 46; // Key: .
export let KEY_SLASH = 47; // Key: /
export let KEY_ZERO = 48; // Key: 0
export let KEY_ONE = 49; // Key: 1
export let KEY_TWO = 50; // Key: 2
export let KEY_THREE = 51; // Key: 3
export let KEY_FOUR = 52; // Key: 4
export let KEY_FIVE = 53; // Key: 5
export let KEY_SIX = 54; // Key: 6
export let KEY_SEVEN = 55; // Key: 7
export let KEY_EIGHT = 56; // Key: 8
export let KEY_NINE = 57; // Key: 9
export let KEY_SEMICOLON = 59; // Key: ;
export let KEY_EQUAL = 61; // Key: =
export let KEY_A = 65; // Key: A | a
export let KEY_B = 66; // Key: B | b
export let KEY_C = 67; // Key: C | c
export let KEY_D = 68; // Key: D | d
export let KEY_E = 69; // Key: E | e
export let KEY_F = 70; // Key: F | f
export let KEY_G = 71; // Key: G | g
export let KEY_H = 72; // Key: H | h
export let KEY_I = 73; // Key: I | i
export let KEY_J = 74; // Key: J | j
export let KEY_K = 75; // Key: K | k
export let KEY_L = 76; // Key: L | l
export let KEY_M = 77; // Key: M | m
export let KEY_N = 78; // Key: N | n
export let KEY_O = 79; // Key: O | o
export let KEY_P = 80; // Key: P | p
export let KEY_Q = 81; // Key: Q | q
export let KEY_R = 82; // Key: R | r
export let KEY_S = 83; // Key: S | s
export let KEY_T = 84; // Key: T | t
export let KEY_U = 85; // Key: U | u
export let KEY_V = 86; // Key: V | v
export let KEY_W = 87; // Key: W | w
export let KEY_X = 88; // Key: X | x
export let KEY_Y = 89; // Key: Y | y
export let KEY_Z = 90; // Key: Z | z
export let KEY_LEFT_BRACKET = 91; // Key: [
export let KEY_BACKSLASH = 92; // Key: '\'
export let KEY_RIGHT_BRACKET = 93; // Key: ]
export let KEY_GRAVE = 96; // Key: `
export let KEY_SPACE = 32; // Key: Space
export let KEY_ESCAPE = 256; // Key: Esc
export let KEY_ENTER = 257; // Key: Enter
export let KEY_TAB = 258; // Key: Tab
export let KEY_BACKSPACE = 259; // Key: Backspace
export let KEY_INSERT = 260; // Key: Ins
export let KEY_DELETE = 261; // Key: Del
export let KEY_RIGHT = 262; // Key: Cursor right
export let KEY_LEFT = 263; // Key: Cursor left
export let KEY_DOWN = 264; // Key: Cursor down
export let KEY_UP = 265; // Key: Cursor up
export let KEY_PAGE_UP = 266; // Key: Page up
export let KEY_PAGE_DOWN = 267; // Key: Page down
export let KEY_HOME = 268; // Key: Home
export let KEY_END = 269; // Key: End
export let KEY_CAPS_LOCK = 280; // Key: Caps lock
export let KEY_SCROLL_LOCK = 281; // Key: Scroll down
export let KEY_NUM_LOCK = 282; // Key: Num lock
export let KEY_PRINT_SCREEN = 283; // Key: Print screen
export let KEY_PAUSE = 284; // Key: Pause
export let KEY_F1 = 290; // Key: F1
export let KEY_F2 = 291; // Key: F2
export let KEY_F3 = 292; // Key: F3
export let KEY_F4 = 293; // Key: F4
export let KEY_F5 = 294; // Key: F5
export let KEY_F6 = 295; // Key: F6
export let KEY_F7 = 296; // Key: F7
export let KEY_F8 = 297; // Key: F8
export let KEY_F9 = 298; // Key: F9
export let KEY_F10 = 299; // Key: F10
export let KEY_F11 = 300; // Key: F11
export let KEY_F12 = 301; // Key: F12
export let KEY_LEFT_SHIFT = 340; // Key: Shift left
export let KEY_LEFT_CONTROL = 341; // Key: Control left
export let KEY_LEFT_ALT = 342; // Key: Alt left
export let KEY_LEFT_SUPER = 343; // Key: Super left
export let KEY_RIGHT_SHIFT = 344; // Key: Shift right
export let KEY_RIGHT_CONTROL = 345; // Key: Control right
export let KEY_RIGHT_ALT = 346; // Key: Alt right
export let KEY_RIGHT_SUPER = 347; // Key: Super right
export let KEY_KB_MENU = 348; // Key: KB menu
export let KEY_KP_0 = 320; // Key: Keypad 0
export let KEY_KP_1 = 321; // Key: Keypad 1
export let KEY_KP_2 = 322; // Key: Keypad 2
export let KEY_KP_3 = 323; // Key: Keypad 3
export let KEY_KP_4 = 324; // Key: Keypad 4
export let KEY_KP_5 = 325; // Key: Keypad 5
export let KEY_KP_6 = 326; // Key: Keypad 6
export let KEY_KP_7 = 327; // Key: Keypad 7
export let KEY_KP_8 = 328; // Key: Keypad 8
export let KEY_KP_9 = 329; // Key: Keypad 9
export let KEY_KP_DECIMAL = 330; // Key: Keypad .
export let KEY_KP_DIVIDE = 331; // Key: Keypad /
export let KEY_KP_MULTIPLY = 332; // Key: Keypad *
export let KEY_KP_SUBTRACT = 333; // Key: Keypad -
export let KEY_KP_ADD = 334; // Key: Keypad +
export let KEY_KP_ENTER = 335; // Key: Keypad Enter
export let KEY_KP_EQUAL = 336; // Key: Keypad =
export let KEY_BACK = 4; // Key: Android back button
export let KEY_MENU = 82; // Key: Android menu button
export let KEY_VOLUME_UP = 24; // Key: Android volume up button
export let KEY_VOLUME_DOWN = 25; // Key: Android volume down button

// MouseButton
export let MOUSE_BUTTON_LEFT = 0; // Mouse button left
export let MOUSE_BUTTON_RIGHT = 1; // Mouse button right
export let MOUSE_BUTTON_MIDDLE = 2; // Mouse button middle (pressed wheel)
export let MOUSE_BUTTON_SIDE = 3; // Mouse button side (advanced mouse device)
export let MOUSE_BUTTON_EXTRA = 4; // Mouse button extra (advanced mouse device)
export let MOUSE_BUTTON_FORWARD = 5; // Mouse button forward (advanced mouse device)
export let MOUSE_BUTTON_BACK = 6; // Mouse button back (advanced mouse device)

// MouseCursor
export let MOUSE_CURSOR_DEFAULT = 0; // Default pointer shape
export let MOUSE_CURSOR_ARROW = 1; // Arrow shape
export let MOUSE_CURSOR_IBEAM = 2; // Text writing cursor shape
export let MOUSE_CURSOR_CROSSHAIR = 3; // Cross shape
export let MOUSE_CURSOR_POINTING_HAND = 4; // Pointing hand cursor
export let MOUSE_CURSOR_RESIZE_EW = 5; // Horizontal resize/move arrow shape
export let MOUSE_CURSOR_RESIZE_NS = 6; // Vertical resize/move arrow shape
export let MOUSE_CURSOR_RESIZE_NWSE = 7; // Top-left to bottom-right diagonal resize/move arrow shape
export let MOUSE_CURSOR_RESIZE_NESW = 8; // The top-right to bottom-left diagonal resize/move arrow shape
export let MOUSE_CURSOR_RESIZE_ALL = 9; // The omnidirectional resize/move cursor shape
export let MOUSE_CURSOR_NOT_ALLOWED = 10; // The operation-not-allowed shape

// GamepadButton
export let GAMEPAD_BUTTON_UNKNOWN = 0; // Unknown button, just for error checking
export let GAMEPAD_BUTTON_LEFT_FACE_UP = 1; // Gamepad left DPAD up button
export let GAMEPAD_BUTTON_LEFT_FACE_RIGHT = 2; // Gamepad left DPAD right button
export let GAMEPAD_BUTTON_LEFT_FACE_DOWN = 3; // Gamepad left DPAD down button
export let GAMEPAD_BUTTON_LEFT_FACE_LEFT = 4; // Gamepad left DPAD left button
export let GAMEPAD_BUTTON_RIGHT_FACE_UP = 5; // Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
export let GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = 6; // Gamepad right button right (i.e. PS3: Square, Xbox: X)
export let GAMEPAD_BUTTON_RIGHT_FACE_DOWN = 7; // Gamepad right button down (i.e. PS3: Cross, Xbox: A)
export let GAMEPAD_BUTTON_RIGHT_FACE_LEFT = 8; // Gamepad right button left (i.e. PS3: Circle, Xbox: B)
export let GAMEPAD_BUTTON_LEFT_TRIGGER_1 = 9; // Gamepad top/back trigger left (first), it could be a trailing button
export let GAMEPAD_BUTTON_LEFT_TRIGGER_2 = 10; // Gamepad top/back trigger left (second), it could be a trailing button
export let GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = 11; // Gamepad top/back trigger right (one), it could be a trailing button
export let GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = 12; // Gamepad top/back trigger right (second), it could be a trailing button
export let GAMEPAD_BUTTON_MIDDLE_LEFT = 13; // Gamepad center buttons, left one (i.e. PS3: Select)
export let GAMEPAD_BUTTON_MIDDLE = 14; // Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
export let GAMEPAD_BUTTON_MIDDLE_RIGHT = 15; // Gamepad center buttons, right one (i.e. PS3: Start)
export let GAMEPAD_BUTTON_LEFT_THUMB = 16; // Gamepad joystick pressed button left
export let GAMEPAD_BUTTON_RIGHT_THUMB = 17; // Gamepad joystick pressed button right

// GamepadAxis
export let GAMEPAD_AXIS_LEFT_X = 0; // Gamepad left stick X axis
export let GAMEPAD_AXIS_LEFT_Y = 1; // Gamepad left stick Y axis
export let GAMEPAD_AXIS_RIGHT_X = 2; // Gamepad right stick X axis
export let GAMEPAD_AXIS_RIGHT_Y = 3; // Gamepad right stick Y axis
export let GAMEPAD_AXIS_LEFT_TRIGGER = 4; // Gamepad back trigger left, pressure level: [1..-1]
export let GAMEPAD_AXIS_RIGHT_TRIGGER = 5; // Gamepad back trigger right, pressure level: [1..-1]

// MaterialMapIndex
export let MATERIAL_MAP_ALBEDO = 0; // Albedo material (same as: MATERIAL_MAP_DIFFUSE)
export let MATERIAL_MAP_METALNESS = 1; // Metalness material (same as: MATERIAL_MAP_SPECULAR)
export let MATERIAL_MAP_NORMAL = 2; // Normal material
export let MATERIAL_MAP_ROUGHNESS = 3; // Roughness material
export let MATERIAL_MAP_OCCLUSION = 4; // Ambient occlusion material
export let MATERIAL_MAP_EMISSION = 5; // Emission material
export let MATERIAL_MAP_HEIGHT = 6; // Heightmap material
export let MATERIAL_MAP_CUBEMAP = 7; // Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
export let MATERIAL_MAP_IRRADIANCE = 8; // Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
export let MATERIAL_MAP_PREFILTER = 9; // Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
export let MATERIAL_MAP_BRDF = 10; // Brdf material

// ShaderLocationIndex
export let SHADER_LOC_VERTEX_POSITION = 0; // Shader location: vertex attribute: position
export let SHADER_LOC_VERTEX_TEXCOORD01 = 1; // Shader location: vertex attribute: texcoord01
export let SHADER_LOC_VERTEX_TEXCOORD02 = 2; // Shader location: vertex attribute: texcoord02
export let SHADER_LOC_VERTEX_NORMAL = 3; // Shader location: vertex attribute: normal
export let SHADER_LOC_VERTEX_TANGENT = 4; // Shader location: vertex attribute: tangent
export let SHADER_LOC_VERTEX_COLOR = 5; // Shader location: vertex attribute: color
export let SHADER_LOC_MATRIX_MVP = 6; // Shader location: matrix uniform: model-view-projection
export let SHADER_LOC_MATRIX_VIEW = 7; // Shader location: matrix uniform: view (camera transform)
export let SHADER_LOC_MATRIX_PROJECTION = 8; // Shader location: matrix uniform: projection
export let SHADER_LOC_MATRIX_MODEL = 9; // Shader location: matrix uniform: model (transform)
export let SHADER_LOC_MATRIX_NORMAL = 10; // Shader location: matrix uniform: normal
export let SHADER_LOC_VECTOR_VIEW = 11; // Shader location: vector uniform: view
export let SHADER_LOC_COLOR_DIFFUSE = 12; // Shader location: vector uniform: diffuse color
export let SHADER_LOC_COLOR_SPECULAR = 13; // Shader location: vector uniform: specular color
export let SHADER_LOC_COLOR_AMBIENT = 14; // Shader location: vector uniform: ambient color
export let SHADER_LOC_MAP_ALBEDO = 15; // Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
export let SHADER_LOC_MAP_METALNESS = 16; // Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
export let SHADER_LOC_MAP_NORMAL = 17; // Shader location: sampler2d texture: normal
export let SHADER_LOC_MAP_ROUGHNESS = 18; // Shader location: sampler2d texture: roughness
export let SHADER_LOC_MAP_OCCLUSION = 19; // Shader location: sampler2d texture: occlusion
export let SHADER_LOC_MAP_EMISSION = 20; // Shader location: sampler2d texture: emission
export let SHADER_LOC_MAP_HEIGHT = 21; // Shader location: sampler2d texture: height
export let SHADER_LOC_MAP_CUBEMAP = 22; // Shader location: samplerCube texture: cubemap
export let SHADER_LOC_MAP_IRRADIANCE = 23; // Shader location: samplerCube texture: irradiance
export let SHADER_LOC_MAP_PREFILTER = 24; // Shader location: samplerCube texture: prefilter
export let SHADER_LOC_MAP_BRDF = 25; // Shader location: sampler2d texture: brdf

// ShaderUniformDataType
export let SHADER_UNIFORM_FLOAT = 0; // Shader uniform type: float
export let SHADER_UNIFORM_VEC2 = 1; // Shader uniform type: vec2 (2 float)
export let SHADER_UNIFORM_VEC3 = 2; // Shader uniform type: vec3 (3 float)
export let SHADER_UNIFORM_VEC4 = 3; // Shader uniform type: vec4 (4 float)
export let SHADER_UNIFORM_INT = 4; // Shader uniform type: int
export let SHADER_UNIFORM_IVEC2 = 5; // Shader uniform type: ivec2 (2 int)
export let SHADER_UNIFORM_IVEC3 = 6; // Shader uniform type: ivec3 (3 int)
export let SHADER_UNIFORM_IVEC4 = 7; // Shader uniform type: ivec4 (4 int)
export let SHADER_UNIFORM_SAMPLER2D = 8; // Shader uniform type: sampler2d

// ShaderAttributeDataType
export let SHADER_ATTRIB_FLOAT = 0; // Shader attribute type: float
export let SHADER_ATTRIB_VEC2 = 1; // Shader attribute type: vec2 (2 float)
export let SHADER_ATTRIB_VEC3 = 2; // Shader attribute type: vec3 (3 float)
export let SHADER_ATTRIB_VEC4 = 3; // Shader attribute type: vec4 (4 float)

// PixelFormat
export let PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1; // 8 bit per pixel (no alpha)
export let PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2; // 8*2 bpp (2 channels)
export let PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3; // 16 bpp
export let PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4; // 24 bpp
export let PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5; // 16 bpp (1 bit alpha)
export let PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6; // 16 bpp (4 bit alpha)
export let PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7; // 32 bpp
export let PIXELFORMAT_UNCOMPRESSED_R32 = 8; // 32 bpp (1 channel - float)
export let PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9; // 32*3 bpp (3 channels - float)
export let PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10; // 32*4 bpp (4 channels - float)
export let PIXELFORMAT_UNCOMPRESSED_R16 = 11; // 16 bpp (1 channel - half float)
export let PIXELFORMAT_UNCOMPRESSED_R16G16B16 = 12; // 16*3 bpp (3 channels - half float)
export let PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = 13; // 16*4 bpp (4 channels - half float)
export let PIXELFORMAT_COMPRESSED_DXT1_RGB = 14; // 4 bpp (no alpha)
export let PIXELFORMAT_COMPRESSED_DXT1_RGBA = 15; // 4 bpp (1 bit alpha)
export let PIXELFORMAT_COMPRESSED_DXT3_RGBA = 16; // 8 bpp
export let PIXELFORMAT_COMPRESSED_DXT5_RGBA = 17; // 8 bpp
export let PIXELFORMAT_COMPRESSED_ETC1_RGB = 18; // 4 bpp
export let PIXELFORMAT_COMPRESSED_ETC2_RGB = 19; // 4 bpp
export let PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 20; // 8 bpp
export let PIXELFORMAT_COMPRESSED_PVRT_RGB = 21; // 4 bpp
export let PIXELFORMAT_COMPRESSED_PVRT_RGBA = 22; // 4 bpp
export let PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 23; // 8 bpp
export let PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 24; // 2 bpp

// TextureFilter
export let TEXTURE_FILTER_POINT = 0; // No filter, just pixel approximation
export let TEXTURE_FILTER_BILINEAR = 1; // Linear filtering
export let TEXTURE_FILTER_TRILINEAR = 2; // Trilinear filtering (linear with mipmaps)
export let TEXTURE_FILTER_ANISOTROPIC_4X = 3; // Anisotropic filtering 4x
export let TEXTURE_FILTER_ANISOTROPIC_8X = 4; // Anisotropic filtering 8x
export let TEXTURE_FILTER_ANISOTROPIC_16X = 5; // Anisotropic filtering 16x

// TextureWrap
export let TEXTURE_WRAP_REPEAT = 0; // Repeats texture in tiled mode
export let TEXTURE_WRAP_CLAMP = 1; // Clamps texture to edge pixel in tiled mode
export let TEXTURE_WRAP_MIRROR_REPEAT = 2; // Mirrors and repeats the texture in tiled mode
export let TEXTURE_WRAP_MIRROR_CLAMP = 3; // Mirrors and clamps to border the texture in tiled mode

// CubemapLayout
export let CUBEMAP_LAYOUT_AUTO_DETECT = 0; // Automatically detect layout type
export let CUBEMAP_LAYOUT_LINE_VERTICAL = 1; // Layout is defined by a vertical line with faces
export let CUBEMAP_LAYOUT_LINE_HORIZONTAL = 2; // Layout is defined by a horizontal line with faces
export let CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR = 3; // Layout is defined by a 3x4 cross with cubemap faces
export let CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE = 4; // Layout is defined by a 4x3 cross with cubemap faces
export let CUBEMAP_LAYOUT_PANORAMA = 5; // Layout is defined by a panorama image (equirrectangular map)

// FontType
export let FONT_DEFAULT = 0; // Default font generation, anti-aliased
export let FONT_BITMAP = 1; // Bitmap font generation, no anti-aliasing
export let FONT_SDF = 2; // SDF font generation, requires external shader

// BlendMode
export let BLEND_ALPHA = 0; // Blend textures considering alpha (default)
export let BLEND_ADDITIVE = 1; // Blend textures adding colors
export let BLEND_MULTIPLIED = 2; // Blend textures multiplying colors
export let BLEND_ADD_COLORS = 3; // Blend textures adding colors (alternative)
export let BLEND_SUBTRACT_COLORS = 4; // Blend textures subtracting colors (alternative)
export let BLEND_ALPHA_PREMULTIPLY = 5; // Blend premultiplied textures considering alpha
export let BLEND_CUSTOM = 6; // Blend textures using custom src/dst factors (use rlSetBlendFactors())
export let BLEND_CUSTOM_SEPARATE = 7; // Blend textures using custom rgb/alpha separate src/dst factors (use rlSetBlendFactorsSeparate())

// Gesture
export let GESTURE_NONE = 0; // No gesture
export let GESTURE_TAP = 1; // Tap gesture
export let GESTURE_DOUBLETAP = 2; // Double tap gesture
export let GESTURE_HOLD = 4; // Hold gesture
export let GESTURE_DRAG = 8; // Drag gesture
export let GESTURE_SWIPE_RIGHT = 16; // Swipe right gesture
export let GESTURE_SWIPE_LEFT = 32; // Swipe left gesture
export let GESTURE_SWIPE_UP = 64; // Swipe up gesture
export let GESTURE_SWIPE_DOWN = 128; // Swipe down gesture
export let GESTURE_PINCH_IN = 256; // Pinch in gesture
export let GESTURE_PINCH_OUT = 512; // Pinch out gesture

// CameraMode
export let CAMERA_CUSTOM = 0; // Custom camera
export let CAMERA_FREE = 1; // Free camera
export let CAMERA_ORBITAL = 2; // Orbital camera
export let CAMERA_FIRST_PERSON = 3; // First person camera
export let CAMERA_THIRD_PERSON = 4; // Third person camera

// CameraProjection
export let CAMERA_PERSPECTIVE = 0; // Perspective projection
export let CAMERA_ORTHOGRAPHIC = 1; // Orthographic projection

// NPatchLayout
export let NPATCH_NINE_PATCH = 0; // Npatch layout: 3x3 tiles
export let NPATCH_THREE_PATCH_VERTICAL = 1; // Npatch layout: 1x3 tiles
export let NPATCH_THREE_PATCH_HORIZONTAL = 2; // Npatch layout: 3x1 tiles

// rlGlVersion
export let RL_OPENGL_11 = 1; // OpenGL 1.1
export let RL_OPENGL_21 = 2; // OpenGL 2.1 (GLSL 120)
export let RL_OPENGL_33 = 3; // OpenGL 3.3 (GLSL 330)
export let RL_OPENGL_43 = 4; // OpenGL 4.3 (using GLSL 330)
export let RL_OPENGL_ES_20 = 5; // OpenGL ES 2.0 (GLSL 100)
export let RL_OPENGL_ES_30 = 6; // OpenGL ES 3.0 (GLSL 300 es)

// rlTraceLogLevel
export let RL_LOG_ALL = 0; // Display all logs
export let RL_LOG_TRACE = 1; // Trace logging, intended for internal use only
export let RL_LOG_DEBUG = 2; // Debug logging, used for internal debugging, it should be disabled on release builds
export let RL_LOG_INFO = 3; // Info logging, used for program execution info
export let RL_LOG_WARNING = 4; // Warning logging, used on recoverable failures
export let RL_LOG_ERROR = 5; // Error logging, used on unrecoverable failures
export let RL_LOG_FATAL = 6; // Fatal logging, used to abort program: exit(EXIT_FAILURE)
export let RL_LOG_NONE = 7; // Disable logging

// rlPixelFormat
export let RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1; // 8 bit per pixel (no alpha)
export let RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2; // 8*2 bpp (2 channels)
export let RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3; // 16 bpp
export let RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4; // 24 bpp
export let RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5; // 16 bpp (1 bit alpha)
export let RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6; // 16 bpp (4 bit alpha)
export let RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7; // 32 bpp
export let RL_PIXELFORMAT_UNCOMPRESSED_R32 = 8; // 32 bpp (1 channel - float)
export let RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9; // 32*3 bpp (3 channels - float)
export let RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10; // 32*4 bpp (4 channels - float)
export let RL_PIXELFORMAT_UNCOMPRESSED_R16 = 11; // 16 bpp (1 channel - half float)
export let RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16 = 12; // 16*3 bpp (3 channels - half float)
export let RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = 13; // 16*4 bpp (4 channels - half float)
export let RL_PIXELFORMAT_COMPRESSED_DXT1_RGB = 14; // 4 bpp (no alpha)
export let RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA = 15; // 4 bpp (1 bit alpha)
export let RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA = 16; // 8 bpp
export let RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA = 17; // 8 bpp
export let RL_PIXELFORMAT_COMPRESSED_ETC1_RGB = 18; // 4 bpp
export let RL_PIXELFORMAT_COMPRESSED_ETC2_RGB = 19; // 4 bpp
export let RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 20; // 8 bpp
export let RL_PIXELFORMAT_COMPRESSED_PVRT_RGB = 21; // 4 bpp
export let RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA = 22; // 4 bpp
export let RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 23; // 8 bpp
export let RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 24; // 2 bpp

// rlTextureFilter
export let RL_TEXTURE_FILTER_POINT = 0; // No filter, just pixel approximation
export let RL_TEXTURE_FILTER_BILINEAR = 1; // Linear filtering
export let RL_TEXTURE_FILTER_TRILINEAR = 2; // Trilinear filtering (linear with mipmaps)
export let RL_TEXTURE_FILTER_ANISOTROPIC_4X = 3; // Anisotropic filtering 4x
export let RL_TEXTURE_FILTER_ANISOTROPIC_8X = 4; // Anisotropic filtering 8x
export let RL_TEXTURE_FILTER_ANISOTROPIC_16X = 5; // Anisotropic filtering 16x

// rlBlendMode
export let RL_BLEND_ALPHA = 0; // Blend textures considering alpha (default)
export let RL_BLEND_ADDITIVE = 1; // Blend textures adding colors
export let RL_BLEND_MULTIPLIED = 2; // Blend textures multiplying colors
export let RL_BLEND_ADD_COLORS = 3; // Blend textures adding colors (alternative)
export let RL_BLEND_SUBTRACT_COLORS = 4; // Blend textures subtracting colors (alternative)
export let RL_BLEND_ALPHA_PREMULTIPLY = 5; // Blend premultiplied textures considering alpha
export let RL_BLEND_CUSTOM = 6; // Blend textures using custom src/dst factors (use rlSetBlendFactors())
export let RL_BLEND_CUSTOM_SEPARATE = 7; // Blend textures using custom src/dst factors (use rlSetBlendFactorsSeparate())

// rlShaderLocationIndex
export let RL_SHADER_LOC_VERTEX_POSITION = 0; // Shader location: vertex attribute: position
export let RL_SHADER_LOC_VERTEX_TEXCOORD01 = 1; // Shader location: vertex attribute: texcoord01
export let RL_SHADER_LOC_VERTEX_TEXCOORD02 = 2; // Shader location: vertex attribute: texcoord02
export let RL_SHADER_LOC_VERTEX_NORMAL = 3; // Shader location: vertex attribute: normal
export let RL_SHADER_LOC_VERTEX_TANGENT = 4; // Shader location: vertex attribute: tangent
export let RL_SHADER_LOC_VERTEX_COLOR = 5; // Shader location: vertex attribute: color
export let RL_SHADER_LOC_MATRIX_MVP = 6; // Shader location: matrix uniform: model-view-projection
export let RL_SHADER_LOC_MATRIX_VIEW = 7; // Shader location: matrix uniform: view (camera transform)
export let RL_SHADER_LOC_MATRIX_PROJECTION = 8; // Shader location: matrix uniform: projection
export let RL_SHADER_LOC_MATRIX_MODEL = 9; // Shader location: matrix uniform: model (transform)
export let RL_SHADER_LOC_MATRIX_NORMAL = 10; // Shader location: matrix uniform: normal
export let RL_SHADER_LOC_VECTOR_VIEW = 11; // Shader location: vector uniform: view
export let RL_SHADER_LOC_COLOR_DIFFUSE = 12; // Shader location: vector uniform: diffuse color
export let RL_SHADER_LOC_COLOR_SPECULAR = 13; // Shader location: vector uniform: specular color
export let RL_SHADER_LOC_COLOR_AMBIENT = 14; // Shader location: vector uniform: ambient color
export let RL_SHADER_LOC_MAP_ALBEDO = 15; // Shader location: sampler2d texture: albedo (same as: RL_SHADER_LOC_MAP_DIFFUSE)
export let RL_SHADER_LOC_MAP_METALNESS = 16; // Shader location: sampler2d texture: metalness (same as: RL_SHADER_LOC_MAP_SPECULAR)
export let RL_SHADER_LOC_MAP_NORMAL = 17; // Shader location: sampler2d texture: normal
export let RL_SHADER_LOC_MAP_ROUGHNESS = 18; // Shader location: sampler2d texture: roughness
export let RL_SHADER_LOC_MAP_OCCLUSION = 19; // Shader location: sampler2d texture: occlusion
export let RL_SHADER_LOC_MAP_EMISSION = 20; // Shader location: sampler2d texture: emission
export let RL_SHADER_LOC_MAP_HEIGHT = 21; // Shader location: sampler2d texture: height
export let RL_SHADER_LOC_MAP_CUBEMAP = 22; // Shader location: samplerCube texture: cubemap
export let RL_SHADER_LOC_MAP_IRRADIANCE = 23; // Shader location: samplerCube texture: irradiance
export let RL_SHADER_LOC_MAP_PREFILTER = 24; // Shader location: samplerCube texture: prefilter
export let RL_SHADER_LOC_MAP_BRDF = 25; // Shader location: sampler2d texture: brdf

// rlShaderUniformDataType
export let RL_SHADER_UNIFORM_FLOAT = 0; // Shader uniform type: float
export let RL_SHADER_UNIFORM_VEC2 = 1; // Shader uniform type: vec2 (2 float)
export let RL_SHADER_UNIFORM_VEC3 = 2; // Shader uniform type: vec3 (3 float)
export let RL_SHADER_UNIFORM_VEC4 = 3; // Shader uniform type: vec4 (4 float)
export let RL_SHADER_UNIFORM_INT = 4; // Shader uniform type: int
export let RL_SHADER_UNIFORM_IVEC2 = 5; // Shader uniform type: ivec2 (2 int)
export let RL_SHADER_UNIFORM_IVEC3 = 6; // Shader uniform type: ivec3 (3 int)
export let RL_SHADER_UNIFORM_IVEC4 = 7; // Shader uniform type: ivec4 (4 int)
export let RL_SHADER_UNIFORM_SAMPLER2D = 8; // Shader uniform type: sampler2d

// rlShaderAttributeDataType
export let RL_SHADER_ATTRIB_FLOAT = 0; // Shader attribute type: float
export let RL_SHADER_ATTRIB_VEC2 = 1; // Shader attribute type: vec2 (2 float)
export let RL_SHADER_ATTRIB_VEC3 = 2; // Shader attribute type: vec3 (3 float)
export let RL_SHADER_ATTRIB_VEC4 = 3; // Shader attribute type: vec4 (4 float)

// rlFramebufferAttachType
export let RL_ATTACHMENT_COLOR_CHANNEL0 = 0; // Framebuffer attachment type: color 0
export let RL_ATTACHMENT_COLOR_CHANNEL1 = 1; // Framebuffer attachment type: color 1
export let RL_ATTACHMENT_COLOR_CHANNEL2 = 2; // Framebuffer attachment type: color 2
export let RL_ATTACHMENT_COLOR_CHANNEL3 = 3; // Framebuffer attachment type: color 3
export let RL_ATTACHMENT_COLOR_CHANNEL4 = 4; // Framebuffer attachment type: color 4
export let RL_ATTACHMENT_COLOR_CHANNEL5 = 5; // Framebuffer attachment type: color 5
export let RL_ATTACHMENT_COLOR_CHANNEL6 = 6; // Framebuffer attachment type: color 6
export let RL_ATTACHMENT_COLOR_CHANNEL7 = 7; // Framebuffer attachment type: color 7
export let RL_ATTACHMENT_DEPTH = 100; // Framebuffer attachment type: depth
export let RL_ATTACHMENT_STENCIL = 200; // Framebuffer attachment type: stencil

// rlFramebufferAttachTextureType
export let RL_ATTACHMENT_CUBEMAP_POSITIVE_X = 0; // Framebuffer texture attachment type: cubemap, +X side
export let RL_ATTACHMENT_CUBEMAP_NEGATIVE_X = 1; // Framebuffer texture attachment type: cubemap, -X side
export let RL_ATTACHMENT_CUBEMAP_POSITIVE_Y = 2; // Framebuffer texture attachment type: cubemap, +Y side
export let RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y = 3; // Framebuffer texture attachment type: cubemap, -Y side
export let RL_ATTACHMENT_CUBEMAP_POSITIVE_Z = 4; // Framebuffer texture attachment type: cubemap, +Z side
export let RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z = 5; // Framebuffer texture attachment type: cubemap, -Z side
export let RL_ATTACHMENT_TEXTURE2D = 100; // Framebuffer texture attachment type: texture2d
export let RL_ATTACHMENT_RENDERBUFFER = 200; // Framebuffer texture attachment type: renderbuffer

// rlCullMode
export let RL_CULL_FACE_FRONT = 0; // 
export let RL_CULL_FACE_BACK = 1; // 

export let GuiState = Int;
export let GuiTextAlignment = Int;
export let GuiTextAlignmentVertical = Int;
export let GuiTextWrapMode = Int;
export let GuiControl = Int;
export let GuiControlProperty = Int;
export let GuiDefaultProperty = Int;
export let GuiToggleProperty = Int;
export let GuiSliderProperty = Int;
export let GuiProgressBarProperty = Int;
export let GuiScrollBarProperty = Int;
export let GuiCheckBoxProperty = Int;
export let GuiComboBoxProperty = Int;
export let GuiDropdownBoxProperty = Int;
export let GuiTextBoxProperty = Int;
export let GuiSpinnerProperty = Int;
export let GuiListViewProperty = Int;
export let GuiColorPickerProperty = Int;
export let ConfigFlags = Int;
export let TraceLogLevel = Int;
export let KeyboardKey = Int;
export let MouseButton = Int;
export let MouseCursor = Int;
export let GamepadButton = Int;
export let GamepadAxis = Int;
export let MaterialMapIndex = Int;
export let ShaderLocationIndex = Int;
export let ShaderUniformDataType = Int;
export let ShaderAttributeDataType = Int;
export let PixelFormat = Int;
export let TextureFilter = Int;
export let TextureWrap = Int;
export let CubemapLayout = Int;
export let FontType = Int;
export let BlendMode = Int;
export let Gesture = Int;
export let CameraMode = Int;
export let CameraProjection = Int;
export let NPatchLayout = Int;
export let rlGlVersion = Int;
export let rlTraceLogLevel = Int;
export let rlPixelFormat = Int;
export let rlTextureFilter = Int;
export let rlBlendMode = Int;
export let rlShaderLocationIndex = Int;
export let rlShaderUniformDataType = Int;
export let rlShaderAttributeDataType = Int;
export let rlFramebufferAttachType = Int;
export let rlFramebufferAttachTextureType = Int;
export let rlCullMode = Int;
// NOTE: Used when exporting style as code for convenience
export class GuiStyleProp {
    // Control identifier
    public var controlId: Int;
    // Property identifier
    public var propertyId: Int;
    // Property value
    public var propertyValue: Int;
}
// NOTE: Text style is defined by control
export class GuiTextStyle {
    // 
    public var size: Int;
    // 
    public var charSpacing: Int;
    // 
    public var lineSpacing: Int;
    // 
    public var alignmentH: Int;
    // 
    public var alignmentV: Int;
    // 
    public var padding: Int;
}
// Vector2, 2 components
export class Vector2 {
    // Vector x component
    public var x: Float64;
    // Vector y component
    public var y: Float64;
}
// Vector3, 3 components
export class Vector3 {
    // Vector x component
    public var x: Float64;
    // Vector y component
    public var y: Float64;
    // Vector z component
    public var z: Float64;
}
// Vector4, 4 components
export class Vector4 {
    // Vector x component
    public var x: Float64;
    // Vector y component
    public var y: Float64;
    // Vector z component
    public var z: Float64;
    // Vector w component
    public var w: Float64;
}
// Matrix, 4x4 components, column major, OpenGL style, right-handed
export class Matrix {
    // Matrix first row (4 components)
    public var m0: Float64;
    // Matrix first row (4 components)
    public var m4: Float64;
    // Matrix first row (4 components)
    public var m8: Float64;
    // Matrix first row (4 components)
    public var m12: Float64;
    // Matrix second row (4 components)
    public var m1: Float64;
    // Matrix second row (4 components)
    public var m5: Float64;
    // Matrix second row (4 components)
    public var m9: Float64;
    // Matrix second row (4 components)
    public var m13: Float64;
    // Matrix third row (4 components)
    public var m2: Float64;
    // Matrix third row (4 components)
    public var m6: Float64;
    // Matrix third row (4 components)
    public var m10: Float64;
    // Matrix third row (4 components)
    public var m14: Float64;
    // Matrix fourth row (4 components)
    public var m3: Float64;
    // Matrix fourth row (4 components)
    public var m7: Float64;
    // Matrix fourth row (4 components)
    public var m11: Float64;
    // Matrix fourth row (4 components)
    public var m15: Float64;
}
// Color, 4 components, R8G8B8A8 (32bit)
export class Color {
    // Color red value
    public var r: Int;
    // Color green value
    public var g: Int;
    // Color blue value
    public var b: Int;
    // Color alpha value
    public var a: Int;
}
// Rectangle, 4 components
export class Rectangle {
    // Rectangle top-left corner position x
    public var x: Float64;
    // Rectangle top-left corner position y
    public var y: Float64;
    // Rectangle width
    public var width: Float64;
    // Rectangle height
    public var height: Float64;
}
// Image, pixel data stored in CPU memory (RAM)
export class Image {
    // Image raw data
    public var data: DenseBitVector;
    // Image base width
    public var width: Int;
    // Image base height
    public var height: Int;
    // Mipmap levels, 1 by default
    public var mipmaps: Int;
    // Data format (PixelFormat type)
    public var format: Int;
}
// Texture, tex data stored in GPU memory (VRAM)
export class Texture {
    // OpenGL texture id
    public var id: Int;
    // Texture base width
    public var width: Int;
    // Texture base height
    public var height: Int;
    // Mipmap levels, 1 by default
    public var mipmaps: Int;
    // Data format (PixelFormat type)
    public var format: Int;
}
// RenderTexture, fbo for texture rendering
export class RenderTexture {
    // OpenGL framebuffer object id
    public var id: Int;
    // Color buffer attachment texture
    public var texture: Texture;
    // Depth buffer attachment texture
    public var depth: Texture;
}
// NPatchInfo, n-patch layout info
export class NPatchInfo {
    // Texture source rectangle
    public var source: Rectangle;
    // Left border offset
    public var left: Int;
    // Top border offset
    public var top: Int;
    // Right border offset
    public var right: Int;
    // Bottom border offset
    public var bottom: Int;
    // Layout of the n-patch: 3x3, 1x3 or 3x1
    public var layout: Int;
}
// GlyphInfo, font characters glyphs info
export class GlyphInfo {
    // Character value (Unicode)
    public var value: Int;
    // Character offset X when drawing
    public var offsetX: Int;
    // Character offset Y when drawing
    public var offsetY: Int;
    // Character advance position X
    public var advanceX: Int;
    // Character image data
    public var image: Image;
}
// Font, font texture and GlyphInfo array data
export class Font {
    // Base size (default chars height)
    public var baseSize: Int;
    // Number of glyph characters
    public var glyphCount: Int;
    // Padding around the glyph characters
    public var glyphPadding: Int;
    // Texture atlas containing the glyphs
    public var texture: Texture2D;
    // Rectangles in texture for the glyphs
    public var recs: Listed<Rectangle>;
    // Glyphs info data
    public var glyphs: Listed<GlyphInfo>;
}
// Camera, defines position/orientation in 3d space
export class Camera3D {
    // Camera position
    public var position: Vector3;
    // Camera target it looks-at
    public var target: Vector3;
    // Camera up vector (rotation over its axis)
    public var up: Vector3;
    // Camera field-of-view aperture in Y (degrees) in perspective, used as near plane width in orthographic
    public var fovy: Float64;
    // Camera projection: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
    public var projection: Int;
}
// Camera2D, defines position/orientation in 2d space
export class Camera2D {
    // Camera offset (displacement from target)
    public var offset: Vector2;
    // Camera target (rotation and zoom origin)
    public var target: Vector2;
    // Camera rotation in degrees
    public var rotation: Float64;
    // Camera zoom (scaling), should be 1.0f by default
    public var zoom: Float64;
}
// Mesh, vertex data and vao/vbo
export class Mesh {
    // Number of vertices stored in arrays
    public var vertexCount: Int;
    // Number of triangles stored (indexed or not)
    public var triangleCount: Int;
    // Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
    public var vertices: Listed<Float64>;
    // Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
    public var texcoords: Listed<Float64>;
    // Vertex texture second coordinates (UV - 2 components per vertex) (shader-location = 5)
    public var texcoords2: Listed<Float64>;
    // Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)
    public var normals: Listed<Float64>;
    // Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)
    public var tangents: Listed<Float64>;
    // Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
    public var colors: Listed<Int>;
    // Vertex indices (in case vertex data comes indexed)
    public var indices: Listed<Int>;
    // Animated vertex positions (after bones transformations)
    public var animVertices: Listed<Float64>;
    // Animated normals (after bones transformations)
    public var animNormals: Listed<Float64>;
    // Vertex bone ids, max 255 bone ids, up to 4 bones influence by vertex (skinning)
    public var boneIds: Listed<Int>;
    // Vertex bone weight, up to 4 bones influence by vertex (skinning)
    public var boneWeights: Listed<Float64>;
    // OpenGL Vertex Array Object id
    public var vaoId: Int;
    // OpenGL Vertex Buffer Objects id (default vertex data)
    public var vboId: Listed<Int>;
}
// Shader
export class Shader {
    // Shader program id
    public var id: Int;
    // Shader locations array (RL_MAX_SHADER_LOCATIONS)
    public var locs: Listed<Int>;
}
// MaterialMap
export class MaterialMap {
    // Material map texture
    public var texture: Texture2D;
    // Material map color
    public var color: Color;
    // Material map value
    public var value: Float64;
}
// Material, includes shader and maps
export class Material {
    // Material shader
    public var shader: Shader;
    // Material maps array (MAX_MATERIAL_MAPS)
    public var maps: Listed<MaterialMap>;
    // Material generic parameters (if required)
    public var params: Listed<Float64>;
}
// Transform, vertex transformation data
export class Transform {
    // Translation
    public var translation: Vector3;
    // Rotation
    public var rotation: Quaternion;
    // Scale
    public var scale: Vector3;
}
// Bone, skeletal animation bone
export class BoneInfo {
    // Bone name
    public var name: String;
    // Bone parent
    public var parent: Int;
}
// Model, meshes, materials and animation data
export class Model {
    // Local transform matrix
    public var transform: Matrix;
    // Number of meshes
    public var meshCount: Int;
    // Number of materials
    public var materialCount: Int;
    // Meshes array
    public var meshes: Listed<Mesh>;
    // Materials array
    public var materials: Listed<Material>;
    // Mesh material number
    public var meshMaterial: Listed<Int>;
    // Number of bones
    public var boneCount: Int;
    // Bones information (skeleton)
    public var bones: Listed<BoneInfo>;
    // Bones base transformation (pose)
    public var bindPose: Listed<Transform>;
}
// ModelAnimation
export class ModelAnimation {
    // Number of bones
    public var boneCount: Int;
    // Number of animation frames
    public var frameCount: Int;
    // Bones information (skeleton)
    public var bones: Listed<BoneInfo>;
    // Poses array by frame
    public var framePoses: Listed<Listed<Transform>>;
    // Animation name
    public var name: String;
}
// Ray, ray for raycasting
export class Ray {
    // Ray position (origin)
    public var position: Vector3;
    // Ray direction
    public var direction: Vector3;
}
// RayCollision, ray hit information
export class RayCollision {
    // Did the ray hit something?
    public var hit: Boolean;
    // Distance to the nearest hit
    public var distance: Float64;
    // Point of the nearest hit
    public var point: Vector3;
    // Surface normal of hit
    public var normal: Vector3;
}
// BoundingBox
export class BoundingBox {
    // Minimum vertex box-corner
    public var min: Vector3;
    // Maximum vertex box-corner
    public var max: Vector3;
}
// Wave, audio wave data
export class Wave {
    // Total number of frames (considering channels)
    public var frameCount: Int;
    // Frequency (samples per second)
    public var sampleRate: Int;
    // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
    public var sampleSize: Int;
    // Number of channels (1-mono, 2-stereo, ...)
    public var channels: Int;
    // Buffer data pointer
    public var data: DenseBitVector;
}
// AudioStream, custom audio stream
export class AudioStream {
    // Pointer to internal data used by the audio system
    public var buffer: Listed<AnyValue>;
    // Pointer to internal data processor, useful for audio effects
    public var processor: Listed<AnyValue>;
    // Frequency (samples per second)
    public var sampleRate: Int;
    // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
    public var sampleSize: Int;
    // Number of channels (1-mono, 2-stereo, ...)
    public var channels: Int;
}
// Sound
export class Sound {
    // Audio stream
    public var stream: AudioStream;
    // Total number of frames (considering channels)
    public var frameCount: Int;
}
// Music, audio stream, anything longer than ~10 seconds should be streamed
export class Music {
    // Audio stream
    public var stream: AudioStream;
    // Total number of frames (considering channels)
    public var frameCount: Int;
    // Music looping enable
    public var looping: Boolean;
    // Type of music context (audio filetype)
    public var ctxType: Int;
    // Audio context data, depends on type
    public var ctxData: DenseBitVector;
}
// VrDeviceInfo, Head-Mounted-Display device parameters
export class VrDeviceInfo {
    // Horizontal resolution in pixels
    public var hResolution: Int;
    // Vertical resolution in pixels
    public var vResolution: Int;
    // Horizontal size in meters
    public var hScreenSize: Float64;
    // Vertical size in meters
    public var vScreenSize: Float64;
    // Distance between eye and display in meters
    public var eyeToScreenDistance: Float64;
    // Lens separation distance in meters
    public var lensSeparationDistance: Float64;
    // IPD (distance between pupils) in meters
    public var interpupillaryDistance: Float64;
    // Lens distortion constant parameters
    public var lensDistortionValues: Listed<Float64>;
    // Chromatic aberration correction parameters
    public var chromaAbCorrection: Listed<Float64>;
}
// VrStereoConfig, VR stereo rendering configuration for simulator
export class VrStereoConfig {
    // VR projection matrices (per eye)
    public var projection: Listed<Matrix>;
    // VR view offset matrices (per eye)
    public var viewOffset: Listed<Matrix>;
    // VR left lens center
    public var leftLensCenter: Listed<Float64>;
    // VR right lens center
    public var rightLensCenter: Listed<Float64>;
    // VR left screen center
    public var leftScreenCenter: Listed<Float64>;
    // VR right screen center
    public var rightScreenCenter: Listed<Float64>;
    // VR distortion scale
    public var scale: Listed<Float64>;
    // VR distortion scale in
    public var scaleIn: Listed<Float64>;
}
// File path list
export class FilePathList {
    // Filepaths max entries
    public var capacity: Int;
    // Filepaths entries count
    public var count: Int;
    // Filepaths entries
    public var paths: Listed<String>;
}
// Automation event
export class AutomationEvent {
    // Event frame
    public var frame: Int;
    // Event type (AutomationEventType)
    public var type: Int;
    // Event parameters (if required)
    public var params: Listed<Int>;
}
// Automation event list
export class AutomationEventList {
    // Events max entries (MAX_AUTOMATION_EVENTS)
    public var capacity: Int;
    // Events entries count
    public var count: Int;
    // Events entries
    public var events: Listed<AutomationEvent>;
}
// NOTE: Helper types to be used instead of array return types for *ToFloat functions
export class float3 {
    // 
    public var v: Listed<Float64>;
}
// 
export class float16 {
    // 
    public var v: Listed<Float64>;
}
// Dynamic vertex buffers (position + texcoords + colors + indices arrays)
export class rlVertexBuffer {
    // Number of elements in the buffer (QUADS)
    public var elementCount: Int;
    // Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
    public var vertices: Listed<Float64>;
    // Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
    public var texcoords: Listed<Float64>;
    // Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
    public var colors: Listed<Int>;
    // OpenGL Vertex Array Object id
    public var vaoId: Int;
    // OpenGL Vertex Buffer Objects id (4 types of vertex data)
    public var vboId: Listed<Int>;
}
// of those state-change happens (this is done in core module)
export class rlDrawCall {
    // Drawing mode: LINES, TRIANGLES, QUADS
    public var mode: Int;
    // Number of vertex of the draw
    public var vertexCount: Int;
    // Number of vertex required for index alignment (LINES, TRIANGLES)
    public var vertexAlignment: Int;
    // Texture id to be used on the draw -> Use to create new draw call if changes
    public var textureId: Int;
}
// rlRenderBatch type
export class rlRenderBatch {
    // Number of vertex buffers (multi-buffering support)
    public var bufferCount: Int;
    // Current buffer tracking in case of multi-buffering
    public var currentBuffer: Int;
    // Dynamic buffer(s) for vertex data
    public var vertexBuffer: Listed<rlVertexBuffer>;
    // Draw calls array, depends on textureId
    public var draws: Listed<rlDrawCall>;
    // Draw calls counter
    public var drawCounter: Int;
    // Current depth value for next draw
    public var currentDepth: Float64;
}
// Quaternion, 4 components (Vector4 alias)
export const Quaternion = Vector4;
// Texture2D, same as Texture
export const Texture2D = Texture;
// TextureCubemap, same as Texture
export const TextureCubemap = Texture;
// RenderTexture2D, same as RenderTexture
export const RenderTexture2D = RenderTexture;
// Camera type fallback, defaults to Camera3D
export const Camera = Camera3D;
// FileIO: Load binary data
export let LoadFileDataCallback = fn(String, Listed<Int>): Listed<Int>;
// FileIO: Save binary data
export let SaveFileDataCallback = fn(String, DenseBitVector, Int): Boolean;
// FileIO: Load text data
export let LoadFileTextCallback = fn(String): String;
// FileIO: Save text data
export let SaveFileTextCallback = fn(String, String): Boolean;
// 
export let AudioCallback = fn(DenseBitVector, Int): Void;
